”l
EF:\Documents\GITrepos\Compil\Compil\Compil\Analyzer\SyntaxAnalyzer.cs
	namespace		 	
Compil		
 
{

 
class 	
SyntaxAnalyzer
 
{ 
private 
readonly 
LexicalAnalyzer (
_lexicalAnalyzer) 9
;9 :
private 
readonly 

Dictionary #
<# $
	TokenType$ -
,- .
(/ 0
NodeType0 8
,8 9
string: @
,@ A
intB E
,E F
intG J
)J K
>K L!
_exprTokenToNodeMatchM b
=c d
newe h

Dictionaryi s
<s t
	TokenTypet }
,} ~
(	 Ä
NodeType
Ä à
,
à â
string
ä ê
,
ê ë
int
í ï
,
ï ñ
int
ó ö
)
ö õ
>
õ ú
(
ú ù
)
ù û
{ 	
{ 
	TokenType 
. 
OR 
, 
( 
NodeType $
.$ %
OR% '
,' (
$str) ,
,, -
$num. /
,/ 0
$num1 2
)2 3
}3 4
,4 5
{ 
	TokenType 
. 
AND 
, 
( 
NodeType %
.% &
AND& )
,) *
$str+ .
,. /
$num0 1
,1 2
$num3 4
)4 5
}5 6
,6 7
{ 
	TokenType 
. 
NOT 
, 
( 
NodeType %
.% &
NOT& )
,) *
$str+ .
,. /
$num0 1
,1 2
$num3 4
)4 5
}5 6
,6 7
{ 
	TokenType 
. 

COMP_EQUAL !
,! "
(# $
NodeType$ ,
., -

COMP_EQUAL- 7
,7 8
$str9 =
,= >
$num? @
,@ A
$numB C
)C D
}D E
,E F
{ 
	TokenType 
. 
PLUS 
, 
( 
NodeType &
.& '
OP_PLUS' .
,. /
$str0 3
,3 4
$num5 6
,6 7
$num8 9
)9 :
}: ;
,; <
{ 
	TokenType 
. 
MINUS 
, 
( 
NodeType '
.' (
OP_MINUS( 0
,0 1
$str2 5
,5 6
$num7 8
,8 9
$num: ;
); <
}< =
,= >
{ 
	TokenType 
. 
POWER 
, 
( 
NodeType '
.' (
OP_POWER( 0
,0 1
$str2 5
,5 6
$num7 8
,8 9
$num: ;
); <
}< =
,= >
{ 
	TokenType 
. 
DIVIDE 
, 
(  
NodeType  (
.( )
	OP_DIVIDE) 2
,2 3
$str4 7
,7 8
$num9 :
,: ;
$num< =
)= >
}> ?
,? @
{ 
	TokenType 
. 
MODULO 
, 
(  
NodeType  (
.( )
	OP_MODULO) 2
,2 3
$str4 7
,7 8
$num9 :
,: ;
$num< =
)= >
}> ?
,? @
{ 
	TokenType 
. 
MULTIPLY 
,  
(! "
NodeType" *
.* +
OP_MULTIPLY+ 6
,6 7
$str8 ;
,; <
$num= >
,> ?
$num@ A
)A B
}B C
,C D
{ 
	TokenType 
. 
COMP_INFERIOR $
,$ %
(& '
NodeType' /
./ 0
COMP_INFERIOR0 =
,= >
$str? B
,B C
$numD E
,E F
$numG H
)H I
}I J
,J K
{ 
	TokenType 
. 
COMP_DIFFERENT %
,% &
(' (
NodeType( 0
.0 1
COMP_DIFFERENT1 ?
,? @
$strA E
,E F
$numG H
,H I
$numJ K
)K L
}L M
,M N
{   
	TokenType   
.   
COMP_SUPPERIOR   %
,  % &
(  ' (
NodeType  ( 0
.  0 1
COMP_SUPPERIOR  1 ?
,  ? @
$str  A D
,  D E
$num  F G
,  G H
$num  I J
)  J K
}  K L
,  L M
{!! 
	TokenType!! 
.!! "
COMP_INFERIOR_OR_EQUAL!! -
,!!- .
(!!/ 0
NodeType!!0 8
.!!8 9"
COMP_INFERIOR_OR_EQUAL!!9 O
,!!O P
$str!!Q U
,!!U V
$num!!W X
,!!X Y
$num!!Z [
)!![ \
}!!\ ]
,!!] ^
{"" 
	TokenType"" 
."" #
COMP_SUPPERIOR_OR_EQUAL"" .
,"". /
(""0 1
NodeType""1 9
.""9 :#
COMP_SUPPERIOR_OR_EQUAL"": Q
,""Q R
$str""S W
,""W X
$num""Y Z
,""Z [
$num""\ ]
)""] ^
}""^ _
,""_ `
}## 	
;##	 

public)) 
SyntaxAnalyzer)) 
()) 
LexicalAnalyzer)) -
lexicalAnalyser)). =
)))= >
{** 	
this++ 
.++ 
_lexicalAnalyzer++ !
=++" #
lexicalAnalyser++$ 3
;++3 4
},, 	
public11 
Node11 
Primary11 
(11 
)11 
{22 	
try33 
{44 
Node55 
node55 
;55 
if88 
(88 
_lexicalAnalyzer88 $
.88$ %
Next88% )
(88) *
)88* +
.88+ ,
Type88, 0
==881 3
	TokenType884 =
.88= >
CONSTANT88> F
)88F G
{99 
node:: 
=:: 
new:: 
Node:: #
(::# $
)::$ %
{::& '
Type::' +
=::, -
NodeType::. 6
.::6 7
CONSTANT::7 ?
,::? @
Value::A F
=::G H
_lexicalAnalyzer::I Y
.::Y Z
Next::Z ^
(::^ _
)::_ `
.::` a
Value::a f
.::f g
ToString::g o
(::o p
)::p q
}::q r
;::r s
_lexicalAnalyzer;; $
.;;$ %
Skip;;% )
(;;) *
);;* +
;;;+ ,
return<< 
node<< 
;<<  
}== 
if@@ 
(@@ 
_lexicalAnalyzer@@ $
.@@$ %
Next@@% )
(@@) *
)@@* +
.@@+ ,
Type@@, 0
==@@1 3
	TokenType@@4 =
.@@= >
PAR_OPEN@@> F
)@@F G
{AA 
_lexicalAnalyzerBB $
.BB$ %
SkipBB% )
(BB) *
)BB* +
;BB+ ,
nodeCC 
=CC 

ExpressionCC %
(CC% &
$numCC& '
)CC' (
;CC( )
_lexicalAnalyzerDD $
.DD$ %
AcceptDD% +
(DD+ ,
	TokenTypeDD, 5
.DD5 6
	PAR_CLOSEDD6 ?
)DD? @
;DD@ A
returnEE 
nodeEE 
;EE  
}FF 
ifII 
(II 
_lexicalAnalyzerII $
.II$ %
NextII% )
(II) *
)II* +
.II+ ,
TypeII, 0
==II1 3
	TokenTypeII4 =
.II= >
MINUSII> C
||IID F
_lexicalAnalyzerJJ $
.JJ$ %
NextJJ% )
(JJ) *
)JJ* +
.JJ+ ,
TypeJJ, 0
==JJ1 3
	TokenTypeJJ4 =
.JJ= >
PLUSJJ> B
||JJC E
_lexicalAnalyzerKK $
.KK$ %
NextKK% )
(KK) *
)KK* +
.KK+ ,
TypeKK, 0
==KK1 3
	TokenTypeKK4 =
.KK= >
NOTKK> A
)KKA B
{LL 
varMM 
(MM 
nodeTypeMM !
,MM! "
valMM# &
,MM& '
_MM( )
,MM) *
_MM+ ,
)MM, -
=MM. /!
_exprTokenToNodeMatchMM0 E
[MME F
_lexicalAnalyzerMMF V
.MMV W
NextMMW [
(MM[ \
)MM\ ]
.MM] ^
TypeMM^ b
]MMb c
;MMc d
nodeNN 
=NN 
newNN 
NodeNN #
(NN# $
)NN$ %
{NN& '
TypeNN' +
=NN, -
nodeTypeNN. 6
,NN6 7
ValueNN8 =
=NN> ?
valNN@ C
}NNC D
;NND E
_lexicalAnalyzerOO $
.OO$ %
SkipOO% )
(OO) *
)OO* +
;OO+ ,
nodePP 
.PP 
AddChildPP !
(PP! "

ExpressionPP" ,
(PP, -
$numPP- .
)PP. /
)PP/ 0
;PP0 1
returnQQ 
nodeQQ 
;QQ  
}RR 
throwUU 
newUU !
ArgumentNullExceptionUU /
(UU/ 0
$strUU0 C
)UUC D
;UUD E
}VV 
catchWW 
(WW #
NotImplementedExceptionWW *
eWW+ ,
)WW, -
{XX 
ConsoleYY 
.YY 
	WriteLineYY !
(YY! "
$strYY" <
)YY< =
;YY= >
ConsoleZZ 
.ZZ 
	WriteLineZZ !
(ZZ! "
eZZ" #
.ZZ# $

StackTraceZZ$ .
)ZZ. /
;ZZ/ 0
return[[ 
null[[ 
;[[ 
}\\ 
catch]] 
(]] !
ArgumentNullException]] (
e]]) *
)]]* +
{^^ 
Console__ 
.__ 
	WriteLine__ !
(__! "
e__" #
.__# $

StackTrace__$ .
)__. /
;__/ 0
return`` 
null`` 
;`` 
}aa 
}bb 	
publicii 
Nodeii 

Expressionii 
(ii 
intii "
pMinii# '
)ii' (
{jj 	
varkk 
leftNodekk 
=kk 
Primarykk "
(kk" #
)kk# $
;kk$ %
whilemm 
(mm 
truemm 
)mm 
{mm 
ifnn 
(nn 
_lexicalAnalyzernn $
.nn$ %
Nextnn% )
(nn) *
)nn* +
==nn, .
nullnn/ 3
)nn3 4
returnoo 
leftNodeoo #
;oo# $
varqq 
opqq 
=qq 
SearchOpqq !
(qq! "
_lexicalAnalyzerqq" 2
.qq2 3
Nextqq3 7
(qq7 8
)qq8 9
)qq9 :
;qq: ;
ifss 
(ss 
opss 
==ss 
nullss 
||ss !
opss" $
.ss$ %
Priorityss% -
<ss. /
pMinss0 4
)ss4 5
returntt 
leftNodett #
;tt# $
_lexicalAnalyzervv  
.vv  !
Skipvv! %
(vv% &
)vv& '
;vv' (
varww 
	rightNodeww 
=ww 

Expressionww  *
(ww* +
opww+ -
.ww- .
Priorityww. 6
+ww7 8
opww9 ;
.ww; <
Associationww< G
)wwG H
;wwH I
varxx 
treexx 
=xx 
newxx 
Nodexx #
(xx# $
)xx$ %
{xx& '
Typexx( ,
=xx- .
opxx/ 1
.xx1 2
Nodexx2 6
.xx6 7
Typexx7 ;
}xx< =
;xx= >
treeyy 
.yy 
AddChildyy 
(yy 
leftNodeyy &
)yy& '
;yy' (
treezz 
.zz 
AddChildzz 
(zz 
	rightNodezz '
)zz' (
;zz( )
leftNode{{ 
={{ 
tree{{ 
;{{  
}|| 
}}} 	
public
ÑÑ 
Operator
ÑÑ 
SearchOp
ÑÑ  
(
ÑÑ  !
Token
ÑÑ! &
token
ÑÑ' ,
)
ÑÑ, -
{
ÖÖ 	
if
ÜÜ 
(
ÜÜ #
_exprTokenToNodeMatch
ÜÜ %
.
ÜÜ% &
TryGetValue
ÜÜ& 1
(
ÜÜ1 2
token
ÜÜ2 7
.
ÜÜ7 8
Type
ÜÜ8 <
,
ÜÜ< =
out
ÜÜ> A
var
ÜÜB E
vals
ÜÜF J
)
ÜÜJ K
)
ÜÜK L
{
ÜÜM N
var
áá 
(
áá 
nodetype
áá 
,
áá 
val
áá "
,
áá" #
priority
áá$ ,
,
áá, -
assos
áá. 3
)
áá3 4
=
áá5 6
vals
áá7 ;
;
áá; <
return
àà 
new
àà 
Operator
àà #
(
àà# $
)
àà$ %
{
àà& '
Token
àà( -
=
àà. /
token
àà0 5
,
àà5 6
Node
àà7 ;
=
àà< =
new
àà> A
Node
ààB F
(
ààF G
)
ààG H
{
ààI J
Type
ààJ N
=
ààO P
nodetype
ààQ Y
}
ààY Z
,
ààZ [
Priority
àà\ d
=
ààe f
priority
ààg o
,
àào p
Association
ààq |
=
àà} ~
assosàà Ñ
}ààÑ Ö
;ààÖ Ü
}
ââ 
return
ää 
null
ää 
;
ää 
}
ãã 	
}
çç 
}éé Å
NF:\Documents\GITrepos\Compil\Compil\Compil\Exceptions\NotValidCharException.cs
	namespace 	
Compil
 
. 

Exceptions 
{ 
class 	!
NotValidCharException
 
{ 
public !
NotValidCharException $
($ %
)% &
{ 	
} 	
} 
} ‡
:F:\Documents\GITrepos\Compil\Compil\Compil\Objects\Node.cs
	namespace 	
Compil
 
{		 
public 

class 
Node 
{ 
public 
NodeType 
Type 
{ 
get "
;" #
set$ '
;' (
}) *
public 
string 
Value 
{ 
get !
;! "
set# &
;& '
}( )
public 
List 
< 
Node 
> 
Children "
{# $
get% (
;( )
set* -
;- .
}/ 0
=1 2
new3 6
List7 ;
<; <
Node< @
>@ A
(A B
)B C
;C D
public 
void 
AddChild 
( 
Node !
node" &
)& '
{ 	
Children 
. 
Add 
( 
node 
) 
; 
} 	
public%% 
void%% 
AddChildren%% 
(%%  
List%%  $
<%%$ %
Node%%% )
>%%) *
nodes%%+ 0
)%%0 1
{&& 	
foreach'' 
('' 
var'' 
node'' 
in''  
nodes''! &
)''& '
Children(( 
.(( 
Add(( 
((( 
node(( !
)((! "
;((" #
})) 	
public00 
void00 
Print00 
(00 
string00  
indent00! '
,00' (
bool00) -
last00. 2
)002 3
{11 	
Console22 
.22 
Write22 
(22 
indent22  
)22  !
;22! "
if33 
(33 
last33 
)33 
{44 
Console55 
.55 
Write55 
(55 
$str55 #
)55# $
;55$ %
indent66 
+=66 
$str66 
;66 
}77 
else88 
{99 
Console:: 
.:: 
Write:: 
(:: 
$str:: "
)::" #
;::# $
indent;; 
+=;; 
$str;; 
;;; 
}<< 
if== 
(== 
Type== 
==== 
NodeType== 
.==  
CONSTANT==  (
)==( )
Console?? 
.?? 
	WriteLine?? !
(??! "
$str??" +
+??, -
Value??. 3
)??3 4
;??4 5
else@@ 
ConsoleBB 
.BB 
	WriteLineBB !
(BB! "
TypeBB" &
)BB& '
;BB' (
forDD 
(DD 
varDD 
iDD 
=DD 
$numDD 
;DD 
iDD 
<DD 
ChildrenDD  (
.DD( )
CountDD) .
;DD. /
iDD0 1
++DD1 3
)DD3 4
ChildrenEE 
[EE 
iEE 
]EE 
.EE 
PrintEE !
(EE! "
indentEE" (
,EE( )
iEE* +
==EE, .
ChildrenEE/ 7
.EE7 8
CountEE8 =
-EE> ?
$numEE@ A
)EEA B
;EEB C
}FF 	
}JJ 
}KK Åí
FF:\Documents\GITrepos\Compil\Compil\Compil\Analyzer\LexicalAnalyzer.cs
	namespace 	
Compil
 
{		 
class

 	
LexicalAnalyzer


 
{ 
private 
readonly 
string 
code  $
;$ %
public 
int 
index 
; 
public 

Dictionary 
< 
string  
,  !
	TokenType" +
>+ ,
keywords- 5
=6 7
new8 ;

Dictionary< F
<F G
stringG M
,M N
	TokenTypeO X
>X Y
(Y Z
)Z [
{ 	
{ 
$str 
, 
	TokenType 
. 
IF 
}  
,  !
{ 
$str 
, 
	TokenType 
. 
ELSE #
}# $
,$ %
{ 
$str 
, 
	TokenType 
. 
FOR !
}! "
," #
{ 
$str 
, 
	TokenType 
.  
WHILE  %
}% &
,& '
{ 
$str 
, 
	TokenType 
. 
DO 
}  
,  !
{ 
$str 
, 
	TokenType  
.  !
SWITCH! '
}' (
,( )
{ 
$str 
, 
	TokenType 
. 
CASE #
}# $
,$ %
{ 
$str 
, 
	TokenType 
. 
INT !
}! "
," #
{ 
$str 
, 
	TokenType 
. 
VOID #
}# $
} 	
;	 

private 
Token 
_currentNextToken '
;' (
private 
int 
_currentTokenLength '
=( )
$num* +
;+ ,
public%% 
LexicalAnalyzer%% 
(%% 
string%% %
code%%& *
,%%* +
int%%, /
index%%0 5
)%%5 6
{&& 	
this'' 
.'' 
code'' 
='' 
code'' 
;'' 
this(( 
.(( 
index(( 
=(( 
index(( 
;(( 
})) 	
public00 
Token00 
Next00 
(00 
)00 
{11 	
if22 
(22 
_currentNextToken22 !
!=22" $
null22% )
)22) *
{33 
return44 
_currentNextToken44 (
;44( )
}55 
var77 
result77 
=77 

DetectNext77 #
(77# $
)77$ %
;77% &
_currentNextToken88 
=88 
result88  &
;88& '
return99 
result99 
;99 
}:: 	
public?? 
void?? 
Skip?? 
(?? 
)?? 
{@@ 	
indexAA 
+=AA 
_currentTokenLengthAA (
;AA( )
_currentTokenLengthBB 
=BB  !
$numBB" #
;BB# $
_currentNextTokenCC 
=CC 
nullCC  $
;CC$ %
}DD 	
publicJJ 
voidJJ 
AcceptJJ 
(JJ 
	TokenTypeJJ $
typeJJ% )
)JJ) *
{KK 	
tryLL 
{MM 
ifNN 
(NN 
NextNN 
(NN 
)NN 
.NN 
TypeNN 
!=NN  "
typeNN# '
)NN' (
{OO 
throwPP 
newPP !
ArgumentNullExceptionPP 3
(PP3 4
$"PP4 6
Bad token: 'PP6 B
{PPB C
typePPC G
.PPG H
ToStringPPH P
(PPP Q
)PPQ R
}PPR S
' expected.PPS ^
"PP^ _
)PP_ `
;PP` a
}QQ 
SkipSS 
(SS 
)SS 
;SS 
}TT 
catchUU 
(UU !
ArgumentNullExceptionUU (
eUU) *
)UU* +
{VV 
ConsoleWW 
.WW 
	WriteLineWW !
(WW! "
eWW" #
.WW# $
MessageWW$ +
)WW+ ,
;WW, -
}XX 
}YY 	
private`` 
Token`` 

DetectNext``  
(``  !
)``! "
{aa 	
StringBuilderbb 
builderbb !
=bb" #
newbb$ '
StringBuilderbb( 5
(bb5 6
)bb6 7
;bb7 8
ifdd 
(dd 
indexdd 
==dd 
codedd 
.dd 
Lengthdd $
)dd$ %
{ee 
returnff 
newff 
Tokenff  
(ff  !
)ff! "
{ff# $
Typeff$ (
=ff) *
	TokenTypeff+ 4
.ff4 5
END_OF_FILEff5 @
}ff@ A
;ffA B
}gg 
whileii 
(ii 
codeii 
[ii 
indexii 
]ii 
==ii !
$charii" %
||ii& (
codeii) -
[ii- .
indexii. 3
]ii3 4
==ii5 7
$charii8 <
||ii= ?
codeii@ D
[iiD E
indexiiE J
]iiJ K
==iiL N
$chariiO S
)iiS T
{jj 
indexkk 
++kk 
;kk 
}ll 
ifoo 
(oo 
charoo 
.oo 
IsDigitoo 
(oo 
codeoo !
[oo! "
indexoo" '
]oo' (
)oo( )
)oo) *
{pp 
_currentTokenLengthqq #
=qq$ %
$numqq& '
;qq' (
builderss 
.ss 
Appendss 
(ss 
codess #
[ss# $
indexss$ )
]ss) *
.ss* +
ToStringss+ 3
(ss3 4
)ss4 5
)ss5 6
;ss6 7
ifuu 
(uu 
indexuu 
==uu 
codeuu !
.uu! "
Lengthuu" (
-uu) *
$numuu+ ,
)uu, -
{vv 
returnww 
newww 
Tokenww $
(ww$ %
)ww% &
{ww' (
Typeww( ,
=ww- .
	TokenTypeww/ 8
.ww8 9
CONSTANTww9 A
,wwA B
ValuewwC H
=wwI J
intwwK N
.wwN O
ParsewwO T
(wwT U
builderwwU \
.ww\ ]
ToStringww] e
(wwe f
)wwf g
)wwg h
}wwh i
;wwi j
}xx 
varzz 
izz 
=zz 
indexzz 
+zz 
$numzz  !
;zz! "
while{{ 
({{ 
i{{ 
<{{ 
code{{ 
.{{  
Length{{  &
&&{{' )
char{{* .
.{{. /
IsDigit{{/ 6
({{6 7
code{{7 ;
[{{; <
i{{< =
]{{= >
){{> ?
){{? @
{|| 
builder}} 
.}} 
Append}} "
(}}" #
code}}# '
[}}' (
i}}( )
]}}) *
.}}* +
ToString}}+ 3
(}}3 4
)}}4 5
)}}5 6
;}}6 7
i~~ 
++~~ 
;~~ 
_currentTokenLength '
++' )
;) *
}
ÄÄ 
return
ÇÇ 
new
ÇÇ 
Token
ÇÇ  
(
ÇÇ  !
)
ÇÇ! "
{
ÇÇ# $
Type
ÇÇ$ (
=
ÇÇ) *
	TokenType
ÇÇ+ 4
.
ÇÇ4 5
CONSTANT
ÇÇ5 =
,
ÇÇ= >
Value
ÇÇ? D
=
ÇÇE F
int
ÇÇG J
.
ÇÇJ K
Parse
ÇÇK P
(
ÇÇP Q
builder
ÇÇQ X
.
ÇÇX Y
ToString
ÇÇY a
(
ÇÇa b
)
ÇÇb c
)
ÇÇc d
}
ÇÇd e
;
ÇÇe f
}
ÉÉ 
if
ÜÜ 
(
ÜÜ 
char
ÜÜ 
.
ÜÜ 
IsLetter
ÜÜ 
(
ÜÜ 
code
ÜÜ "
[
ÜÜ" #
index
ÜÜ# (
]
ÜÜ( )
)
ÜÜ) *
)
ÜÜ* +
{
áá !
_currentTokenLength
àà #
=
àà$ %
$num
àà& '
;
àà' (
builder
ââ 
.
ââ 
Append
ââ 
(
ââ 
code
ââ #
[
ââ# $
index
ââ$ )
]
ââ) *
.
ââ* +
ToString
ââ+ 3
(
ââ3 4
)
ââ4 5
)
ââ5 6
;
ââ6 7
if
ãã 
(
ãã 
index
ãã 
==
ãã 
code
ãã !
.
ãã! "
Length
ãã" (
-
ãã) *
$num
ãã+ ,
)
ãã, -
{
åå 
if
éé 
(
éé 
keywords
éé  
.
éé  !
ContainsKey
éé! ,
(
éé, -
builder
éé- 4
.
éé4 5
ToString
éé5 =
(
éé= >
)
éé> ?
)
éé? @
)
éé@ A
{
èè 
return
êê 
new
êê "
Token
êê# (
(
êê( )
)
êê) *
{
êê+ ,
Type
êê, 0
=
êê1 2
keywords
êê3 ;
[
êê; <
builder
êê< C
.
êêC D
ToString
êêD L
(
êêL M
)
êêM N
]
êêN O
,
êêO P
Name
êêQ U
=
êêV W
builder
êêX _
.
êê_ `
ToString
êê` h
(
êêh i
)
êêi j
}
êêk l
;
êêl m
}
ëë 
return
ìì 
new
ìì 
Token
ìì $
(
ìì$ %
)
ìì% &
{
ìì' (
Type
ìì( ,
=
ìì- .
	TokenType
ìì/ 8
.
ìì8 9

IDENTIFIER
ìì9 C
,
ììC D
Name
ììE I
=
ììJ K
builder
ììL S
.
ììS T
ToString
ììT \
(
ìì\ ]
)
ìì] ^
}
ìì_ `
;
ìì` a
}
îî 
var
ññ 
i
ññ 
=
ññ 
index
ññ 
+
ññ 
$num
ññ  !
;
ññ! "
while
óó 
(
óó 
i
óó 
<
óó 
code
óó 
.
óó  
Length
óó  &
&&
óó' )
(
óó* +
char
óó+ /
.
óó/ 0
IsLetter
óó0 8
(
óó8 9
code
óó9 =
[
óó= >
i
óó> ?
]
óó? @
)
óó@ A
||
óóB D
char
óóE I
.
óóI J
IsDigit
óóJ Q
(
óóQ R
code
óóR V
[
óóV W
i
óóW X
]
óóX Y
)
óóY Z
)
óóZ [
)
óó[ \
{
òò 
builder
ôô 
.
ôô 
Append
ôô "
(
ôô" #
code
ôô# '
[
ôô' (
i
ôô( )
]
ôô) *
.
ôô* +
ToString
ôô+ 3
(
ôô3 4
)
ôô4 5
)
ôô5 6
;
ôô6 7
i
öö 
++
öö 
;
öö !
_currentTokenLength
õõ '
++
õõ' )
;
õõ) *
}
úú 
if
üü 
(
üü 
keywords
üü 
.
üü 
ContainsKey
üü (
(
üü( )
builder
üü) 0
.
üü0 1
ToString
üü1 9
(
üü9 :
)
üü: ;
)
üü; <
)
üü< =
{
†† 
return
°° 
new
°° 
Token
°° $
(
°°$ %
)
°°% &
{
°°' (
Type
°°( ,
=
°°- .
keywords
°°/ 7
[
°°7 8
builder
°°8 ?
.
°°? @
ToString
°°@ H
(
°°H I
)
°°I J
]
°°J K
,
°°K L
Name
°°M Q
=
°°R S
builder
°°T [
.
°°[ \
ToString
°°\ d
(
°°d e
)
°°e f
}
°°g h
;
°°h i
}
¢¢ 
return
§§ 
new
§§ 
Token
§§  
(
§§  !
)
§§! "
{
§§# $
Type
§§$ (
=
§§) *
	TokenType
§§+ 4
.
§§4 5

IDENTIFIER
§§5 ?
,
§§? @
Name
§§A E
=
§§F G
builder
§§H O
.
§§O P
ToString
§§P X
(
§§X Y
)
§§Y Z
}
§§[ \
;
§§\ ]
}
•• 
if
®® 
(
®® 
code
®® 
[
®® 
index
®® 
]
®® 
==
®® 
$char
®® "
)
®®" #
{
©© !
_currentTokenLength
™™ #
=
™™$ %
$num
™™& '
;
™™' (
builder
´´ 
.
´´ 
Append
´´ 
(
´´ 
code
´´ #
[
´´# $
index
´´$ )
]
´´) *
.
´´* +
ToString
´´+ 3
(
´´3 4
)
´´4 5
)
´´5 6
;
´´6 7
if
≠≠ 
(
≠≠ 
index
≠≠ 
==
≠≠ 
code
≠≠ !
.
≠≠! "
Length
≠≠" (
-
≠≠) *
$num
≠≠+ ,
)
≠≠, -
{
ÆÆ 
return
ØØ 
new
ØØ 
Token
ØØ $
(
ØØ$ %
)
ØØ% &
{
ØØ' (
Type
ØØ( ,
=
ØØ- .
	TokenType
ØØ/ 8
.
ØØ8 9
EQUAL
ØØ9 >
}
ØØ> ?
;
ØØ? @
}
∞∞ 
if
≤≤ 
(
≤≤ 
code
≤≤ 
[
≤≤ 
index
≤≤ 
+
≤≤  
$num
≤≤! "
]
≤≤" #
==
≤≤$ &
$char
≤≤' *
)
≤≤* +
{
≥≥ !
_currentTokenLength
¥¥ '
++
¥¥' )
;
¥¥) *
return
µµ 
new
µµ 
Token
µµ $
(
µµ$ %
)
µµ% &
{
µµ' (
Type
µµ( ,
=
µµ- .
	TokenType
µµ/ 8
.
µµ8 9

COMP_EQUAL
µµ9 C
}
µµC D
;
µµD E
}
∂∂ 
return
∏∏ 
new
∏∏ 
Token
∏∏  
(
∏∏  !
)
∏∏! "
{
∏∏# $
Type
∏∏$ (
=
∏∏) *
	TokenType
∏∏+ 4
.
∏∏4 5
EQUAL
∏∏5 :
}
∏∏: ;
;
∏∏; <
}
ππ !
_currentTokenLength
ªª 
++
ªª !
;
ªª! "
switch
ºº 
(
ºº 
code
ºº 
[
ºº 
index
ºº 
]
ºº 
)
ºº  
{
ΩΩ 
case
ææ 
$char
ææ 
:
ææ 
return
øø 
new
øø 
Token
øø $
(
øø$ %
)
øø% &
{
øø' (
Type
øø( ,
=
øø- .
	TokenType
øø/ 8
.
øø8 9
PLUS
øø9 =
}
øø= >
;
øø> ?
case
¿¿ 
$char
¿¿ 
:
¿¿ 
return
¡¡ 
new
¡¡ 
Token
¡¡ $
(
¡¡$ %
)
¡¡% &
{
¡¡' (
Type
¡¡( ,
=
¡¡- .
	TokenType
¡¡/ 8
.
¡¡8 9
MINUS
¡¡9 >
}
¡¡> ?
;
¡¡? @
case
¬¬ 
$char
¬¬ 
:
¬¬ 
return
√√ 
new
√√ 
Token
√√ $
(
√√$ %
)
√√% &
{
√√' (
Type
√√( ,
=
√√- .
	TokenType
√√/ 8
.
√√8 9
MULTIPLY
√√9 A
}
√√A B
;
√√B C
case
ƒƒ 
$char
ƒƒ 
:
ƒƒ 
return
≈≈ 
new
≈≈ 
Token
≈≈ $
(
≈≈$ %
)
≈≈% &
{
≈≈' (
Type
≈≈( ,
=
≈≈- .
	TokenType
≈≈/ 8
.
≈≈8 9
DIVIDE
≈≈9 ?
}
≈≈? @
;
≈≈@ A
case
∆∆ 
$char
∆∆ 
:
∆∆ 
return
«« 
new
«« 
Token
«« $
(
««$ %
)
««% &
{
««' (
Type
««( ,
=
««- .
	TokenType
««/ 8
.
««8 9
MODULO
««9 ?
}
««? @
;
««@ A
case
»» 
$char
»» 
:
»» 
return
…… 
new
…… 
Token
…… $
(
……$ %
)
……% &
{
……' (
Type
……( ,
=
……- .
	TokenType
……/ 8
.
……8 9
POWER
……9 >
}
……> ?
;
……? @
case
   
$char
   
:
   
return
ÀÀ 
new
ÀÀ 
Token
ÀÀ $
(
ÀÀ$ %
)
ÀÀ% &
{
ÀÀ' (
Type
ÀÀ( ,
=
ÀÀ- .
	TokenType
ÀÀ/ 8
.
ÀÀ8 9
PAR_OPEN
ÀÀ9 A
}
ÀÀA B
;
ÀÀB C
case
ÃÃ 
$char
ÃÃ 
:
ÃÃ 
return
ÕÕ 
new
ÕÕ 
Token
ÕÕ $
(
ÕÕ$ %
)
ÕÕ% &
{
ÕÕ' (
Type
ÕÕ( ,
=
ÕÕ- .
	TokenType
ÕÕ/ 8
.
ÕÕ8 9
	PAR_CLOSE
ÕÕ9 B
}
ÕÕB C
;
ÕÕC D
case
ŒŒ 
$char
ŒŒ 
:
ŒŒ 
return
œœ 
new
œœ 
Token
œœ $
(
œœ$ %
)
œœ% &
{
œœ' (
Type
œœ( ,
=
œœ- .
	TokenType
œœ/ 8
.
œœ8 9
BRACKET_OPEN
œœ9 E
}
œœE F
;
œœF G
case
–– 
$char
–– 
:
–– 
return
—— 
new
—— 
Token
—— $
(
——$ %
)
——% &
{
——' (
Type
——( ,
=
——- .
	TokenType
——/ 8
.
——8 9
BRACKET_CLOSE
——9 F
}
——F G
;
——G H
case
““ 
$char
““ 
:
““ 
return
”” 
new
”” 
Token
”” $
(
””$ %
)
””% &
{
””' (
Type
””( ,
=
””- .
	TokenType
””/ 8
.
””8 9
AND
””9 <
}
””< =
;
””= >
case
‘‘ 
$char
‘‘ 
:
‘‘ 
return
’’ 
new
’’ 
Token
’’ $
(
’’$ %
)
’’% &
{
’’' (
Type
’’( ,
=
’’- .
	TokenType
’’/ 8
.
’’8 9
OR
’’9 ;
}
’’; <
;
’’< =
case
÷÷ 
$char
÷÷ 
:
÷÷ 
return
◊◊ 
new
◊◊ 
Token
◊◊ $
(
◊◊$ %
)
◊◊% &
{
◊◊' (
Type
◊◊( ,
=
◊◊- .
	TokenType
◊◊/ 8
.
◊◊8 9
	SEMICOLON
◊◊9 B
}
◊◊B C
;
◊◊C D
default
ÿÿ 
:
ÿÿ 
break
ŸŸ 
;
ŸŸ 
}
⁄⁄ 
throw
‹‹ 
new
‹‹ %
NotImplementedException
‹‹ -
(
‹‹- .
)
‹‹. /
;
‹‹/ 0
}
›› 	
}
ﬁﬁ 
}ﬂﬂ Ö
5F:\Documents\GITrepos\Compil\Compil\Compil\Program.cs
	namespace

 	
Compil


 
{

 
class 	
Program
 
{ 
static 
void 
Main 
( 
string 
[  
]  !
args" &
)& '
{( )
try 
{ 
Console 
. 
	WriteLine !
(! "
$str" 3
+4 5
args6 :
[: ;
args; ?
.? @
Length@ F
-G H
$numI J
]J K
)K L
;L M
string 
pathFile 
=  !
Path" &
.& '
Combine' .
(. /
args/ 3
[3 4
args4 8
.8 9
Length9 ?
-@ A
$numB C
]C D
)D E
;E F
string 
codeTemp 
=  !
File" &
.& '
ReadAllText' 2
(2 3
pathFile3 ;
); <
;< =
Console 
. 
	WriteLine !
(! "
$str" 3
)3 4
;4 5
Console 
. 
	WriteLine !
(! "
codeTemp" *
)* +
;+ ,
Console 
. 
	WriteLine !
(! "
$str" >
)> ?
;? @
Console 
. 
ReadKey 
(  
)  !
;! "
Console 
. 
	WriteLine !
(! "
)" #
;# $
var 
lexicalAnalyser #
=$ %
new& )
LexicalAnalyzer* 9
(9 :
codeTemp: B
,B C
$numD E
)E F
;F G
var 
syntaxAnalyzer "
=# $
new% (
SyntaxAnalyzer) 7
(7 8
lexicalAnalyser8 G
)G H
;H I
var!! 
node!! 
=!! 
syntaxAnalyzer!! )
.!!) *

Expression!!* 4
(!!4 5
$num!!5 6
)!!6 7
;!!7 8
node"" 
."" 
Print"" 
("" 
$str"" 
,"" 
false"" $
)""$ %
;""% &
Console$$ 
.$$ 
	WriteLine$$ !
($$! "
)$$" #
;$$# $
Console'' 
.'' 
	WriteLine'' !
(''! "
$str''" <
)''< =
;''= >
Console(( 
.(( 
ReadKey(( 
(((  
)((  !
;((! "
})) 
catch** 
(** $
EncoderFallbackException** +
e**, -
)**- .
{++ 
Console,, 
.,, 
	WriteLine,, !
(,,! "
e,," #
.,,# $

StackTrace,,$ .
),,. /
;,,/ 0
}-- 
}.. 	
}// 
}00 
EF:\Documents\GITrepos\Compil\Compil\Compil\Properties\AssemblyInfo.cs
[ 
assembly 	
:	 

AssemblyTitle 
( 
$str !
)! "
]" #
[		 
assembly		 	
:			 

AssemblyDescription		 
(		 
$str		 !
)		! "
]		" #
[

 
assembly

 	
:

	 
!
AssemblyConfiguration

  
(

  !
$str

! #
)

# $
]

$ %
[ 
assembly 	
:	 

AssemblyCompany 
( 
$str 
) 
] 
[ 
assembly 	
:	 

AssemblyProduct 
( 
$str #
)# $
]$ %
[ 
assembly 	
:	 

AssemblyCopyright 
( 
$str 0
)0 1
]1 2
[ 
assembly 	
:	 

AssemblyTrademark 
( 
$str 
)  
]  !
[ 
assembly 	
:	 

AssemblyCulture 
( 
$str 
) 
] 
[ 
assembly 	
:	 


ComVisible 
( 
false 
) 
] 
[ 
assembly 	
:	 

Guid 
( 
$str 6
)6 7
]7 8
[## 
assembly## 	
:##	 

AssemblyVersion## 
(## 
$str## $
)##$ %
]##% &
[$$ 
assembly$$ 	
:$$	 

AssemblyFileVersion$$ 
($$ 
$str$$ (
)$$( )
]$$) *π
;F:\Documents\GITrepos\Compil\Compil\Compil\Objects\Token.cs
	namespace 	
Compil
 
{		 
class 	
Token
 
{ 
public 
string 
Name 
{ 
get  
;  !
set" %
;% &
}' (
public 
int 
Value 
{ 
get 
; 
set  #
;# $
}% &
public 
int 
Line 
{ 
get 
; 
set "
;" #
}$ %
public 
int 
Column 
{ 
get 
;  
set! $
;$ %
}& '
public 
	TokenType 
Type 
{ 
get "
;" #
set$ '
;' (
}( )
} 
} Ú	
<F:\Documents\GITrepos\Compil\Compil\Compil\Utils\NodeType.cs
	namespace 	
Compil
 
. 
Utils 
{ 
public		 

enum		 
NodeType		 
{

 

IDENTIFIER 
, 
CONSTANT 
, 
MINUS 
, 
PLUS 
, 
NOT 
, 
OP_PLUS 
, 
OP_MINUS 
, 
OP_MULTIPLY 
, 
	OP_DIVIDE 
, 
	OP_MODULO 
, 
OP_POWER 
, 

COMP_EQUAL 
, 
COMP_DIFFERENT 
, 
COMP_SUPPERIOR 
, 
COMP_INFERIOR 
, #
COMP_SUPPERIOR_OR_EQUAL 
,  "
COMP_INFERIOR_OR_EQUAL   
,   
AND## 
,## 
OR$$ 

,$$
 
IF%% 

,%%
 
ELSE&& 
,&& 
FOR'' 
,'' 
WHILE(( 
,(( 
DO)) 

,))
 
SWITCH** 
,** 
CASE++ 
,++ 
INT,, 
,,, 
VOID-- 
}.. 
}// Õ
<F:\Documents\GITrepos\Compil\Compil\Compil\Utils\Operator.cs
	namespace 	
Compil
 
. 
Utils 
{ 
class		 	
Operator		
 
{

 
public 
Token 
Token 
{ 
get  
;  !
set" %
;% &
}' (
public 
Node 
Node 
{ 
get 
; 
set  #
;# $
}% &
public 
int 
Priority 
{ 
get !
;! "
set# &
;& '
}( )
public 
int 
Association 
{  
get! $
;$ %
set& )
;) *
}+ ,
} 
} ’
=F:\Documents\GITrepos\Compil\Compil\Compil\Utils\TokenType.cs
	namespace 	
Compil
 
. 
Utils 
{ 
public		 

enum		 
	TokenType		 
{

 

IDENTIFIER 
, 
CONSTANT 
, 
END_OF_FILE 
, 
NOT 
, 
PLUS 
, 
MINUS 
, 
MULTIPLY 
, 
DIVIDE 
, 
MODULO 
, 
POWER 
, 
IF 

,
 
ELSE 
, 
FOR 
, 
WHILE 
, 
DO 

,
 
SWITCH 
, 
CASE   
,   
INT!! 
,!! 
VOID"" 
,"" 

COMP_EQUAL$$ 
,$$ 
COMP_DIFFERENT%% 
,%% 
COMP_SUPPERIOR&& 
,&& 
COMP_INFERIOR'' 
,'' #
COMP_SUPPERIOR_OR_EQUAL(( 
,((  "
COMP_INFERIOR_OR_EQUAL)) 
,)) 
PAR_OPEN++ 
,++ 
	PAR_CLOSE,, 
,,, 
OR.. 

,..
 
AND// 
,// 
EQUAL11 
,11 
BRACKET_OPEN44 
,44 
BRACKET_CLOSE55 
,55 
	SEMICOLON77 
,77 
COMA88 
,88 
COMMENT_LINE99 
,99 
COMMENT_BLOCK_START:: 
,:: 
COMMENT_BLOCK_END;; 
}<< 
}== 