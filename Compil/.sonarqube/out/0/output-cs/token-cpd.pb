’l
EF:\Documents\GITrepos\Compil\Compil\Compil\Analyzer\SyntaxAnalyzer.cs
	namespace 	
Compil
 
{ 
class

 	
SyntaxAnalyzer


 
{ 
private 
readonly 
LexicalAnalyzer (
_lexicalAnalyzer) 9
;9 :
private 
readonly 

Dictionary #
<# $
	TokenType$ -
,- .
(/ 0
NodeType0 8
,8 9
string: @
,@ A
intB E
,E F
intG J
)J K
>K L!
_exprTokenToNodeMatchM b
=c d
newe h

Dictionaryi s
<s t
	TokenTypet }
,} ~
(	 Ä
NodeType
Ä à
,
à â
string
ä ê
,
ê ë
int
í ï
,
ï ñ
int
ó ö
)
ö õ
>
õ ú
(
ú ù
)
ù û
{ 	
{ 
	TokenType 
. 
OR 
, 
( 
NodeType $
.$ %
OR% '
,' (
$str) ,
,, -
$num. /
,/ 0
$num1 2
)2 3
}3 4
,4 5
{ 
	TokenType 
. 
AND 
, 
( 
NodeType %
.% &
AND& )
,) *
$str+ .
,. /
$num0 1
,1 2
$num3 4
)4 5
}5 6
,6 7
{ 
	TokenType 
. 
NOT 
, 
( 
NodeType %
.% &
NOT& )
,) *
$str+ .
,. /
$num0 1
,1 2
$num3 4
)4 5
}5 6
,6 7
{ 
	TokenType 
. 

COMP_EQUAL !
,! "
(# $
NodeType$ ,
., -

COMP_EQUAL- 7
,7 8
$str9 =
,= >
$num? @
,@ A
$numB C
)C D
}D E
,E F
{ 
	TokenType 
. 
PLUS 
, 
( 
NodeType &
.& '
OP_PLUS' .
,. /
$str0 3
,3 4
$num5 6
,6 7
$num8 9
)9 :
}: ;
,; <
{ 
	TokenType 
. 
MINUS 
, 
( 
NodeType '
.' (
OP_MINUS( 0
,0 1
$str2 5
,5 6
$num7 8
,8 9
$num: ;
); <
}< =
,= >
{ 
	TokenType 
. 
POWER 
, 
( 
NodeType '
.' (
OP_POWER( 0
,0 1
$str2 5
,5 6
$num7 8
,8 9
$num: ;
); <
}< =
,= >
{ 
	TokenType 
. 
DIVIDE 
, 
(  
NodeType  (
.( )
	OP_DIVIDE) 2
,2 3
$str4 7
,7 8
$num9 :
,: ;
$num< =
)= >
}> ?
,? @
{ 
	TokenType 
. 
MODULO 
, 
(  
NodeType  (
.( )
	OP_MODULO) 2
,2 3
$str4 7
,7 8
$num9 :
,: ;
$num< =
)= >
}> ?
,? @
{ 
	TokenType 
. 
MULTIPLY 
,  
(! "
NodeType" *
.* +
OP_MULTIPLY+ 6
,6 7
$str8 ;
,; <
$num= >
,> ?
$num@ A
)A B
}B C
,C D
{ 
	TokenType 
. 
COMP_INFERIOR $
,$ %
(& '
NodeType' /
./ 0
COMP_INFERIOR0 =
,= >
$str? B
,B C
$numD E
,E F
$numG H
)H I
}I J
,J K
{ 
	TokenType 
. 
COMP_DIFFERENT %
,% &
(' (
NodeType( 0
.0 1
COMP_DIFFERENT1 ?
,? @
$strA E
,E F
$numG H
,H I
$numJ K
)K L
}L M
,M N
{ 
	TokenType 
. 
COMP_SUPPERIOR %
,% &
(' (
NodeType( 0
.0 1
COMP_SUPPERIOR1 ?
,? @
$strA D
,D E
$numF G
,G H
$numI J
)J K
}K L
,L M
{ 
	TokenType 
. "
COMP_INFERIOR_OR_EQUAL -
,- .
(/ 0
NodeType0 8
.8 9"
COMP_INFERIOR_OR_EQUAL9 O
,O P
$strQ U
,U V
$numW X
,X Y
$numZ [
)[ \
}\ ]
,] ^
{ 
	TokenType 
. #
COMP_SUPPERIOR_OR_EQUAL .
,. /
(0 1
NodeType1 9
.9 :#
COMP_SUPPERIOR_OR_EQUAL: Q
,Q R
$strS W
,W X
$numY Z
,Z [
$num\ ]
)] ^
}^ _
,_ `
} 	
;	 

public%% 
SyntaxAnalyzer%% 
(%% 
LexicalAnalyzer%% -
lexicalAnalyser%%. =
)%%= >
{&& 	
this'' 
.'' 
_lexicalAnalyzer'' !
=''" #
lexicalAnalyser''$ 3
;''3 4
}(( 	
public-- 
Node-- 
Primary-- 
(-- 
)-- 
{.. 	
try// 
{00 
Node11 
node11 
;11 
if44 
(44 
_lexicalAnalyzer44 $
.44$ %
Next44% )
(44) *
)44* +
.44+ ,
Type44, 0
==441 3
	TokenType444 =
.44= >
CONSTANT44> F
)44F G
{55 
node66 
=66 
new66 
Node66 #
(66# $
)66$ %
{66& '
Type66( ,
=66- .
NodeType66/ 7
.667 8
CONSTANT668 @
,66@ A
Value66B G
=66H I
_lexicalAnalyzer66J Z
.66Z [
Next66[ _
(66_ `
)66` a
.66a b
Value66b g
.66g h
ToString66h p
(66p q
)66q r
}66s t
;66t u
_lexicalAnalyzer77 $
.77$ %
Skip77% )
(77) *
)77* +
;77+ ,
return88 
node88 
;88  
}99 
if<< 
(<< 
_lexicalAnalyzer<< $
.<<$ %
Next<<% )
(<<) *
)<<* +
.<<+ ,
Type<<, 0
==<<1 3
	TokenType<<4 =
.<<= >
PAR_OPEN<<> F
)<<F G
{== 
_lexicalAnalyzer>> $
.>>$ %
Skip>>% )
(>>) *
)>>* +
;>>+ ,
node?? 
=?? 

Expression?? %
(??% &
$num??& '
)??' (
;??( )
_lexicalAnalyzer@@ $
.@@$ %
Accept@@% +
(@@+ ,
	TokenType@@, 5
.@@5 6
	PAR_CLOSE@@6 ?
)@@? @
;@@@ A
returnAA 
nodeAA 
;AA  
}BB 
ifEE 
(EE 
_lexicalAnalyzerEE $
.EE$ %
NextEE% )
(EE) *
)EE* +
.EE+ ,
TypeEE, 0
==EE1 3
	TokenTypeEE4 =
.EE= >
MINUSEE> C
||EED F
_lexicalAnalyzerFF $
.FF$ %
NextFF% )
(FF) *
)FF* +
.FF+ ,
TypeFF, 0
==FF1 3
	TokenTypeFF4 =
.FF= >
PLUSFF> B
||FFC E
_lexicalAnalyzerGG $
.GG$ %
NextGG% )
(GG) *
)GG* +
.GG+ ,
TypeGG, 0
==GG1 3
	TokenTypeGG4 =
.GG= >
NOTGG> A
)GGA B
{HH 
varII 
(II 
nodeTypeII !
,II! "
valII# &
,II& '
_II( )
,II) *
_II+ ,
)II, -
=II. /!
_exprTokenToNodeMatchII0 E
[IIE F
_lexicalAnalyzerIIF V
.IIV W
NextIIW [
(II[ \
)II\ ]
.II] ^
TypeII^ b
]IIb c
;IIc d
nodeJJ 
=JJ 
newJJ 
NodeJJ #
(JJ# $
)JJ$ %
{JJ& '
TypeJJ( ,
=JJ- .
nodeTypeJJ/ 7
,JJ7 8
ValueJJ9 >
=JJ? @
valJJA D
}JJE F
;JJF G
_lexicalAnalyzerKK $
.KK$ %
SkipKK% )
(KK) *
)KK* +
;KK+ ,
nodeLL 
.LL 
AddChildLL !
(LL! "

ExpressionLL" ,
(LL, -
$numLL- .
)LL. /
)LL/ 0
;LL0 1
returnMM 
nodeMM 
;MM  
}NN 
throwQQ 
newQQ !
ArgumentNullExceptionQQ /
(QQ/ 0
$strQQ0 C
)QQC D
;QQD E
}RR 
catchSS 
(SS #
NotImplementedExceptionSS *
eSS+ ,
)SS, -
{TT 
ConsoleUU 
.UU 
	WriteLineUU !
(UU! "
$strUU" <
)UU< =
;UU= >
ConsoleVV 
.VV 
	WriteLineVV !
(VV! "
eVV" #
.VV# $

StackTraceVV$ .
)VV. /
;VV/ 0
returnWW 
nullWW 
;WW 
}XX 
catchYY 
(YY !
ArgumentNullExceptionYY (
eYY) *
)YY* +
{ZZ 
Console[[ 
.[[ 
	WriteLine[[ !
([[! "
e[[" #
.[[# $

StackTrace[[$ .
)[[. /
;[[/ 0
return\\ 
null\\ 
;\\ 
}]] 
}^^ 	
publicee 
Nodeee 

Expressionee 
(ee 
intee "
pMinee# '
)ee' (
{ff 	
vargg 
leftNodegg 
=gg 
Primarygg "
(gg" #
)gg# $
;gg$ %
whileii 
(ii 
trueii 
)ii 
{jj 
ifkk 
(kk 
_lexicalAnalyzerkk $
.kk$ %
Nextkk% )
(kk) *
)kk* +
==kk, .
nullkk/ 3
)kk3 4
returnll 
leftNodell #
;ll# $
varnn 
opnn 
=nn 
SearchOpnn !
(nn! "
_lexicalAnalyzernn" 2
.nn2 3
Nextnn3 7
(nn7 8
)nn8 9
)nn9 :
;nn: ;
ifpp 
(pp 
oppp 
==pp 
nullpp 
||pp !
oppp" $
.pp$ %
Prioritypp% -
<pp. /
pMinpp0 4
)pp4 5
returnqq 
leftNodeqq #
;qq# $
_lexicalAnalyzerss  
.ss  !
Skipss! %
(ss% &
)ss& '
;ss' (
vartt 
	rightNodett 
=tt 

Expressiontt  *
(tt* +
optt+ -
.tt- .
Prioritytt. 6
+tt7 8
optt9 ;
.tt; <
Associationtt< G
)ttG H
;ttH I
varuu 
treeuu 
=uu 
newuu 
Nodeuu #
(uu# $
)uu$ %
{uu& '
Typeuu( ,
=uu- .
opuu/ 1
.uu1 2
Nodeuu2 6
.uu6 7
Typeuu7 ;
}uu< =
;uu= >
treevv 
.vv 
AddChildvv 
(vv 
leftNodevv &
)vv& '
;vv' (
treeww 
.ww 
AddChildww 
(ww 
	rightNodeww '
)ww' (
;ww( )
leftNodexx 
=xx 
treexx 
;xx  
}yy 
}zz 	
public
ÅÅ 
Operator
ÅÅ 
SearchOp
ÅÅ  
(
ÅÅ  !
Token
ÅÅ! &
token
ÅÅ' ,
)
ÅÅ, -
{
ÇÇ 	
if
ÉÉ 
(
ÉÉ #
_exprTokenToNodeMatch
ÉÉ %
.
ÉÉ% &
TryGetValue
ÉÉ& 1
(
ÉÉ1 2
token
ÉÉ2 7
.
ÉÉ7 8
Type
ÉÉ8 <
,
ÉÉ< =
out
ÉÉ> A
var
ÉÉB E
vals
ÉÉF J
)
ÉÉJ K
)
ÉÉK L
{
ÑÑ 
var
ÖÖ 
(
ÖÖ 
nodetype
ÖÖ 
,
ÖÖ 
val
ÖÖ "
,
ÖÖ" #
priority
ÖÖ$ ,
,
ÖÖ, -
assos
ÖÖ. 3
)
ÖÖ3 4
=
ÖÖ5 6
vals
ÖÖ7 ;
;
ÖÖ; <
return
ÜÜ 
new
ÜÜ 
Operator
ÜÜ #
(
ÜÜ# $
)
ÜÜ$ %
{
ÜÜ& '
Token
ÜÜ( -
=
ÜÜ. /
token
ÜÜ0 5
,
ÜÜ5 6
Node
ÜÜ7 ;
=
ÜÜ< =
new
ÜÜ> A
Node
ÜÜB F
(
ÜÜF G
)
ÜÜG H
{
ÜÜI J
Type
ÜÜK O
=
ÜÜP Q
nodetype
ÜÜR Z
}
ÜÜ[ \
,
ÜÜ\ ]
Priority
ÜÜ^ f
=
ÜÜg h
priority
ÜÜi q
,
ÜÜq r
Association
ÜÜs ~
=ÜÜ Ä
assosÜÜÅ Ü
}ÜÜá à
;ÜÜà â
}
áá 
return
àà 
null
àà 
;
àà 
}
ââ 	
}
ãã 
}åå Å
NF:\Documents\GITrepos\Compil\Compil\Compil\Exceptions\NotValidCharException.cs
	namespace 	
Compil
 
. 

Exceptions 
{ 
class 	!
NotValidCharException
 
{ 
public !
NotValidCharException $
($ %
)% &
{		 	
} 	
} 
} ‡
:F:\Documents\GITrepos\Compil\Compil\Compil\Objects\Node.cs
	namespace 	
Compil
 
{ 
public

 

class

 
Node

 
{ 
public 
NodeType 
Type 
{ 
get "
;" #
set$ '
;' (
}) *
public 
string 
Value 
{ 
get !
;! "
set# &
;& '
}( )
public 
List 
< 
Node 
> 
Children "
{# $
get% (
;( )
set* -
;- .
}/ 0
=1 2
new3 6
List7 ;
<; <
Node< @
>@ A
(A B
)B C
;C D
public 
void 
AddChild 
( 
Node !
node" &
)& '
{ 	
Children 
. 
Add 
( 
node 
) 
; 
} 	
public"" 
void"" 
AddChildren"" 
(""  
List""  $
<""$ %
Node""% )
>"") *
nodes""+ 0
)""0 1
{## 	
foreach$$ 
($$ 
var$$ 
node$$ 
in$$  
nodes$$! &
)$$& '
Children%% 
.%% 
Add%% 
(%% 
node%% !
)%%! "
;%%" #
}&& 	
public-- 
void-- 
Print-- 
(-- 
string--  
indent--! '
,--' (
bool--) -
last--. 2
)--2 3
{.. 	
Console// 
.// 
Write// 
(// 
indent//  
)//  !
;//! "
if00 
(00 
last00 
)00 
{11 
Console22 
.22 
Write22 
(22 
$str22 #
)22# $
;22$ %
indent33 
+=33 
$str33 
;33 
}44 
else55 
{66 
Console77 
.77 
Write77 
(77 
$str77 "
)77" #
;77# $
indent88 
+=88 
$str88 
;88 
}99 
if:: 
(:: 
Type:: 
==:: 
NodeType::  
.::  !
CONSTANT::! )
)::) *
Console<< 
.<< 
	WriteLine<< !
(<<! "
$str<<" +
+<<, -
Value<<. 3
)<<3 4
;<<4 5
else== 
Console?? 
.?? 
	WriteLine?? !
(??! "
Type??" &
)??& '
;??' (
forAA 
(AA 
varAA 
iAA 
=AA 
$numAA 
;AA 
iAA 
<AA 
ChildrenAA  (
.AA( )
CountAA) .
;AA. /
iAA0 1
++AA1 3
)AA3 4
ChildrenBB 
[BB 
iBB 
]BB 
.BB 
PrintBB !
(BB! "
indentBB" (
,BB( )
iBB* +
==BB, .
ChildrenBB/ 7
.BB7 8
CountBB8 =
-BB> ?
$numBB@ A
)BBA B
;BBB C
}CC 	
}GG 
}HH ˇë
FF:\Documents\GITrepos\Compil\Compil\Compil\Analyzer\LexicalAnalyzer.cs
	namespace 	
Compil
 
{ 
class 	
LexicalAnalyzer
 
{		 
private

 
readonly

 
string

 
code

  $
;

$ %
public 
int 
index 
; 
public 

Dictionary 
< 
string  
,  !
	TokenType" +
>+ ,
keywords- 5
=6 7
new8 ;

Dictionary< F
<F G
stringG M
,M N
	TokenTypeO X
>X Y
(Y Z
)Z [
{ 	
{ 
$str 
, 
	TokenType 
. 
IF 
}  
,  !
{ 
$str 
, 
	TokenType 
. 
ELSE #
}# $
,$ %
{ 
$str 
, 
	TokenType 
. 
FOR !
}! "
," #
{ 
$str 
, 
	TokenType 
.  
WHILE  %
}% &
,& '
{ 
$str 
, 
	TokenType 
. 
DO 
}  
,  !
{ 
$str 
, 
	TokenType  
.  !
SWITCH! '
}' (
,( )
{ 
$str 
, 
	TokenType 
. 
CASE #
}# $
,$ %
{ 
$str 
, 
	TokenType 
. 
INT !
}! "
," #
{ 
$str 
, 
	TokenType 
. 
VOID #
}# $
} 	
;	 

private 
Token 
_currentNextToken '
;' (
private 
int 
_currentTokenLength '
=( )
$num* +
;+ ,
public## 
LexicalAnalyzer## 
(## 
string## %
code##& *
,##* +
int##, /
index##0 5
)##5 6
{$$ 	
this%% 
.%% 
code%% 
=%% 
code%% 
;%% 
this&& 
.&& 
index&& 
=&& 
index&& 
;&& 
}'' 	
public.. 
Token.. 
Next.. 
(.. 
).. 
{// 	
if00 
(00 
_currentNextToken00 !
!=00" $
null00% )
)00) *
{11 
return22 
_currentNextToken22 (
;22( )
}33 
var55 
result55 
=55 

DetectNext55 #
(55# $
)55$ %
;55% &
_currentNextToken66 
=66 
result66  &
;66& '
return77 
result77 
;77 
}88 	
public== 
void== 
Skip== 
(== 
)== 
{>> 	
index?? 
+=?? 
_currentTokenLength?? (
;??( )
_currentTokenLength@@ 
=@@  !
$num@@" #
;@@# $
_currentNextTokenAA 
=AA 
nullAA  $
;AA$ %
}BB 	
publicHH 
voidHH 
AcceptHH 
(HH 
	TokenTypeHH $
typeHH% )
)HH) *
{II 	
tryJJ 
{KK 
ifLL 
(LL 
NextLL 
(LL 
)LL 
.LL 
TypeLL 
!=LL  "
typeLL# '
)LL' (
{MM 
throwNN 
newNN !
ArgumentNullExceptionNN 3
(NN3 4
$"NN4 6
Bad token: 'NN6 B
{NNB C
typeNNC G
.NNG H
ToStringNNH P
(NNP Q
)NNQ R
}NNR S
' expected.NNS ^
"NN^ _
)NN_ `
;NN` a
}OO 
SkipQQ 
(QQ 
)QQ 
;QQ 
}RR 
catchSS 
(SS !
ArgumentNullExceptionSS (
eSS) *
)SS* +
{TT 
ConsoleUU 
.UU 
	WriteLineUU !
(UU! "
eUU" #
.UU# $
MessageUU$ +
)UU+ ,
;UU, -
}VV 
}WW 	
private^^ 
Token^^ 

DetectNext^^  
(^^  !
)^^! "
{__ 	
StringBuilder`` 
builder`` !
=``" #
new``$ '
StringBuilder``( 5
(``5 6
)``6 7
;``7 8
ifbb 
(bb 
indexbb 
==bb 
codebb 
.bb 
Lengthbb $
)bb$ %
{cc 
returndd 
newdd 
Tokendd  
(dd  !
)dd! "
{dd# $
Typedd% )
=dd* +
	TokenTypedd, 5
.dd5 6
END_OF_FILEdd6 A
}ddB C
;ddC D
}ee 
whilegg 
(gg 
codegg 
[gg 
indexgg 
]gg 
==gg !
$chargg" %
||gg& (
codegg) -
[gg- .
indexgg. 3
]gg3 4
==gg5 7
$chargg8 <
||gg= ?
codegg@ D
[ggD E
indexggE J
]ggJ K
==ggL N
$charggO S
)ggS T
{hh 
indexii 
++ii 
;ii 
}jj 
ifmm 
(mm 
charmm 
.mm 
IsDigitmm 
(mm 
codemm !
[mm! "
indexmm" '
]mm' (
)mm( )
)mm) *
{nn 
_currentTokenLengthoo #
=oo$ %
$numoo& '
;oo' (
builderqq 
.qq 
Appendqq 
(qq 
codeqq #
[qq# $
indexqq$ )
]qq) *
.qq* +
ToStringqq+ 3
(qq3 4
)qq4 5
)qq5 6
;qq6 7
ifss 
(ss 
indexss 
==ss 
codess !
.ss! "
Lengthss" (
-ss) *
$numss+ ,
)ss, -
{tt 
returnuu 
newuu 
Tokenuu $
(uu$ %
)uu% &
{uu' (
Typeuu) -
=uu. /
	TokenTypeuu0 9
.uu9 :
CONSTANTuu: B
,uuB C
ValueuuD I
=uuJ K
intuuL O
.uuO P
ParseuuP U
(uuU V
builderuuV ]
.uu] ^
ToStringuu^ f
(uuf g
)uug h
)uuh i
}uuj k
;uuk l
}vv 
varxx 
ixx 
=xx 
indexxx 
+xx 
$numxx  !
;xx! "
whileyy 
(yy 
iyy 
<yy 
codeyy 
.yy  
Lengthyy  &
&&yy' )
charyy* .
.yy. /
IsDigityy/ 6
(yy6 7
codeyy7 ;
[yy; <
iyy< =
]yy= >
)yy> ?
)yy? @
{zz 
builder{{ 
.{{ 
Append{{ "
({{" #
code{{# '
[{{' (
i{{( )
]{{) *
.{{* +
ToString{{+ 3
({{3 4
){{4 5
){{5 6
;{{6 7
i|| 
++|| 
;|| 
_currentTokenLength}} '
++}}' )
;}}) *
}~~ 
return
ÄÄ 
new
ÄÄ 
Token
ÄÄ  
(
ÄÄ  !
)
ÄÄ! "
{
ÄÄ# $
Type
ÄÄ% )
=
ÄÄ* +
	TokenType
ÄÄ, 5
.
ÄÄ5 6
CONSTANT
ÄÄ6 >
,
ÄÄ> ?
Value
ÄÄ@ E
=
ÄÄF G
int
ÄÄH K
.
ÄÄK L
Parse
ÄÄL Q
(
ÄÄQ R
builder
ÄÄR Y
.
ÄÄY Z
ToString
ÄÄZ b
(
ÄÄb c
)
ÄÄc d
)
ÄÄd e
}
ÄÄf g
;
ÄÄg h
}
ÅÅ 
if
ÑÑ 
(
ÑÑ 
char
ÑÑ 
.
ÑÑ 
IsLetter
ÑÑ 
(
ÑÑ 
code
ÑÑ "
[
ÑÑ" #
index
ÑÑ# (
]
ÑÑ( )
)
ÑÑ) *
)
ÑÑ* +
{
ÖÖ !
_currentTokenLength
ÜÜ #
=
ÜÜ$ %
$num
ÜÜ& '
;
ÜÜ' (
builder
áá 
.
áá 
Append
áá 
(
áá 
code
áá #
[
áá# $
index
áá$ )
]
áá) *
.
áá* +
ToString
áá+ 3
(
áá3 4
)
áá4 5
)
áá5 6
;
áá6 7
if
ââ 
(
ââ 
index
ââ 
==
ââ 
code
ââ !
.
ââ! "
Length
ââ" (
-
ââ) *
$num
ââ+ ,
)
ââ, -
{
ää 
if
åå 
(
åå 
keywords
åå  
.
åå  !
ContainsKey
åå! ,
(
åå, -
builder
åå- 4
.
åå4 5
ToString
åå5 =
(
åå= >
)
åå> ?
)
åå? @
)
åå@ A
{
çç 
return
éé 
new
éé "
Token
éé# (
(
éé( )
)
éé) *
{
éé+ ,
Type
éé- 1
=
éé2 3
keywords
éé4 <
[
éé< =
builder
éé= D
.
ééD E
ToString
ééE M
(
ééM N
)
ééN O
]
ééO P
,
ééP Q
Name
ééR V
=
ééW X
builder
ééY `
.
éé` a
ToString
ééa i
(
ééi j
)
ééj k
}
éél m
;
éém n
}
èè 
return
ëë 
new
ëë 
Token
ëë $
(
ëë$ %
)
ëë% &
{
ëë' (
Type
ëë) -
=
ëë. /
	TokenType
ëë0 9
.
ëë9 :

IDENTIFIER
ëë: D
,
ëëD E
Name
ëëF J
=
ëëK L
builder
ëëM T
.
ëëT U
ToString
ëëU ]
(
ëë] ^
)
ëë^ _
}
ëë` a
;
ëëa b
}
íí 
var
îî 
i
îî 
=
îî 
index
îî 
+
îî 
$num
îî  !
;
îî! "
while
ïï 
(
ïï 
i
ïï 
<
ïï 
code
ïï 
.
ïï  
Length
ïï  &
&&
ïï' )
(
ïï* +
char
ïï+ /
.
ïï/ 0
IsLetter
ïï0 8
(
ïï8 9
code
ïï9 =
[
ïï= >
i
ïï> ?
]
ïï? @
)
ïï@ A
||
ïïB D
char
ïïE I
.
ïïI J
IsDigit
ïïJ Q
(
ïïQ R
code
ïïR V
[
ïïV W
i
ïïW X
]
ïïX Y
)
ïïY Z
)
ïïZ [
)
ïï[ \
{
ññ 
builder
óó 
.
óó 
Append
óó "
(
óó" #
code
óó# '
[
óó' (
i
óó( )
]
óó) *
.
óó* +
ToString
óó+ 3
(
óó3 4
)
óó4 5
)
óó5 6
;
óó6 7
i
òò 
++
òò 
;
òò !
_currentTokenLength
ôô '
++
ôô' )
;
ôô) *
}
öö 
if
ùù 
(
ùù 
keywords
ùù 
.
ùù 
ContainsKey
ùù (
(
ùù( )
builder
ùù) 0
.
ùù0 1
ToString
ùù1 9
(
ùù9 :
)
ùù: ;
)
ùù; <
)
ùù< =
{
ûû 
return
üü 
new
üü 
Token
üü $
(
üü$ %
)
üü% &
{
üü' (
Type
üü) -
=
üü. /
keywords
üü0 8
[
üü8 9
builder
üü9 @
.
üü@ A
ToString
üüA I
(
üüI J
)
üüJ K
]
üüK L
,
üüL M
Name
üüN R
=
üüS T
builder
üüU \
.
üü\ ]
ToString
üü] e
(
üüe f
)
üüf g
}
üüh i
;
üüi j
}
†† 
return
¢¢ 
new
¢¢ 
Token
¢¢  
(
¢¢  !
)
¢¢! "
{
¢¢# $
Type
¢¢% )
=
¢¢* +
	TokenType
¢¢, 5
.
¢¢5 6

IDENTIFIER
¢¢6 @
,
¢¢@ A
Name
¢¢B F
=
¢¢G H
builder
¢¢I P
.
¢¢P Q
ToString
¢¢Q Y
(
¢¢Y Z
)
¢¢Z [
}
¢¢\ ]
;
¢¢] ^
}
££ 
if
¶¶ 
(
¶¶ 
code
¶¶ 
[
¶¶ 
index
¶¶ 
]
¶¶ 
==
¶¶ 
$char
¶¶ "
)
¶¶" #
{
ßß !
_currentTokenLength
®® #
=
®®$ %
$num
®®& '
;
®®' (
builder
©© 
.
©© 
Append
©© 
(
©© 
code
©© #
[
©©# $
index
©©$ )
]
©©) *
.
©©* +
ToString
©©+ 3
(
©©3 4
)
©©4 5
)
©©5 6
;
©©6 7
if
´´ 
(
´´ 
index
´´ 
==
´´ 
code
´´ !
.
´´! "
Length
´´" (
-
´´) *
$num
´´+ ,
)
´´, -
{
¨¨ 
return
≠≠ 
new
≠≠ 
Token
≠≠ $
(
≠≠$ %
)
≠≠% &
{
≠≠' (
Type
≠≠) -
=
≠≠. /
	TokenType
≠≠0 9
.
≠≠9 :
EQUAL
≠≠: ?
}
≠≠@ A
;
≠≠A B
}
ÆÆ 
if
∞∞ 
(
∞∞ 
code
∞∞ 
[
∞∞ 
index
∞∞ 
+
∞∞  
$num
∞∞! "
]
∞∞" #
==
∞∞$ &
$char
∞∞' *
)
∞∞* +
{
±± !
_currentTokenLength
≤≤ '
++
≤≤' )
;
≤≤) *
return
≥≥ 
new
≥≥ 
Token
≥≥ $
(
≥≥$ %
)
≥≥% &
{
≥≥' (
Type
≥≥) -
=
≥≥. /
	TokenType
≥≥0 9
.
≥≥9 :

COMP_EQUAL
≥≥: D
}
≥≥E F
;
≥≥F G
}
¥¥ 
return
∂∂ 
new
∂∂ 
Token
∂∂  
(
∂∂  !
)
∂∂! "
{
∂∂# $
Type
∂∂% )
=
∂∂* +
	TokenType
∂∂, 5
.
∂∂5 6
EQUAL
∂∂6 ;
}
∂∂< =
;
∂∂= >
}
∑∑ !
_currentTokenLength
ππ 
++
ππ !
;
ππ! "
switch
∫∫ 
(
∫∫ 
code
∫∫ 
[
∫∫ 
index
∫∫ 
]
∫∫ 
)
∫∫  
{
ªª 
case
ºº 
$char
ºº 
:
ºº 
return
ΩΩ 
new
ΩΩ 
Token
ΩΩ $
(
ΩΩ$ %
)
ΩΩ% &
{
ΩΩ' (
Type
ΩΩ) -
=
ΩΩ. /
	TokenType
ΩΩ0 9
.
ΩΩ9 :
PLUS
ΩΩ: >
}
ΩΩ? @
;
ΩΩ@ A
case
ææ 
$char
ææ 
:
ææ 
return
øø 
new
øø 
Token
øø $
(
øø$ %
)
øø% &
{
øø' (
Type
øø) -
=
øø. /
	TokenType
øø0 9
.
øø9 :
MINUS
øø: ?
}
øø@ A
;
øøA B
case
¿¿ 
$char
¿¿ 
:
¿¿ 
return
¡¡ 
new
¡¡ 
Token
¡¡ $
(
¡¡$ %
)
¡¡% &
{
¡¡' (
Type
¡¡) -
=
¡¡. /
	TokenType
¡¡0 9
.
¡¡9 :
MULTIPLY
¡¡: B
}
¡¡C D
;
¡¡D E
case
¬¬ 
$char
¬¬ 
:
¬¬ 
return
√√ 
new
√√ 
Token
√√ $
(
√√$ %
)
√√% &
{
√√' (
Type
√√) -
=
√√. /
	TokenType
√√0 9
.
√√9 :
DIVIDE
√√: @
}
√√A B
;
√√B C
case
ƒƒ 
$char
ƒƒ 
:
ƒƒ 
return
≈≈ 
new
≈≈ 
Token
≈≈ $
(
≈≈$ %
)
≈≈% &
{
≈≈' (
Type
≈≈) -
=
≈≈. /
	TokenType
≈≈0 9
.
≈≈9 :
MODULO
≈≈: @
}
≈≈A B
;
≈≈B C
case
∆∆ 
$char
∆∆ 
:
∆∆ 
return
«« 
new
«« 
Token
«« $
(
««$ %
)
««% &
{
««' (
Type
««) -
=
««. /
	TokenType
««0 9
.
««9 :
POWER
««: ?
}
««@ A
;
««A B
case
»» 
$char
»» 
:
»» 
return
…… 
new
…… 
Token
…… $
(
……$ %
)
……% &
{
……' (
Type
……) -
=
……. /
	TokenType
……0 9
.
……9 :
PAR_OPEN
……: B
}
……C D
;
……D E
case
   
$char
   
:
   
return
ÀÀ 
new
ÀÀ 
Token
ÀÀ $
(
ÀÀ$ %
)
ÀÀ% &
{
ÀÀ' (
Type
ÀÀ) -
=
ÀÀ. /
	TokenType
ÀÀ0 9
.
ÀÀ9 :
	PAR_CLOSE
ÀÀ: C
}
ÀÀD E
;
ÀÀE F
case
ÃÃ 
$char
ÃÃ 
:
ÃÃ 
return
ÕÕ 
new
ÕÕ 
Token
ÕÕ $
(
ÕÕ$ %
)
ÕÕ% &
{
ÕÕ' (
Type
ÕÕ) -
=
ÕÕ. /
	TokenType
ÕÕ0 9
.
ÕÕ9 :
BRACKET_OPEN
ÕÕ: F
}
ÕÕG H
;
ÕÕH I
case
ŒŒ 
$char
ŒŒ 
:
ŒŒ 
return
œœ 
new
œœ 
Token
œœ $
(
œœ$ %
)
œœ% &
{
œœ' (
Type
œœ) -
=
œœ. /
	TokenType
œœ0 9
.
œœ9 :
BRACKET_CLOSE
œœ: G
}
œœH I
;
œœI J
case
–– 
$char
–– 
:
–– 
return
—— 
new
—— 
Token
—— $
(
——$ %
)
——% &
{
——' (
Type
——) -
=
——. /
	TokenType
——0 9
.
——9 :
AND
——: =
}
——> ?
;
——? @
case
““ 
$char
““ 
:
““ 
return
”” 
new
”” 
Token
”” $
(
””$ %
)
””% &
{
””' (
Type
””) -
=
””. /
	TokenType
””0 9
.
””9 :
OR
””: <
}
””= >
;
””> ?
case
‘‘ 
$char
‘‘ 
:
‘‘ 
return
’’ 
new
’’ 
Token
’’ $
(
’’$ %
)
’’% &
{
’’' (
Type
’’) -
=
’’. /
	TokenType
’’0 9
.
’’9 :
	SEMICOLON
’’: C
}
’’D E
;
’’E F
default
÷÷ 
:
÷÷ 
break
◊◊ 
;
◊◊ 
}
ÿÿ 
throw
⁄⁄ 
new
⁄⁄ %
NotImplementedException
⁄⁄ -
(
⁄⁄- .
)
⁄⁄. /
;
⁄⁄/ 0
}
€€ 	
}
‹‹ 
}›› ˙
5F:\Documents\GITrepos\Compil\Compil\Compil\Program.cs
	namespace 	
Compil
 
{ 
static 

class 
Program 
{		 
static

 
void

 
Main

 
(

 
string

 
[

  
]

  !
args

" &
)

& '
{ 	
try 
{ 
Console 
. 
	WriteLine !
(! "
$str" 3
+4 5
args6 :
[: ;
args; ?
.? @
Length@ F
-G H
$numI J
]J K
)K L
;L M
string 
pathFile 
=  !
Path" &
.& '
Combine' .
(. /
args/ 3
[3 4
args4 8
.8 9
Length9 ?
-@ A
$numB C
]C D
)D E
;E F
string 
codeTemp 
=  !
File" &
.& '
ReadAllText' 2
(2 3
pathFile3 ;
); <
;< =
Console 
. 
	WriteLine !
(! "
$str" 3
)3 4
;4 5
Console 
. 
	WriteLine !
(! "
codeTemp" *
)* +
;+ ,
Console 
. 
	WriteLine !
(! "
$str" >
)> ?
;? @
Console 
. 
ReadKey 
(  
)  !
;! "
Console 
. 
	WriteLine !
(! "
)" #
;# $
var 
lexicalAnalyser #
=$ %
new& )
LexicalAnalyzer* 9
(9 :
codeTemp: B
,B C
$numD E
)E F
;F G
var 
syntaxAnalyzer "
=# $
new% (
SyntaxAnalyzer) 7
(7 8
lexicalAnalyser8 G
)G H
;H I
var 

fileWriter 
=  
new! $

FileWriter% /
(/ 0
)0 1
;1 2

fileWriter!! 
.!! 
InitFile!! #
(!!# $
)!!$ %
;!!% &

fileWriter"" 
."" 
	WriteFile"" $
(""$ %
)""% &
;""& '
var&& 
node&& 
=&& 
syntaxAnalyzer&& )
.&&) *

Expression&&* 4
(&&4 5
$num&&5 6
)&&6 7
;&&7 8
node'' 
.'' 
Print'' 
('' 
$str'' 
,'' 
false'' $
)''$ %
;''% &
Console)) 
.)) 
	WriteLine)) !
())! "
)))" #
;))# $
Console,, 
.,, 
	WriteLine,, !
(,,! "
$str,," <
),,< =
;,,= >
Console-- 
.-- 
ReadKey-- 
(--  
)--  !
;--! "
}.. 
catch// 
(// $
EncoderFallbackException// +
e//, -
)//- .
{00 
Console11 
.11 
	WriteLine11 !
(11! "
e11" #
.11# $

StackTrace11$ .
)11. /
;11/ 0
}22 
}33 	
}44 
}55 
EF:\Documents\GITrepos\Compil\Compil\Compil\Properties\AssemblyInfo.cs
[ 
assembly 	
:	 

AssemblyTitle 
( 
$str !
)! "
]" #
[ 
assembly 	
:	 

AssemblyDescription 
( 
$str !
)! "
]" #
[		 
assembly		 	
:			 
!
AssemblyConfiguration		  
(		  !
$str		! #
)		# $
]		$ %
[

 
assembly

 	
:

	 

AssemblyCompany

 
(

 
$str

 
)

 
]

 
[ 
assembly 	
:	 

AssemblyProduct 
( 
$str #
)# $
]$ %
[ 
assembly 	
:	 

AssemblyCopyright 
( 
$str 0
)0 1
]1 2
[ 
assembly 	
:	 

AssemblyTrademark 
( 
$str 
)  
]  !
[ 
assembly 	
:	 

AssemblyCulture 
( 
$str 
) 
] 
[ 
assembly 	
:	 


ComVisible 
( 
false 
) 
] 
[ 
assembly 	
:	 

Guid 
( 
$str 6
)6 7
]7 8
["" 
assembly"" 	
:""	 

AssemblyVersion"" 
("" 
$str"" $
)""$ %
]""% &
[## 
assembly## 	
:##	 

AssemblyFileVersion## 
(## 
$str## (
)##( )
]##) *π
;F:\Documents\GITrepos\Compil\Compil\Compil\Objects\Token.cs
	namespace 	
Compil
 
{ 
class 	
Token
 
{		 
public 
string 
Name 
{ 
get  
;  !
set" %
;% &
}' (
public 
int 
Value 
{ 
get 
; 
set  #
;# $
}% &
public 
int 
Line 
{ 
get 
; 
set "
;" #
}$ %
public 
int 
Column 
{ 
get 
;  
set! $
;$ %
}& '
public 
	TokenType 
Type 
{ 
get  #
;# $
set% (
;( )
}* +
} 
} ®
>F:\Documents\GITrepos\Compil\Compil\Compil\Utils\FileWriter.cs
	namespace 	
Compil
 
. 
Utils 
{ 
public		 

class		 

FileWriter		 
{

 
private 
readonly 
string 
pathFileCode  ,
;, -
private 
string 
code 
; 
public 

FileWriter 
( 
) 
{ 	
code 
= 
String 
. 
Empty 
;  
pathFileCode 
= 
Path 
.  
Combine  '
(' (
Environment( 3
.3 4
CurrentDirectory4 D
,D E
$strF P
)P Q
;Q R
} 	
public 
void 
InitFile 
( 
) 
{ 	
code 
+= 
$str 
+ 
$str #
;# $
} 	
public$$ 
void$$ 
WriteCommand$$  
($$  !
string$$! '
cmd$$( +
)$$+ ,
{%% 	
code&& 
+=&& 
cmd&& 
+&& 
$str&& 
;&& 
}'' 	
public,, 
void,, 
	WriteFile,, 
(,, 
),, 
{-- 	
try.. 
{// 
code00 
+=00 
$str00 
;00 
if11 
(11 
File11 
.11 
Exists11 
(11  
pathFileCode11  ,
)11, -
)11- .
File22 
.22 
Delete22 
(22  
pathFileCode22  ,
)22, -
;22- .
File44 
.44 
WriteAllText44 !
(44! "
pathFileCode44" .
,44. /
code440 4
)444 5
;445 6
}55 
catch66 
(66 
	Exception66 
e66 
)66 
{77 
Console88 
.88 
	WriteLine88 !
(88! "
e88" #
.88# $
Message88$ +
)88+ ,
;88, -
Console99 
.99 
	WriteLine99 !
(99! "
e99" #
.99# $

StackTrace99$ .
)99. /
;99/ 0
}:: 
};; 	
}<< 
}== Ú	
<F:\Documents\GITrepos\Compil\Compil\Compil\Utils\NodeType.cs
	namespace 	
Compil
 
. 
Utils 
{ 
public 

enum 
NodeType 
{ 

IDENTIFIER 
, 
CONSTANT 
, 
MINUS		 
,		 
PLUS

 
,

 
NOT 
, 
OP_PLUS 
, 
OP_MINUS 
, 
OP_MULTIPLY 
, 
	OP_DIVIDE 
, 
	OP_MODULO 
, 
OP_POWER 
, 

COMP_EQUAL 
, 
COMP_DIFFERENT 
, 
COMP_SUPPERIOR 
, 
COMP_INFERIOR 
, #
COMP_SUPPERIOR_OR_EQUAL 
,  "
COMP_INFERIOR_OR_EQUAL 
, 
AND 
, 
OR 

,
 
IF 

,
 
ELSE   
,   
FOR!! 
,!! 
WHILE"" 
,"" 
DO## 

,##
 
SWITCH$$ 
,$$ 
CASE%% 
,%% 
INT&& 
,&& 
VOID'' 
}(( 
})) Õ
<F:\Documents\GITrepos\Compil\Compil\Compil\Utils\Operator.cs
	namespace 	
Compil
 
. 
Utils 
{ 
class 	
Operator
 
{ 
public 
Token 
Token 
{ 
get  
;  !
set" %
;% &
}' (
public 
Node 
Node 
{ 
get 
; 
set  #
;# $
}% &
public 
int 
Priority 
{ 
get !
;! "
set# &
;& '
}( )
public 
int 
Association 
{  
get! $
;$ %
set& )
;) *
}+ ,
}		 
}

 ’
=F:\Documents\GITrepos\Compil\Compil\Compil\Utils\TokenType.cs
	namespace 	
Compil
 
. 
Utils 
{ 
public 

enum 
	TokenType 
{ 

IDENTIFIER 
, 
CONSTANT 
, 
END_OF_FILE		 
,		 
NOT 
, 
PLUS 
, 
MINUS 
, 
MULTIPLY 
, 
DIVIDE 
, 
MODULO 
, 
POWER 
, 
IF 

,
 
ELSE 
, 
FOR 
, 
WHILE 
, 
DO 

,
 
SWITCH 
, 
CASE 
, 
INT 
, 
VOID 
, 

COMP_EQUAL 
, 
COMP_DIFFERENT 
, 
COMP_SUPPERIOR   
,   
COMP_INFERIOR!! 
,!! #
COMP_SUPPERIOR_OR_EQUAL"" 
,""  "
COMP_INFERIOR_OR_EQUAL## 
,## 
PAR_OPEN%% 
,%% 
	PAR_CLOSE&& 
,&& 
OR(( 

,((
 
AND)) 
,)) 
EQUAL++ 
,++ 
BRACKET_OPEN.. 
,.. 
BRACKET_CLOSE// 
,// 
	SEMICOLON11 
,11 
COMA22 
,22 
COMMENT_LINE33 
,33 
COMMENT_BLOCK_START44 
,44 
COMMENT_BLOCK_END55 
}66 
}77 