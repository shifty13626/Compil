äö
EF:\Documents\GITrepos\Compil\Compil\Compil\Analyzer\SyntaxAnalyzer.cs
	namespace 	
Compil
 
{ 
public 

class 
SyntaxAnalyzer 
{ 
private 
readonly 
LexicalAnalyzer (
_lexicalAnalyzer) 9
;9 :
private 
readonly 

Dictionary #
<# $
	TokenType$ -
,- .
(/ 0
NodeType0 8
,8 9
string: @
,@ A
intB E
,E F
intG J
)J K
>K L!
_exprTokenToNodeMatchM b
=c d
newe h

Dictionaryi s
<s t
	TokenTypet }
,} ~
(	 Ä
NodeType
Ä à
,
à â
string
ä ê
,
ê ë
int
í ï
,
ï ñ
int
ó ö
)
ö õ
>
õ ú
(
ú ù
)
ù û
{ 	
{ 
	TokenType 
. 
OR 
, 
( 
NodeType $
.$ %
OR% '
,' (
$str) ,
,, -
$num. /
,/ 0
$num1 2
)2 3
}3 4
,4 5
{ 
	TokenType 
. 
AND 
, 
( 
NodeType %
.% &
AND& )
,) *
$str+ .
,. /
$num0 1
,1 2
$num3 4
)4 5
}5 6
,6 7
{ 
	TokenType 
. 
NOT 
, 
( 
NodeType %
.% &
NOT& )
,) *
$str+ .
,. /
$num0 1
,1 2
$num3 4
)4 5
}5 6
,6 7
{ 
	TokenType 
. 

COMP_EQUAL !
,! "
(# $
NodeType$ ,
., -

COMP_EQUAL- 7
,7 8
$str9 =
,= >
$num? @
,@ A
$numB C
)C D
}D E
,E F
{ 
	TokenType 
. 
PLUS 
, 
( 
NodeType &
.& '
OP_PLUS' .
,. /
$str0 3
,3 4
$num5 6
,6 7
$num8 9
)9 :
}: ;
,; <
{ 
	TokenType 
. 
MINUS 
, 
( 
NodeType '
.' (
OP_MINUS( 0
,0 1
$str2 5
,5 6
$num7 8
,8 9
$num: ;
); <
}< =
,= >
{ 
	TokenType 
. 
POWER 
, 
( 
NodeType '
.' (
OP_POWER( 0
,0 1
$str2 5
,5 6
$num7 8
,8 9
$num: ;
); <
}< =
,= >
{ 
	TokenType 
. 
DIVIDE 
, 
(  
NodeType  (
.( )
	OP_DIVIDE) 2
,2 3
$str4 7
,7 8
$num9 :
,: ;
$num< =
)= >
}> ?
,? @
{ 
	TokenType 
. 
MODULO 
, 
(  
NodeType  (
.( )
	OP_MODULO) 2
,2 3
$str4 7
,7 8
$num9 :
,: ;
$num< =
)= >
}> ?
,? @
{ 
	TokenType 
. 
MULTIPLY 
,  
(! "
NodeType" *
.* +
OP_MULTIPLY+ 6
,6 7
$str8 ;
,; <
$num= >
,> ?
$num@ A
)A B
}B C
,C D
{ 
	TokenType 
. 
COMP_INFERIOR $
,$ %
(& '
NodeType' /
./ 0
COMP_INFERIOR0 =
,= >
$str? B
,B C
$numD E
,E F
$numG H
)H I
}I J
,J K
{ 
	TokenType 
. 
COMP_DIFFERENT %
,% &
(' (
NodeType( 0
.0 1
COMP_DIFFERENT1 ?
,? @
$strA E
,E F
$numG H
,H I
$numJ K
)K L
}L M
,M N
{ 
	TokenType 
. 
COMP_SUPPERIOR %
,% &
(' (
NodeType( 0
.0 1
COMP_SUPPERIOR1 ?
,? @
$strA D
,D E
$numF G
,G H
$numI J
)J K
}K L
,L M
{ 
	TokenType 
. "
COMP_INFERIOR_OR_EQUAL -
,- .
(/ 0
NodeType0 8
.8 9"
COMP_INFERIOR_OR_EQUAL9 O
,O P
$strQ U
,U V
$numW X
,X Y
$numZ [
)[ \
}\ ]
,] ^
{   
	TokenType   
.   #
COMP_SUPPERIOR_OR_EQUAL   .
,  . /
(  0 1
NodeType  1 9
.  9 :#
COMP_SUPPERIOR_OR_EQUAL  : Q
,  Q R
$str  S W
,  W X
$num  Y Z
,  Z [
$num  \ ]
)  ] ^
}  ^ _
,  _ `
{!! 
	TokenType!! 
.!! 
EQUAL!! 
,!! 
(!! 
NodeType!! '
.!!' (
AFFECT!!( .
,!!. /
$str!!0 3
,!!3 4
$num!!5 6
,!!6 7
$num!!8 9
)!!9 :
}!!: ;
}"" 	
;""	 

public(( 
SyntaxAnalyzer(( 
((( 
LexicalAnalyzer(( -
lexicalAnalyser((. =
)((= >
{)) 	
this** 
.** 
_lexicalAnalyzer** !
=**" #
lexicalAnalyser**$ 3
;**3 4
}++ 	
public00 
Node00 
Primary00 
(00 
)00 
{11 	
try22 
{33 
Node44 
node44 
;44 
if77 
(77 
_lexicalAnalyzer77 $
.77$ %
Next77% )
(77) *
)77* +
.77+ ,
Type77, 0
==771 3
	TokenType774 =
.77= >
CONSTANT77> F
)77F G
{88 
node99 
=99 
new99 
Node99 #
(99# $
)99$ %
{99& '
Type99( ,
=99- .
NodeType99/ 7
.997 8
CONSTANT998 @
,99@ A
Value99B G
=99H I
_lexicalAnalyzer99J Z
.99Z [
Next99[ _
(99_ `
)99` a
.99a b
Value99b g
.99g h
ToString99h p
(99p q
)99q r
}99s t
;99t u
_lexicalAnalyzer:: $
.::$ %
Skip::% )
(::) *
)::* +
;::+ ,
return;; 
node;; 
;;;  
}<< 
if?? 
(?? 
_lexicalAnalyzer?? $
.??$ %
Next??% )
(??) *
)??* +
.??+ ,
Type??, 0
==??1 3
	TokenType??4 =
.??= >
PAR_OPEN??> F
)??F G
{@@ 
_lexicalAnalyzerAA $
.AA$ %
SkipAA% )
(AA) *
)AA* +
;AA+ ,
nodeBB 
=BB 

ExpressionBB %
(BB% &
$numBB& '
)BB' (
;BB( )
_lexicalAnalyzerCC $
.CC$ %
AcceptCC% +
(CC+ ,
	TokenTypeCC, 5
.CC5 6
	PAR_CLOSECC6 ?
)CC? @
;CC@ A
returnDD 
nodeDD 
;DD  
}EE 
ifHH 
(HH 
_lexicalAnalyzerHH $
.HH$ %
NextHH% )
(HH) *
)HH* +
.HH+ ,
TypeHH, 0
==HH1 3
	TokenTypeHH4 =
.HH= >
MINUSHH> C
||HHD F
_lexicalAnalyzerII $
.II$ %
NextII% )
(II) *
)II* +
.II+ ,
TypeII, 0
==II1 3
	TokenTypeII4 =
.II= >
PLUSII> B
||IIC E
_lexicalAnalyzerJJ $
.JJ$ %
NextJJ% )
(JJ) *
)JJ* +
.JJ+ ,
TypeJJ, 0
==JJ1 3
	TokenTypeJJ4 =
.JJ= >
NOTJJ> A
)JJA B
{KK 
varLL 
(LL 
nodeTypeLL !
,LL! "
valLL# &
,LL& '
_LL( )
,LL) *
_LL+ ,
)LL, -
=LL. /!
_exprTokenToNodeMatchLL0 E
[LLE F
_lexicalAnalyzerLLF V
.LLV W
NextLLW [
(LL[ \
)LL\ ]
.LL] ^
TypeLL^ b
]LLb c
;LLc d
nodeMM 
=MM 
newMM 
NodeMM #
(MM# $
)MM$ %
{MM& '
TypeMM( ,
=MM- .
nodeTypeMM/ 7
,MM7 8
ValueMM9 >
=MM? @
valMMA D
}MME F
;MMF G
_lexicalAnalyzerNN $
.NN$ %
SkipNN% )
(NN) *
)NN* +
;NN+ ,
nodeOO 
.OO 
AddChildOO !
(OO! "

ExpressionOO" ,
(OO, -
$numOO- .
)OO. /
)OO/ 0
;OO0 1
returnPP 
nodePP 
;PP  
}QQ 
ifTT 
(TT 
_lexicalAnalyzerTT $
.TT$ %
NextTT% )
(TT) *
)TT* +
.TT+ ,
TypeTT, 0
==TT1 3
	TokenTypeTT4 =
.TT= >

IDENTIFIERTT> H
)TTH I
{UU 
nodeVV 
=VV 
newVV 
NodeVV #
(VV# $
)VV$ %
{VV& '
TypeVV( ,
=VV- .
NodeTypeVV/ 7
.VV7 8
VARIABLEVV8 @
,VV@ A
ValueVVB G
=VVH I
_lexicalAnalyzerVVJ Z
.VVZ [
NextVV[ _
(VV_ `
)VV` a
.VVa b
NameVVb f
.VVf g
ToStringVVg o
(VVo p
)VVp q
}VVr s
;VVs t
_lexicalAnalyzerWW $
.WW$ %
SkipWW% )
(WW) *
)WW* +
;WW+ ,
returnXX 
nodeXX 
;XX  
}YY 
throw\\ 
new\\ !
ArgumentNullException\\ /
(\\/ 0
$str\\0 C
)\\C D
;\\D E
}]] 
catch^^ 
(^^ #
NotImplementedException^^ *
e^^+ ,
)^^, -
{__ 
Console`` 
.`` 
	WriteLine`` !
(``! "
$str``" <
)``< =
;``= >
Consoleaa 
.aa 
	WriteLineaa !
(aa! "
eaa" #
.aa# $

StackTraceaa$ .
)aa. /
;aa/ 0
returnbb 
nullbb 
;bb 
}cc 
catchdd 
(dd !
ArgumentNullExceptiondd (
edd) *
)dd* +
{ee 
Consoleff 
.ff 
	WriteLineff !
(ff! "
eff" #
.ff# $
Messageff$ +
)ff+ ,
;ff, -
Consolegg 
.gg 
	WriteLinegg !
(gg! "
egg" #
.gg# $

StackTracegg$ .
)gg. /
;gg/ 0
returnhh 
nullhh 
;hh 
}ii 
}jj 	
publicqq 
Nodeqq 

Expressionqq 
(qq 
intqq "
pMinqq# '
=qq( )
$numqq* +
)qq+ ,
{rr 	
varss 
leftNodess 
=ss 
Primaryss "
(ss" #
)ss# $
;ss$ %
whileuu 
(uu 
trueuu 
)uu 
{vv 
ifww 
(ww 
_lexicalAnalyzerww $
.ww$ %
Nextww% )
(ww) *
)ww* +
==ww, .
nullww/ 3
)ww3 4
returnxx 
leftNodexx #
;xx# $
varzz 
opzz 
=zz 
SearchOpzz !
(zz! "
_lexicalAnalyzerzz" 2
.zz2 3
Nextzz3 7
(zz7 8
)zz8 9
)zz9 :
;zz: ;
if|| 
(|| 
op|| 
==|| 
null|| 
|||| !
op||" $
.||$ %
Priority||% -
<||. /
pMin||0 4
)||4 5
return}} 
leftNode}} #
;}}# $
_lexicalAnalyzer  
.  !
Skip! %
(% &
)& '
;' (
var
ÄÄ 
	rightNode
ÄÄ 
=
ÄÄ 

Expression
ÄÄ  *
(
ÄÄ* +
op
ÄÄ+ -
.
ÄÄ- .
Priority
ÄÄ. 6
+
ÄÄ7 8
op
ÄÄ9 ;
.
ÄÄ; <
Association
ÄÄ< G
)
ÄÄG H
;
ÄÄH I
var
ÅÅ 
tree
ÅÅ 
=
ÅÅ 
new
ÅÅ 
Node
ÅÅ #
(
ÅÅ# $
)
ÅÅ$ %
{
ÅÅ& '
Type
ÅÅ( ,
=
ÅÅ- .
op
ÅÅ/ 1
.
ÅÅ1 2
Node
ÅÅ2 6
.
ÅÅ6 7
Type
ÅÅ7 ;
}
ÅÅ< =
;
ÅÅ= >
tree
ÇÇ 
.
ÇÇ 
AddChild
ÇÇ 
(
ÇÇ 
leftNode
ÇÇ &
)
ÇÇ& '
;
ÇÇ' (
tree
ÉÉ 
.
ÉÉ 
AddChild
ÉÉ 
(
ÉÉ 
	rightNode
ÉÉ '
)
ÉÉ' (
;
ÉÉ( )
leftNode
ÑÑ 
=
ÑÑ 
tree
ÑÑ 
;
ÑÑ  
}
ÖÖ 
}
ÜÜ 	
public
çç 
Operator
çç 
SearchOp
çç  
(
çç  !
Token
çç! &
token
çç' ,
)
çç, -
{
éé 	
if
èè 
(
èè #
_exprTokenToNodeMatch
èè %
.
èè% &
TryGetValue
èè& 1
(
èè1 2
token
èè2 7
.
èè7 8
Type
èè8 <
,
èè< =
out
èè> A
var
èèB E
vals
èèF J
)
èèJ K
)
èèK L
{
êê 
var
ëë 
(
ëë 
nodetype
ëë 
,
ëë 
val
ëë "
,
ëë" #
priority
ëë$ ,
,
ëë, -
assos
ëë. 3
)
ëë3 4
=
ëë5 6
vals
ëë7 ;
;
ëë; <
return
íí 
new
íí 
Operator
íí #
(
íí# $
)
íí$ %
{
íí& '
Token
íí( -
=
íí. /
token
íí0 5
,
íí5 6
Node
íí7 ;
=
íí< =
new
íí> A
Node
ííB F
(
ííF G
)
ííG H
{
ííI J
Type
ííK O
=
ííP Q
nodetype
ííR Z
}
íí[ \
,
íí\ ]
Priority
íí^ f
=
ííg h
priority
ííi q
,
ííq r
Association
íís ~
=íí Ä
assosííÅ Ü
}ííá à
;ííà â
}
ìì 
return
îî 
null
îî 
;
îî 
}
ïï 	
public
óó 
Node
óó 
Instruction
óó 
(
óó  
)
óó  !
{
òò 	
if
ôô 
(
ôô 
_lexicalAnalyzer
ôô  
.
ôô  !
Next
ôô! %
(
ôô% &
)
ôô& '
.
ôô' (
Type
ôô( ,
==
ôô- /
	TokenType
ôô0 9
.
ôô9 :
IF
ôô: <
)
ôô< =
{
öö 
_lexicalAnalyzer
õõ  
.
õõ  !
Skip
õõ! %
(
õõ% &
)
õõ& '
;
õõ' (
_lexicalAnalyzer
úú  
.
úú  !
Accept
úú! '
(
úú' (
	TokenType
úú( 1
.
úú1 2
PAR_OPEN
úú2 :
)
úú: ;
;
úú; <
var
ùù 
aTest
ùù 
=
ùù 

Expression
ùù &
(
ùù& '
)
ùù' (
;
ùù( )
_lexicalAnalyzer
ûû  
.
ûû  !
Accept
ûû! '
(
ûû' (
	TokenType
ûû( 1
.
ûû1 2
	PAR_CLOSE
ûû2 ;
)
ûû; <
;
ûû< =
var
üü 
aCode
üü 
=
üü 
Instruction
üü '
(
üü' (
)
üü( )
;
üü) *
var
†† 
node
†† 
=
†† 
new
†† 
Node
†† #
(
††# $
)
††$ %
{
††& '
Type
††' +
=
††, -
NodeType
††. 6
.
††6 7
	CONDITION
††7 @
}
††@ A
;
††A B
node
°° 
.
°° 
AddChild
°° 
(
°° 
aTest
°° #
)
°°# $
;
°°$ %
node
¢¢ 
.
¢¢ 
AddChild
¢¢ 
(
¢¢ 
aCode
¢¢ #
)
¢¢# $
;
¢¢$ %
return
££ 
node
££ 
;
££ 
}
§§ 
else
•• 
if
•• 
(
•• 
_lexicalAnalyzer
•• %
.
••% &
Next
••& *
(
••* +
)
••+ ,
.
••, -
Type
••- 1
==
••2 4
	TokenType
••5 >
.
••> ?
BRACKET_OPEN
••? K
)
••K L
{
¶¶ 
var
ßß 
node
ßß 
=
ßß 
new
ßß 
Node
ßß #
(
ßß# $
)
ßß$ %
{
ßß& '
Type
ßß' +
=
ßß, -
NodeType
ßß. 6
.
ßß6 7
BLOCK
ßß7 <
}
ßß< =
;
ßß= >
_lexicalAnalyzer
®®  
.
®®  !
Accept
®®! '
(
®®' (
	TokenType
®®( 1
.
®®1 2
BRACKET_OPEN
®®2 >
)
®®> ?
;
®®? @
while
©© 
(
©© 
_lexicalAnalyzer
©© '
.
©©' (
Next
©©( ,
(
©©, -
)
©©- .
.
©©. /
Type
©©/ 3
!=
©©4 6
	TokenType
©©7 @
.
©©@ A
BRACKET_CLOSE
©©A N
)
©©N O
{
™™ 
var
´´ 
x
´´ 
=
´´ 
Instruction
´´ '
(
´´' (
)
´´( )
;
´´) *
node
¨¨ 
.
¨¨ 
AddChild
¨¨ !
(
¨¨! "
x
¨¨" #
)
¨¨# $
;
¨¨$ %
}
≠≠ 
_lexicalAnalyzer
ÆÆ  
.
ÆÆ  !
Accept
ÆÆ! '
(
ÆÆ' (
	TokenType
ÆÆ( 1
.
ÆÆ1 2
BRACKET_CLOSE
ÆÆ2 ?
)
ÆÆ? @
;
ÆÆ@ A
return
ØØ 
node
ØØ 
;
ØØ 
}
∞∞ 
else
±± 
{
≤≤ 
var
≥≥ 
ex
≥≥ 
=
≥≥ 

Expression
≥≥ #
(
≥≥# $
)
≥≥$ %
;
≥≥% &
_lexicalAnalyzer
¥¥  
.
¥¥  !
Accept
¥¥! '
(
¥¥' (
	TokenType
¥¥( 1
.
¥¥1 2
	SEMICOLON
¥¥2 ;
)
¥¥; <
;
¥¥< =
var
µµ 
node
µµ 
=
µµ 
new
µµ 
Node
µµ #
(
µµ# $
)
µµ$ %
{
µµ& '
Type
µµ' +
=
µµ, -
NodeType
µµ. 6
.
µµ6 7

EXPRESSION
µµ7 A
}
µµA B
;
µµB C
node
∂∂ 
.
∂∂ 
AddChild
∂∂ 
(
∂∂ 
ex
∂∂  
)
∂∂  !
;
∂∂! "
return
∑∑ 
node
∑∑ 
;
∑∑ 
}
∏∏ 
}
ππ 	
}
ªª 
}ºº Õ
8F:\Documents\GITrepos\Compil\Compil\Compil\Compilator.cs
	namespace 	
Compil
 
{ 
public 

class 

Compilator 
{ 
public		 
void		 
Compile		 
(		 
string		 "
	inputCode		# ,
,		, -
string		. 4

outputPath		5 ?
)		? @
{

 	
var 
lexicalAnalyser 
=  !
new" %
LexicalAnalyzer& 5
(5 6
	inputCode6 ?
,? @
$numA B
)B C
;C D
var 
syntaxAnalyzer 
=  
new! $
SyntaxAnalyzer% 3
(3 4
lexicalAnalyser4 C
)C D
;D E
var 

fileWriter 
= 
new  

FileWriter! +
(+ ,
), -
;- .
var 
node 
= 
syntaxAnalyzer %
.% &

Expression& 0
(0 1
$num1 2
)2 3
;3 4
var 
codeGenerator 
= 
new  #
CodeGenerator$ 1
(1 2

fileWriter2 <
,< =
false> C
)C D
;D E
codeGenerator 
. 
GenerateCode &
(& '
node' +
)+ ,
;, -
} 	
} 
} Å
NF:\Documents\GITrepos\Compil\Compil\Compil\Exceptions\NotValidCharException.cs
	namespace 	
Compil
 
. 

Exceptions 
{ 
class 	!
NotValidCharException
 
{ 
public !
NotValidCharException $
($ %
)% &
{		 	
} 	
} 
} Œ:
EF:\Documents\GITrepos\Compil\Compil\Compil\Generator\CodeGenerator.cs
	namespace 	
Compil
 
. 
	Generator 
{ 
public 

class 
CodeGenerator 
{		 
private 
readonly 

FileWriter #
_fileWriter$ /
;/ 0
private 
readonly 
bool 
_debug $
;$ %
private 
readonly 

Dictionary #
<# $
NodeType$ ,
,, -
string. 4
>4 5
_operatorsToCode6 F
=G H
newI L

DictionaryM W
<W X
NodeTypeX `
,` a
stringb h
>h i
(i j
)j k
{ 	
{ 
NodeType 
. 
OP_PLUS 
, 
$str  %
}& '
,' (
{ 
NodeType 
. 
OP_MINUS 
,  
$str! &
}' (
,( )
{ 
NodeType 
. 
OP_MULTIPLY "
," #
$str$ )
}* +
,+ ,
{ 
NodeType 
. 
	OP_DIVIDE  
,  !
$str" '
}( )
,) *
{ 
NodeType 
. 
	OP_MODULO  
,  !
$str" '
}( )
,) *
{ 
NodeType 
. 
AND 
, 
$str !
}" #
,# $
{ 
NodeType 
. 
OR 
, 
$str 
}  !
} 	
;	 

public 
CodeGenerator 
( 

FileWriter '

fileWriter( 2
,2 3
bool4 8
debug9 >
)> ?
{ 	
_fileWriter   
=   

fileWriter   $
;  $ %
_debug!! 
=!! 
debug!! 
;!! 
}"" 	
public)) 
void)) 
GenerateCode))  
())  !
Node))! %
node))& *
)))* +
{** 	
if,, 
(,, 
node,, 
.,, 
Type,, 
==,, 
NodeType,, %
.,,% &
CONSTANT,,& .
),,. /
{-- 
_fileWriter.. 
... 
WriteCommand.. (
(..( )
$str..) 0
+..1 2
node..2 6
...6 7
Value..7 <
,..< =
_debug..> D
)..D E
;..E F
}// 
if22 
(22 
_operatorsToCode22  
.22  !
ContainsKey22! ,
(22, -
node22- 1
.221 2
Type222 6
)226 7
)227 8
{33 
GenerateCode44 
(44 
node44 !
.44! "
Children44" *
[44* +
$num44+ ,
]44, -
)44- .
;44. /
GenerateCode55 
(55 
node55 !
.55! "
Children55" *
[55* +
$num55+ ,
]55, -
)55- .
;55. /
_fileWriter66 
.66 
WriteCommand66 (
(66( )
_operatorsToCode66) 9
[669 :
node66: >
.66> ?
Type66? C
]66C D
,66D E
_debug66F L
)66L M
;66M N
}77 
switch:: 
(:: 
node:: 
.:: 
Type:: 
):: 
{;; 
case== 
NodeType== 
.== 
MINUS== #
:==# $
_fileWriter>> 
.>>  
WriteCommand>>  ,
(>>, -
$str>>- 5
,>>5 6
_debug>>7 =
)>>= >
;>>> ?
GenerateCode??  
(??  !
node??! %
.??% &
Children??& .
[??. /
$num??/ 0
]??0 1
)??1 2
;??2 3
_fileWriter@@ 
.@@  
WriteCommand@@  ,
(@@, -
$str@@- 2
,@@2 3
_debug@@4 :
)@@: ;
;@@; <
breakAA 
;AA 
caseBB 
NodeTypeBB 
.BB 
PLUSBB "
:BB" #
_fileWriterCC 
.CC  
WriteCommandCC  ,
(CC, -
$strCC- 5
,CC5 6
_debugCC7 =
)CC= >
;CC> ?
GenerateCodeDD  
(DD  !
nodeDD! %
.DD% &
ChildrenDD& .
[DD. /
$numDD/ 0
]DD0 1
)DD1 2
;DD2 3
_fileWriterEE 
.EE  
WriteCommandEE  ,
(EE, -
$strEE- 2
,EE2 3
_debugEE4 :
)EE: ;
;EE; <
breakFF 
;FF 
}GG 
ifJJ 
(JJ 
nodeJJ 
.JJ 
TypeJJ 
==JJ 
NodeTypeJJ %
.JJ% &
VARIABLEJJ& .
)JJ. /
{KK 
_fileWriterLL 
.LL 
WriteCommandLL (
(LL( )
$strLL) 0
)LL0 1
;LL1 2
}MM 
ifOO 
(OO 
nodeOO 
.OO 
TypeOO 
==OO 
NodeTypeOO %
.OO% &
AFFECTOO& ,
)OO, -
{PP 
GenerateCodeQQ 
(QQ 
nodeQQ !
.QQ! "
ChildrenQQ" *
[QQ* +
$numQQ+ ,
]QQ, -
)QQ- .
;QQ. /
_fileWriterRR 
.RR 
WriteCommandRR (
(RR( )
$strRR) .
)RR. /
;RR/ 0
_fileWriterSS 
.SS 
WriteCommandSS (
(SS( )
$strSS) 0
)SS0 1
;SS1 2
}TT 
ifWW 
(WW 
nodeWW 
.WW 
TypeWW 
==WW 
NodeTypeWW %
.WW% &
BLOCKWW& +
)WW+ ,
{XX 
foreachYY 
(YY 
varYY 
childYY "
inYY# %
nodeYY& *
.YY* +
ChildrenYY+ 3
)YY3 4
{ZZ 
GenerateCode[[  
([[  !
child[[! &
)[[& '
;[[' (
}\\ 
}]] 
if`` 
(`` 
node`` 
.`` 
Type`` 
==`` 
NodeType`` %
.``% &

EXPRESSION``& 0
)``0 1
{aa 
GenerateCodebb 
(bb 
nodebb !
.bb! "
Childrenbb" *
[bb* +
$numbb+ ,
]bb, -
)bb- .
;bb. /
_fileWritercc 
.cc 
WriteCommandcc (
(cc( )
$strcc) /
)cc/ 0
;cc0 1
}dd 
ifgg 
(gg 
nodegg 
.gg 
Typegg 
==gg 
NodeTypegg %
.gg% &
	CONDITIONgg& /
)gg/ 0
{hh 
GenerateCodeii 
(ii 
nodeii !
.ii! "
Childrenii" *
[ii* +
$numii+ ,
]ii, -
)ii- .
;ii. /
}jj 
ifmm 
(mm 
nodemm 
.mm 
Typemm 
==mm 
NodeTypemm %
.mm% &

COMP_EQUALmm& 0
)mm0 1
{nn 
}pp 
}qq 	
}rr 
}ss ÿ≥
FF:\Documents\GITrepos\Compil\Compil\Compil\Analyzer\LexicalAnalyzer.cs
	namespace 	
Compil
 
{		 
public

 

class

 
LexicalAnalyzer

  
{ 
private 
readonly 
string 
code  $
;$ %
private 
int 
index 
; 
private 
readonly 

Dictionary #
<# $
string$ *
,* +
	TokenType, 5
>5 6
keywords7 ?
=@ A
newB E

DictionaryF P
<P Q
stringQ W
,W X
	TokenTypeY b
>b c
(c d
)d e
{ 	
{ 
$str 
, 
	TokenType 
. 
IF 
}  
,  !
{ 
$str 
, 
	TokenType 
. 
ELSE #
}# $
,$ %
{ 
$str 
, 
	TokenType 
. 
FOR !
}! "
," #
{ 
$str 
, 
	TokenType 
.  
WHILE  %
}% &
,& '
{ 
$str 
, 
	TokenType 
. 
DO 
}  
,  !
{ 
$str 
, 
	TokenType  
.  !
SWITCH! '
}' (
,( )
{ 
$str 
, 
	TokenType 
. 
CASE #
}# $
,$ %
{ 
$str 
, 
	TokenType 
. 
INT !
}! "
," #
{ 
$str 
, 
	TokenType 
. 
VOID #
}# $
} 	
;	 

private 
Token 
_currentNextToken '
;' (
private 
int 
_currentTokenLength '
=( )
$num* +
;+ ,
public%% 
LexicalAnalyzer%% 
(%% 
string%% %
code%%& *
,%%* +
int%%, /
index%%0 5
)%%5 6
{&& 	
this'' 
.'' 
code'' 
='' 
code'' 
;'' 
this(( 
.(( 
index(( 
=(( 
index(( 
;(( 
})) 	
public00 
Token00 
Next00 
(00 
)00 
{11 	
if22 
(22 
_currentNextToken22 !
!=22" $
null22% )
)22) *
{33 
return44 
_currentNextToken44 (
;44( )
}55 
var77 
result77 
=77 

DetectNext77 #
(77# $
)77$ %
;77% &
_currentNextToken88 
=88 
result88  &
;88& '
return99 
result99 
;99 
}:: 	
public?? 
void?? 
Skip?? 
(?? 
)?? 
{@@ 	
indexAA 
+=AA 
_currentTokenLengthAA (
;AA( )
_currentTokenLengthBB 
=BB  !
$numBB" #
;BB# $
_currentNextTokenCC 
=CC 
nullCC  $
;CC$ %
}DD 	
publicJJ 
voidJJ 
AcceptJJ 
(JJ 
	TokenTypeJJ $
typeJJ% )
)JJ) *
{KK 	
tryLL 
{MM 
ifNN 
(NN 
NextNN 
(NN 
)NN 
.NN 
TypeNN 
!=NN  "
typeNN# '
)NN' (
{OO 
throwPP 
newPP !
ArgumentNullExceptionPP 3
(PP3 4
$"PP4 6
Bad token: 'PP6 B
{PPB C
typePPC G
.PPG H
ToStringPPH P
(PPP Q
)PPQ R
}PPR S
' expected.PPS ^
"PP^ _
)PP_ `
;PP` a
}QQ 
SkipSS 
(SS 
)SS 
;SS 
}TT 
catchUU 
(UU !
ArgumentNullExceptionUU (
eUU) *
)UU* +
{VV 
ConsoleWW 
.WW 
	WriteLineWW !
(WW! "
eWW" #
.WW# $
MessageWW$ +
)WW+ ,
;WW, -
}XX 
}YY 	
private`` 
Token`` 

DetectNext``  
(``  !
)``! "
{aa 	
trybb 
{cc 
StringBuilderdd 
builderdd %
=dd& '
newdd( +
StringBuilderdd, 9
(dd9 :
)dd: ;
;dd; <
ifff 
(ff 
indexff 
==ff 
codeff !
.ff! "
Lengthff" (
)ff( )
{gg 
returnhh 
newhh 
Tokenhh $
(hh$ %
)hh% &
{hh' (
Typehh) -
=hh. /
	TokenTypehh0 9
.hh9 :
END_OF_FILEhh: E
}hhF G
;hhG H
}ii 
whilekk 
(kk 
codekk 
[kk 
indexkk !
]kk! "
==kk# %
$charkk& )
||kk* ,
codekk- 1
[kk1 2
indexkk2 7
]kk7 8
==kk9 ;
$charkk< @
||kkA C
codekkD H
[kkH I
indexkkI N
]kkN O
==kkP R
$charkkS W
||kkX Z
codekk[ _
[kk_ `
indexkk` e
]kke f
==kkg i
$charkkj n
)kkn o
{ll 
indexmm 
++mm 
;mm 
}nn 
ifqq 
(qq 
charqq 
.qq 
IsDigitqq  
(qq  !
codeqq! %
[qq% &
indexqq& +
]qq+ ,
)qq, -
)qq- .
{rr 
_currentTokenLengthss '
=ss( )
$numss* +
;ss+ ,
builderuu 
.uu 
Appenduu "
(uu" #
codeuu# '
[uu' (
indexuu( -
]uu- .
.uu. /
ToStringuu/ 7
(uu7 8
)uu8 9
)uu9 :
;uu: ;
ifww 
(ww 
indexww 
==ww  
codeww! %
.ww% &
Lengthww& ,
-ww- .
$numww/ 0
)ww0 1
{xx 
returnyy 
newyy "
Tokenyy# (
(yy( )
)yy) *
{yy+ ,
Typeyy- 1
=yy2 3
	TokenTypeyy4 =
.yy= >
CONSTANTyy> F
,yyF G
ValueyyH M
=yyN O
intyyP S
.yyS T
ParseyyT Y
(yyY Z
builderyyZ a
.yya b
ToStringyyb j
(yyj k
)yyk l
)yyl m
}yyn o
;yyo p
}zz 
var|| 
i|| 
=|| 
index|| !
+||" #
$num||$ %
;||% &
while}} 
(}} 
i}} 
<}} 
code}} #
.}}# $
Length}}$ *
&&}}+ -
char}}. 2
.}}2 3
IsDigit}}3 :
(}}: ;
code}}; ?
[}}? @
i}}@ A
]}}A B
)}}B C
)}}C D
{~~ 
builder 
.  
Append  &
(& '
code' +
[+ ,
i, -
]- .
.. /
ToString/ 7
(7 8
)8 9
)9 :
;: ;
i
ÄÄ 
++
ÄÄ 
;
ÄÄ !
_currentTokenLength
ÅÅ +
++
ÅÅ+ -
;
ÅÅ- .
}
ÇÇ 
return
ÑÑ 
new
ÑÑ 
Token
ÑÑ $
(
ÑÑ$ %
)
ÑÑ% &
{
ÑÑ' (
Type
ÑÑ) -
=
ÑÑ. /
	TokenType
ÑÑ0 9
.
ÑÑ9 :
CONSTANT
ÑÑ: B
,
ÑÑB C
Value
ÑÑD I
=
ÑÑJ K
int
ÑÑL O
.
ÑÑO P
Parse
ÑÑP U
(
ÑÑU V
builder
ÑÑV ]
.
ÑÑ] ^
ToString
ÑÑ^ f
(
ÑÑf g
)
ÑÑg h
)
ÑÑh i
}
ÑÑj k
;
ÑÑk l
}
ÖÖ 
if
àà 
(
àà 
char
àà 
.
àà 
IsLetter
àà !
(
àà! "
code
àà" &
[
àà& '
index
àà' ,
]
àà, -
)
àà- .
)
àà. /
{
ââ !
_currentTokenLength
ää '
=
ää( )
$num
ää* +
;
ää+ ,
builder
ãã 
.
ãã 
Append
ãã "
(
ãã" #
code
ãã# '
[
ãã' (
index
ãã( -
]
ãã- .
.
ãã. /
ToString
ãã/ 7
(
ãã7 8
)
ãã8 9
)
ãã9 :
;
ãã: ;
if
çç 
(
çç 
index
çç 
==
çç  
code
çç! %
.
çç% &
Length
çç& ,
-
çç- .
$num
çç/ 0
)
çç0 1
{
éé 
if
êê 
(
êê 
keywords
êê $
.
êê$ %
ContainsKey
êê% 0
(
êê0 1
builder
êê1 8
.
êê8 9
ToString
êê9 A
(
êêA B
)
êêB C
)
êêC D
)
êêD E
{
ëë 
return
íí "
new
íí# &
Token
íí' ,
(
íí, -
)
íí- .
{
íí/ 0
Type
íí1 5
=
íí6 7
keywords
íí8 @
[
íí@ A
builder
ííA H
.
ííH I
ToString
ííI Q
(
ííQ R
)
ííR S
]
ííS T
,
ííT U
Name
ííV Z
=
íí[ \
builder
íí] d
.
ííd e
ToString
ííe m
(
íím n
)
íín o
}
ííp q
;
ííq r
}
ìì 
return
ïï 
new
ïï "
Token
ïï# (
(
ïï( )
)
ïï) *
{
ïï+ ,
Type
ïï- 1
=
ïï2 3
	TokenType
ïï4 =
.
ïï= >

IDENTIFIER
ïï> H
,
ïïH I
Name
ïïJ N
=
ïïO P
builder
ïïQ X
.
ïïX Y
ToString
ïïY a
(
ïïa b
)
ïïb c
}
ïïd e
;
ïïe f
}
ññ 
var
òò 
i
òò 
=
òò 
index
òò !
+
òò" #
$num
òò$ %
;
òò% &
while
ôô 
(
ôô 
i
ôô 
<
ôô 
code
ôô #
.
ôô# $
Length
ôô$ *
&&
ôô+ -
(
ôô. /
char
ôô/ 3
.
ôô3 4
IsLetter
ôô4 <
(
ôô< =
code
ôô= A
[
ôôA B
i
ôôB C
]
ôôC D
)
ôôD E
||
ôôF H
char
ôôI M
.
ôôM N
IsDigit
ôôN U
(
ôôU V
code
ôôV Z
[
ôôZ [
i
ôô[ \
]
ôô\ ]
)
ôô] ^
)
ôô^ _
)
ôô_ `
{
öö 
builder
õõ 
.
õõ  
Append
õõ  &
(
õõ& '
code
õõ' +
[
õõ+ ,
i
õõ, -
]
õõ- .
.
õõ. /
ToString
õõ/ 7
(
õõ7 8
)
õõ8 9
)
õõ9 :
;
õõ: ;
i
úú 
++
úú 
;
úú !
_currentTokenLength
ùù +
++
ùù+ -
;
ùù- .
}
ûû 
if
°° 
(
°° 
keywords
°°  
.
°°  !
ContainsKey
°°! ,
(
°°, -
builder
°°- 4
.
°°4 5
ToString
°°5 =
(
°°= >
)
°°> ?
)
°°? @
)
°°@ A
{
¢¢ 
return
££ 
new
££ "
Token
££# (
(
££( )
)
££) *
{
££+ ,
Type
££- 1
=
££2 3
keywords
££4 <
[
££< =
builder
££= D
.
££D E
ToString
££E M
(
££M N
)
££N O
]
££O P
,
££P Q
Name
££R V
=
££W X
builder
££Y `
.
££` a
ToString
££a i
(
££i j
)
££j k
}
££l m
;
££m n
}
§§ 
return
¶¶ 
new
¶¶ 
Token
¶¶ $
(
¶¶$ %
)
¶¶% &
{
¶¶' (
Type
¶¶) -
=
¶¶. /
	TokenType
¶¶0 9
.
¶¶9 :

IDENTIFIER
¶¶: D
,
¶¶D E
Name
¶¶F J
=
¶¶K L
builder
¶¶M T
.
¶¶T U
ToString
¶¶U ]
(
¶¶] ^
)
¶¶^ _
}
¶¶` a
;
¶¶a b
}
ßß 
if
™™ 
(
™™ 
code
™™ 
[
™™ 
index
™™ 
]
™™ 
==
™™  "
$char
™™# &
)
™™& '
{
´´ !
_currentTokenLength
¨¨ '
=
¨¨( )
$num
¨¨* +
;
¨¨+ ,
builder
≠≠ 
.
≠≠ 
Append
≠≠ "
(
≠≠" #
code
≠≠# '
[
≠≠' (
index
≠≠( -
]
≠≠- .
.
≠≠. /
ToString
≠≠/ 7
(
≠≠7 8
)
≠≠8 9
)
≠≠9 :
;
≠≠: ;
if
ØØ 
(
ØØ 
index
ØØ 
==
ØØ  
code
ØØ! %
.
ØØ% &
Length
ØØ& ,
-
ØØ- .
$num
ØØ/ 0
)
ØØ0 1
{
∞∞ 
return
±± 
new
±± "
Token
±±# (
(
±±( )
)
±±) *
{
±±+ ,
Type
±±- 1
=
±±2 3
	TokenType
±±4 =
.
±±= >
EQUAL
±±> C
}
±±D E
;
±±E F
}
≤≤ 
if
¥¥ 
(
¥¥ 
code
¥¥ 
[
¥¥ 
index
¥¥ "
+
¥¥# $
$num
¥¥% &
]
¥¥& '
==
¥¥( *
$char
¥¥+ .
)
¥¥. /
{
µµ !
_currentTokenLength
∂∂ +
++
∂∂+ -
;
∂∂- .
return
∑∑ 
new
∑∑ "
Token
∑∑# (
(
∑∑( )
)
∑∑) *
{
∑∑+ ,
Type
∑∑- 1
=
∑∑2 3
	TokenType
∑∑4 =
.
∑∑= >

COMP_EQUAL
∑∑> H
}
∑∑I J
;
∑∑J K
}
∏∏ 
return
∫∫ 
new
∫∫ 
Token
∫∫ $
(
∫∫$ %
)
∫∫% &
{
∫∫' (
Type
∫∫) -
=
∫∫. /
	TokenType
∫∫0 9
.
∫∫9 :
EQUAL
∫∫: ?
}
∫∫@ A
;
∫∫A B
}
ªª 
if
ææ 
(
ææ 
code
ææ 
[
ææ 
index
ææ 
]
ææ 
==
ææ  "
$char
ææ# &
)
ææ& '
{
øø !
_currentTokenLength
¿¿ '
=
¿¿( )
$num
¿¿* +
;
¿¿+ ,
builder
¡¡ 
.
¡¡ 
Append
¡¡ "
(
¡¡" #
code
¡¡# '
[
¡¡' (
index
¡¡( -
]
¡¡- .
.
¡¡. /
ToString
¡¡/ 7
(
¡¡7 8
)
¡¡8 9
)
¡¡9 :
;
¡¡: ;
if
√√ 
(
√√ 
index
√√ 
==
√√  
code
√√! %
.
√√% &
Length
√√& ,
-
√√- .
$num
√√/ 0
)
√√0 1
{
ƒƒ 
return
≈≈ 
new
≈≈ "
Token
≈≈# (
(
≈≈( )
)
≈≈) *
{
≈≈+ ,
Type
≈≈- 1
=
≈≈2 3
	TokenType
≈≈4 =
.
≈≈= >
COMP_SUPPERIOR
≈≈> L
}
≈≈M N
;
≈≈N O
}
∆∆ 
if
»» 
(
»» 
code
»» 
[
»» 
index
»» "
+
»»# $
$num
»»% &
]
»»& '
==
»»( *
$char
»»+ .
)
»». /
{
…… !
_currentTokenLength
   +
++
  + -
;
  - .
return
ÀÀ 
new
ÀÀ "
Token
ÀÀ# (
(
ÀÀ( )
)
ÀÀ) *
{
ÀÀ+ ,
Type
ÀÀ- 1
=
ÀÀ2 3
	TokenType
ÀÀ4 =
.
ÀÀ= >%
COMP_SUPPERIOR_OR_EQUAL
ÀÀ> U
}
ÀÀV W
;
ÀÀW X
}
ÃÃ 
return
ŒŒ 
new
ŒŒ 
Token
ŒŒ $
(
ŒŒ$ %
)
ŒŒ% &
{
ŒŒ' (
Type
ŒŒ) -
=
ŒŒ. /
	TokenType
ŒŒ0 9
.
ŒŒ9 :
COMP_SUPPERIOR
ŒŒ: H
}
ŒŒI J
;
ŒŒJ K
}
œœ 
if
““ 
(
““ 
code
““ 
[
““ 
index
““ 
]
““ 
==
““  "
$char
““# &
)
““& '
{
”” !
_currentTokenLength
‘‘ '
=
‘‘( )
$num
‘‘* +
;
‘‘+ ,
builder
’’ 
.
’’ 
Append
’’ "
(
’’" #
code
’’# '
[
’’' (
index
’’( -
]
’’- .
.
’’. /
ToString
’’/ 7
(
’’7 8
)
’’8 9
)
’’9 :
;
’’: ;
if
◊◊ 
(
◊◊ 
index
◊◊ 
==
◊◊  
code
◊◊! %
.
◊◊% &
Length
◊◊& ,
-
◊◊- .
$num
◊◊/ 0
)
◊◊0 1
{
ÿÿ 
return
ŸŸ 
new
ŸŸ "
Token
ŸŸ# (
(
ŸŸ( )
)
ŸŸ) *
{
ŸŸ+ ,
Type
ŸŸ- 1
=
ŸŸ2 3
	TokenType
ŸŸ4 =
.
ŸŸ= >
COMP_INFERIOR
ŸŸ> K
}
ŸŸL M
;
ŸŸM N
}
⁄⁄ 
if
‹‹ 
(
‹‹ 
code
‹‹ 
[
‹‹ 
index
‹‹ "
+
‹‹# $
$num
‹‹% &
]
‹‹& '
==
‹‹( *
$char
‹‹+ .
)
‹‹. /
{
›› !
_currentTokenLength
ﬁﬁ +
++
ﬁﬁ+ -
;
ﬁﬁ- .
return
ﬂﬂ 
new
ﬂﬂ "
Token
ﬂﬂ# (
(
ﬂﬂ( )
)
ﬂﬂ) *
{
ﬂﬂ+ ,
Type
ﬂﬂ- 1
=
ﬂﬂ2 3
	TokenType
ﬂﬂ4 =
.
ﬂﬂ= >$
COMP_INFERIOR_OR_EQUAL
ﬂﬂ> T
}
ﬂﬂU V
;
ﬂﬂV W
}
‡‡ 
return
‚‚ 
new
‚‚ 
Token
‚‚ $
(
‚‚$ %
)
‚‚% &
{
‚‚' (
Type
‚‚) -
=
‚‚. /
	TokenType
‚‚0 9
.
‚‚9 :
COMP_INFERIOR
‚‚: G
}
‚‚H I
;
‚‚I J
}
„„ !
_currentTokenLength
ÂÂ #
++
ÂÂ# %
;
ÂÂ% &
switch
ÊÊ 
(
ÊÊ 
code
ÊÊ 
[
ÊÊ 
index
ÊÊ "
]
ÊÊ" #
)
ÊÊ# $
{
ÁÁ 
case
ËË 
$char
ËË 
:
ËË 
return
ÈÈ 
new
ÈÈ "
Token
ÈÈ# (
(
ÈÈ( )
)
ÈÈ) *
{
ÈÈ+ ,
Type
ÈÈ- 1
=
ÈÈ2 3
	TokenType
ÈÈ4 =
.
ÈÈ= >
PLUS
ÈÈ> B
}
ÈÈC D
;
ÈÈD E
case
ÍÍ 
$char
ÍÍ 
:
ÍÍ 
return
ÎÎ 
new
ÎÎ "
Token
ÎÎ# (
(
ÎÎ( )
)
ÎÎ) *
{
ÎÎ+ ,
Type
ÎÎ- 1
=
ÎÎ2 3
	TokenType
ÎÎ4 =
.
ÎÎ= >
MINUS
ÎÎ> C
}
ÎÎD E
;
ÎÎE F
case
ÏÏ 
$char
ÏÏ 
:
ÏÏ 
return
ÌÌ 
new
ÌÌ "
Token
ÌÌ# (
(
ÌÌ( )
)
ÌÌ) *
{
ÌÌ+ ,
Type
ÌÌ- 1
=
ÌÌ2 3
	TokenType
ÌÌ4 =
.
ÌÌ= >
MULTIPLY
ÌÌ> F
}
ÌÌG H
;
ÌÌH I
case
ÓÓ 
$char
ÓÓ 
:
ÓÓ 
return
ÔÔ 
new
ÔÔ "
Token
ÔÔ# (
(
ÔÔ( )
)
ÔÔ) *
{
ÔÔ+ ,
Type
ÔÔ- 1
=
ÔÔ2 3
	TokenType
ÔÔ4 =
.
ÔÔ= >
DIVIDE
ÔÔ> D
}
ÔÔE F
;
ÔÔF G
case
 
$char
 
:
 
return
ÒÒ 
new
ÒÒ "
Token
ÒÒ# (
(
ÒÒ( )
)
ÒÒ) *
{
ÒÒ+ ,
Type
ÒÒ- 1
=
ÒÒ2 3
	TokenType
ÒÒ4 =
.
ÒÒ= >
MODULO
ÒÒ> D
}
ÒÒE F
;
ÒÒF G
case
ÚÚ 
$char
ÚÚ 
:
ÚÚ 
return
ÛÛ 
new
ÛÛ "
Token
ÛÛ# (
(
ÛÛ( )
)
ÛÛ) *
{
ÛÛ+ ,
Type
ÛÛ- 1
=
ÛÛ2 3
	TokenType
ÛÛ4 =
.
ÛÛ= >
POWER
ÛÛ> C
}
ÛÛD E
;
ÛÛE F
case
ÙÙ 
$char
ÙÙ 
:
ÙÙ 
return
ıı 
new
ıı "
Token
ıı# (
(
ıı( )
)
ıı) *
{
ıı+ ,
Type
ıı- 1
=
ıı2 3
	TokenType
ıı4 =
.
ıı= >
PAR_OPEN
ıı> F
}
ııG H
;
ııH I
case
ˆˆ 
$char
ˆˆ 
:
ˆˆ 
return
˜˜ 
new
˜˜ "
Token
˜˜# (
(
˜˜( )
)
˜˜) *
{
˜˜+ ,
Type
˜˜- 1
=
˜˜2 3
	TokenType
˜˜4 =
.
˜˜= >
	PAR_CLOSE
˜˜> G
}
˜˜H I
;
˜˜I J
case
¯¯ 
$char
¯¯ 
:
¯¯ 
return
˘˘ 
new
˘˘ "
Token
˘˘# (
(
˘˘( )
)
˘˘) *
{
˘˘+ ,
Type
˘˘- 1
=
˘˘2 3
	TokenType
˘˘4 =
.
˘˘= >
BRACKET_OPEN
˘˘> J
}
˘˘K L
;
˘˘L M
case
˙˙ 
$char
˙˙ 
:
˙˙ 
return
˚˚ 
new
˚˚ "
Token
˚˚# (
(
˚˚( )
)
˚˚) *
{
˚˚+ ,
Type
˚˚- 1
=
˚˚2 3
	TokenType
˚˚4 =
.
˚˚= >
BRACKET_CLOSE
˚˚> K
}
˚˚L M
;
˚˚M N
case
¸¸ 
$char
¸¸ 
:
¸¸ 
return
˝˝ 
new
˝˝ "
Token
˝˝# (
(
˝˝( )
)
˝˝) *
{
˝˝+ ,
Type
˝˝- 1
=
˝˝2 3
	TokenType
˝˝4 =
.
˝˝= >
AND
˝˝> A
}
˝˝B C
;
˝˝C D
case
˛˛ 
$char
˛˛ 
:
˛˛ 
return
ˇˇ 
new
ˇˇ "
Token
ˇˇ# (
(
ˇˇ( )
)
ˇˇ) *
{
ˇˇ+ ,
Type
ˇˇ- 1
=
ˇˇ2 3
	TokenType
ˇˇ4 =
.
ˇˇ= >
OR
ˇˇ> @
}
ˇˇA B
;
ˇˇB C
case
ÄÄ 
$char
ÄÄ 
:
ÄÄ 
return
ÅÅ 
new
ÅÅ "
Token
ÅÅ# (
(
ÅÅ( )
)
ÅÅ) *
{
ÅÅ+ ,
Type
ÅÅ- 1
=
ÅÅ2 3
	TokenType
ÅÅ4 =
.
ÅÅ= >
	SEMICOLON
ÅÅ> G
}
ÅÅH I
;
ÅÅI J
default
ÇÇ 
:
ÇÇ 
break
ÉÉ 
;
ÉÉ 
}
ÑÑ 
throw
ÜÜ 
new
ÜÜ %
NotImplementedException
ÜÜ 1
(
ÜÜ1 2
)
ÜÜ2 3
;
ÜÜ3 4
}
áá 
catch
àà 
(
àà %
NotImplementedException
àà *
e
àà+ ,
)
àà, -
{
ââ 
Console
ää 
.
ää 
	WriteLine
ää !
(
ää! "
e
ää" #
.
ää# $
Message
ää$ +
)
ää+ ,
;
ää, -
return
ãã 
null
ãã 
;
ãã 
}
åå 
}
çç 	
}
éé 
}èè Å
8F:\Documents\GITrepos\Compil\Compil\Compil\Nodes\Node.cs
	namespace 	
Compil
 
{ 
public 

class 
Node 
{ 
public 
NodeType 
Type 
{ 
get "
;" #
set$ '
;' (
}) *
public 
string 
Value 
{ 
get !
;! "
set# &
;& '
}( )
public 
List 
< 
Node 
> 
Children "
{# $
get% (
;( )
set* -
;- .
}/ 0
=1 2
new3 6
List7 ;
<; <
Node< @
>@ A
(A B
)B C
;C D
public 
void 
AddChild 
( 
Node !
node" &
)& '
{ 	
Children 
. 
Add 
( 
node 
) 
; 
} 	
public## 
void## 
AddChildren## 
(##  
List##  $
<##$ %
Node##% )
>##) *
nodes##+ 0
)##0 1
{$$ 	
foreach%% 
(%% 
var%% 
node%% 
in%%  
nodes%%! &
)%%& '
Children&& 
.&& 
Add&& 
(&& 
node&& !
)&&! "
;&&" #
}'' 	
public.. 
void.. 
Print.. 
(.. 
string..  
indent..! '
,..' (
bool..) -
last... 2
)..2 3
{// 	
Console00 
.00 
Write00 
(00 
indent00  
)00  !
;00! "
if11 
(11 
last11 
)11 
{22 
Console33 
.33 
Write33 
(33 
$str33 #
)33# $
;33$ %
indent44 
+=44 
$str44 
;44 
}55 
else66 
{77 
Console88 
.88 
Write88 
(88 
$str88 "
)88" #
;88# $
indent99 
+=99 
$str99 
;99 
}:: 
if;; 
(;; 
Type;; 
==;; 
NodeType;;  
.;;  !
CONSTANT;;! )
);;) *
Console== 
.== 
	WriteLine== !
(==! "
$"==" $
VALUE: ==$ +
{==+ ,
Value==, 1
}==1 2
"==2 3
)==3 4
;==4 5
else>> 
if>> 
(>> 
Type>> 
==>> 
NodeType>> $
.>>$ %
VARIABLE>>% -
)>>- .
Console?? 
.?? 
	WriteLine?? !
(??! "
$"??" $
VARIABLE: name=??$ 3
{??3 4
Value??4 9
}??9 :
"??: ;
)??; <
;??< =
else@@ 
ConsoleBB 
.BB 
	WriteLineBB !
(BB! "
TypeBB" &
)BB& '
;BB' (
forDD 
(DD 
varDD 
iDD 
=DD 
$numDD 
;DD 
iDD 
<DD 
ChildrenDD  (
.DD( )
CountDD) .
;DD. /
iDD0 1
++DD1 3
)DD3 4
ChildrenEE 
[EE 
iEE 
]EE 
.EE 
PrintEE !
(EE! "
indentEE" (
,EE( )
iEE* +
==EE, .
ChildrenEE/ 7
.EE7 8
CountEE8 =
-EE> ?
$numEE@ A
)EEA B
;EEB C
}FF 	
}JJ 
}KK „

<F:\Documents\GITrepos\Compil\Compil\Compil\Nodes\NodeType.cs
	namespace 	
Compil
 
. 
Nodes 
{ 
public		 

enum		 
NodeType		 
{

 
VARIABLE 
, 
CONSTANT 
, 
MINUS 
, 
PLUS 
, 
NOT 
, 
OP_PLUS 
, 
OP_MINUS 
, 
OP_MULTIPLY 
, 
	OP_DIVIDE 
, 
	OP_MODULO 
, 
OP_POWER 
, 
AFFECT 
, 

COMP_EQUAL 
, 
COMP_DIFFERENT 
, 
COMP_SUPPERIOR 
, 
COMP_INFERIOR   
,   #
COMP_SUPPERIOR_OR_EQUAL!! 
,!!  "
COMP_INFERIOR_OR_EQUAL"" 
,"" 
AND%% 
,%% 
OR&& 

,&&
 
	CONDITION'' 
,'' 
ELSE(( 
,(( 
FOR)) 
,)) 
WHILE** 
,** 
DO++ 

,++
 
SWITCH,, 
,,, 
CASE-- 
,-- 
INT.. 
,.. 
VOID// 
,// 
BLOCK11 
,11 

EXPRESSION22 
}33 
}44 Ú!
5F:\Documents\GITrepos\Compil\Compil\Compil\Program.cs
	namespace		 	
Compil		
 
{

 
static 

class 
Program 
{ 
static 
void 
Main 
( 
string 
[  
]  !
args" &
)& '
{ 	
try 
{ 
if 
( 
args 
. 
Length 
==  "
$num# $
)$ %
throw 
new !
ArgumentNullException 3
(3 4
$str4 D
)D E
;E F
Console 
. 
	WriteLine !
(! "
$str" 3
+4 5
args6 :
[: ;
args; ?
.? @
Length@ F
-G H
$numI J
]J K
)K L
;L M
string 
pathFile 
=  !
Path" &
.& '
Combine' .
(. /
args/ 3
[3 4
args4 8
.8 9
Length9 ?
-@ A
$numB C
]C D
)D E
;E F
string 
codeTemp 
=  !
File" &
.& '
ReadAllText' 2
(2 3
pathFile3 ;
); <
;< =
Console 
. 
	WriteLine !
(! "
$str" 3
)3 4
;4 5
Console 
. 
	WriteLine !
(! "
codeTemp" *
)* +
;+ ,
Console 
. 
	WriteLine !
(! "
$str" >
)> ?
;? @
Console 
. 
ReadKey 
(  
)  !
;! "
Console 
. 
	WriteLine !
(! "
)" #
;# $
var!! 
lexicalAnalyser!! #
=!!$ %
new!!& )
LexicalAnalyzer!!* 9
(!!9 :
codeTemp!!: B
,!!B C
$num!!D E
)!!E F
;!!F G
var## 
syntaxAnalyzer## "
=### $
new##% (
SyntaxAnalyzer##) 7
(##7 8
lexicalAnalyser##8 G
)##G H
;##H I
var%% 

fileWriter%% 
=%%  
new%%! $

FileWriter%%% /
(%%/ 0
)%%0 1
;%%1 2

fileWriter'' 
.'' 
InitFile'' #
(''# $
)''$ %
;''% &
var** 
node** 
=** 
syntaxAnalyzer** )
.**) *
Instruction*** 5
(**5 6
)**6 7
;**7 8
node++ 
.++ 
Print++ 
(++ 
$str++ 
,++ 
false++ $
)++$ %
;++% &
var-- 
codeGenerator-- !
=--" #
new--$ '
CodeGenerator--( 5
(--5 6

fileWriter--6 @
,--@ A
true--B F
)--F G
;--G H
codeGenerator.. 
... 
GenerateCode.. *
(..* +
node..+ /
)../ 0
;..0 1

fileWriter11 
.11 
	WriteFile11 $
(11$ %
)11% &
;11& '
Console44 
.44 
	WriteLine44 !
(44! "
$str44" <
)44< =
;44= >
Console55 
.55 
ReadKey55 
(55  
)55  !
;55! "
}66 
catch77 
(77 $
EncoderFallbackException77 +
e77, -
)77- .
{88 
Console99 
.99 
	WriteLine99 !
(99! "
e99" #
.99# $

StackTrace99$ .
)99. /
;99/ 0
}:: 
catch;; 
(;; !
ArgumentNullException;; (
e;;) *
);;* +
{<< 
Console== 
.== 
	WriteLine== !
(==! "
$str==" K
)==K L
;==L M
Console>> 
.>> 
	WriteLine>> !
(>>! "
e>>" #
.>># $
Message>>$ +
)>>+ ,
;>>, -
}?? 
}@@ 	
}AA 
}BB 
EF:\Documents\GITrepos\Compil\Compil\Compil\Properties\AssemblyInfo.cs
[ 
assembly 	
:	 

AssemblyTitle 
( 
$str !
)! "
]" #
[ 
assembly 	
:	 

AssemblyDescription 
( 
$str !
)! "
]" #
[		 
assembly		 	
:			 
!
AssemblyConfiguration		  
(		  !
$str		! #
)		# $
]		$ %
[

 
assembly

 	
:

	 

AssemblyCompany

 
(

 
$str

 
)

 
]

 
[ 
assembly 	
:	 

AssemblyProduct 
( 
$str #
)# $
]$ %
[ 
assembly 	
:	 

AssemblyCopyright 
( 
$str 0
)0 1
]1 2
[ 
assembly 	
:	 

AssemblyTrademark 
( 
$str 
)  
]  !
[ 
assembly 	
:	 

AssemblyCulture 
( 
$str 
) 
] 
[ 
assembly 	
:	 


ComVisible 
( 
false 
) 
] 
[ 
assembly 	
:	 

Guid 
( 
$str 6
)6 7
]7 8
["" 
assembly"" 	
:""	 

AssemblyVersion"" 
("" 
$str"" $
)""$ %
]""% &
[## 
assembly## 	
:##	 

AssemblyFileVersion## 
(## 
$str## (
)##( )
]##) *ß
>F:\Documents\GITrepos\Compil\Compil\Compil\Utils\FileWriter.cs
	namespace 	
Compil
 
. 
Utils 
{ 
public		 

class		 

FileWriter		 
{

 
private 
readonly 
string 
pathFileCode  ,
;, -
private 
string 
code 
; 
public 

FileWriter 
( 
) 
{ 	
code 
= 
String 
. 
Empty 
;  
pathFileCode 
= 
Path 
.  
Combine  '
(' (
Environment( 3
.3 4
CurrentDirectory4 D
,D E
$strF P
)P Q
;Q R
} 	
public 
void 
InitFile 
( 
) 
{ 	
code 
+= 
$str 
+ 
$str #
;# $
} 	
public$$ 
void$$ 
WriteCommand$$  
($$  !
string$$! '
cmd$$( +
,$$+ ,
bool$$- 1
debug$$2 7
=$$8 9
false$$: ?
)$$? @
{%% 	
code&& 
+=&& 
cmd&& 
+&& 
$str&& 
;&& 
if'' 
('' 
debug'' 
)'' 
code(( 
+=(( 
$str(( 
;((  
})) 	
public.. 
void.. 
	WriteFile.. 
(.. 
).. 
{// 	
try00 
{11 
code22 
+=22 
$str22 
;22  
code33 
+=33 
$str33 
;33 
if44 
(44 
File44 
.44 
Exists44 
(44  
pathFileCode44  ,
)44, -
)44- .
File55 
.55 
Delete55 
(55  
pathFileCode55  ,
)55, -
;55- .
Console77 
.77 
	WriteLine77 !
(77! "
)77" #
;77# $
Console88 
.88 
	WriteLine88 !
(88! "
code88" &
)88& '
;88' (
File:: 
.:: 
WriteAllText:: !
(::! "
pathFileCode::" .
,::. /
code::0 4
)::4 5
;::5 6
};; 
catch<< 
(<< 
	Exception<< 
e<< 
)<< 
{== 
Console>> 
.>> 
	WriteLine>> !
(>>! "
e>>" #
.>># $
Message>>$ +
)>>+ ,
;>>, -
Console?? 
.?? 
	WriteLine?? !
(??! "
e??" #
.??# $

StackTrace??$ .
)??. /
;??/ 0
}@@ 
}AA 	
}BB 
}CC Ã
:F:\Documents\GITrepos\Compil\Compil\Compil\Tokens\Token.cs
	namespace 	
Compil
 
{ 
public		 

class		 
Token		 
{

 
public 
string 
Name 
{ 
get  
;  !
set" %
;% &
}' (
public 
int 
Value 
{ 
get 
; 
set  #
;# $
}% &
public 
int 
Line 
{ 
get 
; 
set "
;" #
}$ %
public 
int 
Column 
{ 
get 
;  
set! $
;$ %
}& '
public 
	TokenType 
Type 
{ 
get  #
;# $
set% (
;( )
}* +
} 
} ◊
>F:\Documents\GITrepos\Compil\Compil\Compil\Tokens\TokenType.cs
	namespace 	
Compil
 
. 
Tokens 
{ 
public 

enum 
	TokenType 
{ 

IDENTIFIER 
, 
CONSTANT 
, 
END_OF_FILE		 
,		 
NOT 
, 
PLUS 
, 
MINUS 
, 
MULTIPLY 
, 
DIVIDE 
, 
MODULO 
, 
POWER 
, 
IF 

,
 
ELSE 
, 
FOR 
, 
WHILE 
, 
DO 

,
 
SWITCH 
, 
CASE 
, 
INT 
, 
VOID 
, 

COMP_EQUAL 
, 
COMP_DIFFERENT 
, 
COMP_SUPPERIOR   
,   
COMP_INFERIOR!! 
,!! #
COMP_SUPPERIOR_OR_EQUAL"" 
,""  "
COMP_INFERIOR_OR_EQUAL## 
,## 
PAR_OPEN%% 
,%% 
	PAR_CLOSE&& 
,&& 
OR(( 

,((
 
AND)) 
,)) 
EQUAL++ 
,++ 
BRACKET_OPEN.. 
,.. 
BRACKET_CLOSE// 
,// 
	SEMICOLON11 
,11 
COMA22 
,22 
COMMENT_LINE33 
,33 
COMMENT_BLOCK_START44 
,44 
COMMENT_BLOCK_END55 
}66 
}77 ·
<F:\Documents\GITrepos\Compil\Compil\Compil\Utils\Operator.cs
	namespace 	
Compil
 
. 
Utils 
{ 
public 

class 
Operator 
{ 
public 
Token 
Token 
{ 
get  
;  !
set" %
;% &
}' (
public 
Node 
Node 
{ 
get 
; 
set  #
;# $
}% &
public 
int 
Priority 
{ 
get !
;! "
set# &
;& '
}( )
public 
int 
Association 
{  
get! $
;$ %
set& )
;) *
}+ ,
}		 
}

 