‰k
EF:\Documents\GITrepos\Compil\Compil\Compil\Analyzer\SyntaxAnalyzer.cs
	namespace		 	
Compil		
 
{

 
class 	
SyntaxAnalyzer
 
{ 
private 
readonly 
LexicalAnalyzer (
_lexicalAnalyzer) 9
;9 :
private 
readonly 

Dictionary #
<# $
	TokenType$ -
,- .
(/ 0
NodeType0 8
,8 9
string: @
,@ A
intB E
,E F
intG J
)J K
>K L!
_exprTokenToNodeMatchM b
=c d
newe h

Dictionaryi s
<s t
	TokenTypet }
,} ~
(	 Ä
NodeType
Ä à
,
à â
string
ä ê
,
ê ë
int
í ï
,
ï ñ
int
ó ö
)
ö õ
>
õ ú
(
ú ù
)
ù û
{ 	
{ 
	TokenType 
. 
OR 
, 
( 
NodeType $
.$ %
OR% '
,' (
$str) ,
,, -
$num. /
,/ 0
$num1 2
)2 3
}3 4
,4 5
{ 
	TokenType 
. 
AND 
, 
( 
NodeType %
.% &
AND& )
,) *
$str+ .
,. /
$num0 1
,1 2
$num3 4
)4 5
}5 6
,6 7
{ 
	TokenType 
. 
NOT 
, 
( 
NodeType %
.% &
NOT& )
,) *
$str+ .
,. /
$num0 1
,1 2
$num3 4
)4 5
}5 6
,6 7
{ 
	TokenType 
. 

COMP_EQUAL !
,! "
(# $
NodeType$ ,
., -

COMP_EQUAL- 7
,7 8
$str9 =
,= >
$num? @
,@ A
$numB C
)C D
}D E
,E F
{ 
	TokenType 
. 
PLUS 
, 
( 
NodeType &
.& '
OP_PLUS' .
,. /
$str0 3
,3 4
$num5 6
,6 7
$num8 9
)9 :
}: ;
,; <
{ 
	TokenType 
. 
MINUS 
, 
( 
NodeType '
.' (
OP_MINUS( 0
,0 1
$str2 5
,5 6
$num7 8
,8 9
$num: ;
); <
}< =
,= >
{ 
	TokenType 
. 
POWER 
, 
( 
NodeType '
.' (
OP_POWER( 0
,0 1
$str2 5
,5 6
$num7 8
,8 9
$num: ;
); <
}< =
,= >
{ 
	TokenType 
. 
DIVIDE 
, 
(  
NodeType  (
.( )
	OP_DIVIDE) 2
,2 3
$str4 7
,7 8
$num9 :
,: ;
$num< =
)= >
}> ?
,? @
{ 
	TokenType 
. 
MODULO 
, 
(  
NodeType  (
.( )
	OP_MODULO) 2
,2 3
$str4 7
,7 8
$num9 :
,: ;
$num< =
)= >
}> ?
,? @
{ 
	TokenType 
. 
MULTIPLY 
,  
(! "
NodeType" *
.* +
OP_MULTIPLY+ 6
,6 7
$str8 ;
,; <
$num= >
,> ?
$num@ A
)A B
}B C
,C D
{ 
	TokenType 
. 
COMP_INFERIOR $
,$ %
(& '
NodeType' /
./ 0
COMP_INFERIOR0 =
,= >
$str? B
,B C
$numD E
,E F
$numG H
)H I
}I J
,J K
{ 
	TokenType 
. 
COMP_DIFFERENT %
,% &
(' (
NodeType( 0
.0 1
COMP_DIFFERENT1 ?
,? @
$strA E
,E F
$numG H
,H I
$numJ K
)K L
}L M
,M N
{   
	TokenType   
.   
COMP_SUPPERIOR   %
,  % &
(  ' (
NodeType  ( 0
.  0 1
COMP_SUPPERIOR  1 ?
,  ? @
$str  A D
,  D E
$num  F G
,  G H
$num  I J
)  J K
}  K L
,  L M
{!! 
	TokenType!! 
.!! "
COMP_INFERIOR_OR_EQUAL!! -
,!!- .
(!!/ 0
NodeType!!0 8
.!!8 9"
COMP_INFERIOR_OR_EQUAL!!9 O
,!!O P
$str!!Q U
,!!U V
$num!!W X
,!!X Y
$num!!Z [
)!![ \
}!!\ ]
,!!] ^
{"" 
	TokenType"" 
."" #
COMP_SUPPERIOR_OR_EQUAL"" .
,"". /
(""0 1
NodeType""1 9
.""9 :#
COMP_SUPPERIOR_OR_EQUAL"": Q
,""Q R
$str""S W
,""W X
$num""Y Z
,""Z [
$num""\ ]
)""] ^
}""^ _
,""_ `
}## 	
;##	 

public)) 
SyntaxAnalyzer)) 
()) 
LexicalAnalyzer)) -
lexicalAnalyser)). =
)))= >
{** 	
this++ 
.++ 
_lexicalAnalyzer++ !
=++" #
lexicalAnalyser++$ 3
;++3 4
},, 	
public11 
Node11 
Primary11 
(11 
)11 
{22 	
try33 
{44 
Node55 
node55 
;55 
if88 
(88 
_lexicalAnalyzer88 $
.88$ %
Next88% )
(88) *
)88* +
.88+ ,
Type88, 0
==881 3
	TokenType884 =
.88= >
CONSTANT88> F
)88F G
{99 
node:: 
=:: 
new:: 
Node:: #
(::# $
)::$ %
{::& '
Type::' +
=::, -
NodeType::. 6
.::6 7
CONSTANT::7 ?
,::? @
Value::A F
=::G H
_lexicalAnalyzer::I Y
.::Y Z
Next::Z ^
(::^ _
)::_ `
.::` a
Value::a f
.::f g
ToString::g o
(::o p
)::p q
}::q r
;::r s
_lexicalAnalyzer;; $
.;;$ %
Skip;;% )
(;;) *
);;* +
;;;+ ,
return<< 
node<< 
;<<  
}== 
if@@ 
(@@ 
_lexicalAnalyzer@@ $
.@@$ %
Next@@% )
(@@) *
)@@* +
.@@+ ,
Type@@, 0
==@@1 3
	TokenType@@4 =
.@@= >
PAR_OPEN@@> F
)@@F G
{AA 
_lexicalAnalyzerBB $
.BB$ %
SkipBB% )
(BB) *
)BB* +
;BB+ ,
nodeCC 
=CC 

ExpressionCC %
(CC% &
$numCC& '
)CC' (
;CC( )
_lexicalAnalyzerDD $
.DD$ %
AcceptDD% +
(DD+ ,
	TokenTypeDD, 5
.DD5 6
	PAR_CLOSEDD6 ?
)DD? @
;DD@ A
returnEE 
nodeEE 
;EE  
}FF 
ifHH 
(HH 
_lexicalAnalyzerHH $
.HH$ %
NextHH% )
(HH) *
)HH* +
.HH+ ,
TypeHH, 0
==HH1 3
	TokenTypeHH4 =
.HH= >
MINUSHH> C
||HHD F
_lexicalAnalyzerII $
.II$ %
NextII% )
(II) *
)II* +
.II+ ,
TypeII, 0
==II1 3
	TokenTypeII4 =
.II= >
PLUSII> B
||IIC E
_lexicalAnalyzerJJ $
.JJ$ %
NextJJ% )
(JJ) *
)JJ* +
.JJ+ ,
TypeJJ, 0
==JJ1 3
	TokenTypeJJ4 =
.JJ= >
NOTJJ> A
)JJA B
{KK 
varLL 
(LL 
nodetypeLL !
,LL! "
valLL# &
,LL& '
priorityLL( 0
,LL0 1
assosLL2 7
)LL7 8
=LL9 :!
_exprTokenToNodeMatchLL; P
[LLP Q
_lexicalAnalyzerLLQ a
.LLa b
NextLLb f
(LLf g
)LLg h
.LLh i
TypeLLi m
]LLm n
;LLn o
nodeMM 
=MM 
newMM 
NodeMM #
(MM# $
)MM$ %
{MM& '
TypeMM' +
=MM, -
nodetypeMM. 6
,MM6 7
ValueMM8 =
=MM> ?
valMM@ C
}MMC D
;MMD E
_lexicalAnalyzerNN $
.NN$ %
SkipNN% )
(NN) *
)NN* +
;NN+ ,
nodeOO 
.OO 
AddChildOO !
(OO! "

ExpressionOO" ,
(OO, -
$numOO- .
)OO. /
)OO/ 0
;OO0 1
returnPP 
nodePP 
;PP  
}QQ 
throwTT 
newTT !
ArgumentNullExceptionTT /
(TT/ 0
$strTT0 C
)TTC D
;TTD E
}UU 
catchVV 
(VV #
NotImplementedExceptionVV *
eVV+ ,
)VV, -
{WW 
ConsoleXX 
.XX 
	WriteLineXX !
(XX! "
eXX" #
.XX# $

StackTraceXX$ .
)XX. /
;XX/ 0
returnYY 
nullYY 
;YY 
}ZZ 
catch[[ 
([[ !
ArgumentNullException[[ (
e[[) *
)[[* +
{\\ 
Console]] 
.]] 
	WriteLine]] !
(]]! "
e]]" #
.]]# $

StackTrace]]$ .
)]]. /
;]]/ 0
return^^ 
null^^ 
;^^ 
}__ 
}`` 	
publicgg 
Nodegg 

Expressiongg 
(gg 
intgg "
pMingg# '
)gg' (
{hh 	
varii 
leftNodeii 
=ii 
Primaryii "
(ii" #
)ii# $
;ii$ %
whilekk 
(kk 
truekk 
)kk 
{kk 
ifll 
(ll 
_lexicalAnalyzerll $
.ll$ %
Nextll% )
(ll) *
)ll* +
==ll, .
nullll/ 3
)ll3 4
returnmm 
leftNodemm #
;mm# $
varoo 
opoo 
=oo 
SearchOpoo !
(oo! "
_lexicalAnalyzeroo" 2
.oo2 3
Nextoo3 7
(oo7 8
)oo8 9
)oo9 :
;oo: ;
ifqq 
(qq 
opqq 
==qq 
nullqq 
||qq !
opqq" $
.qq$ %
Priorityqq% -
<qq. /
pMinqq0 4
)qq4 5
returnrr 
leftNoderr #
;rr# $
_lexicalAnalyzertt  
.tt  !
Skiptt! %
(tt% &
)tt& '
;tt' (
varuu 
	rightNodeuu 
=uu 

Expressionuu  *
(uu* +
opuu+ -
.uu- .
Priorityuu. 6
+uu7 8
opuu9 ;
.uu; <
Associationuu< G
)uuG H
;uuH I
varvv 
treevv 
=vv 
newvv 
Nodevv #
(vv# $
)vv$ %
{vv& '
Typevv( ,
=vv- .
opvv/ 1
.vv1 2
Nodevv2 6
.vv6 7
Typevv7 ;
}vv< =
;vv= >
treeww 
.ww 
AddChildww 
(ww 
leftNodeww &
)ww& '
;ww' (
treexx 
.xx 
AddChildxx 
(xx 
	rightNodexx '
)xx' (
;xx( )
leftNodeyy 
=yy 
treeyy 
;yy  
}zz 
}{{ 	
public
ÇÇ 
Operator
ÇÇ 
SearchOp
ÇÇ  
(
ÇÇ  !
Token
ÇÇ! &
token
ÇÇ' ,
)
ÇÇ, -
{
ÉÉ 	
if
ÑÑ 
(
ÑÑ #
_exprTokenToNodeMatch
ÑÑ %
.
ÑÑ% &
TryGetValue
ÑÑ& 1
(
ÑÑ1 2
token
ÑÑ2 7
.
ÑÑ7 8
Type
ÑÑ8 <
,
ÑÑ< =
out
ÑÑ> A
var
ÑÑB E
vals
ÑÑF J
)
ÑÑJ K
)
ÑÑK L
{
ÑÑM N
var
ÖÖ 
(
ÖÖ 
nodetype
ÖÖ 
,
ÖÖ 
val
ÖÖ "
,
ÖÖ" #
priority
ÖÖ$ ,
,
ÖÖ, -
assos
ÖÖ. 3
)
ÖÖ3 4
=
ÖÖ5 6
vals
ÖÖ7 ;
;
ÖÖ; <
return
ÜÜ 
new
ÜÜ 
Operator
ÜÜ #
(
ÜÜ# $
)
ÜÜ$ %
{
ÜÜ& '
Token
ÜÜ( -
=
ÜÜ. /
token
ÜÜ0 5
,
ÜÜ5 6
Node
ÜÜ7 ;
=
ÜÜ< =
new
ÜÜ> A
Node
ÜÜB F
(
ÜÜF G
)
ÜÜG H
{
ÜÜI J
Type
ÜÜJ N
=
ÜÜO P
nodetype
ÜÜQ Y
}
ÜÜY Z
,
ÜÜZ [
Priority
ÜÜ\ d
=
ÜÜe f
priority
ÜÜg o
,
ÜÜo p
Association
ÜÜq |
=
ÜÜ} ~
assosÜÜ Ñ
}ÜÜÑ Ö
;ÜÜÖ Ü
}
áá 
return
àà 
null
àà 
;
àà 
}
ââ 	
}
ãã 
}åå Å
NF:\Documents\GITrepos\Compil\Compil\Compil\Exceptions\NotValidCharException.cs
	namespace 	
Compil
 
. 

Exceptions 
{ 
class 	!
NotValidCharException
 
{ 
public !
NotValidCharException $
($ %
)% &
{ 	
} 	
} 
} ‡
:F:\Documents\GITrepos\Compil\Compil\Compil\Objects\Node.cs
	namespace 	
Compil
 
{		 
public 

class 
Node 
{ 
public 
NodeType 
Type 
{ 
get "
;" #
set$ '
;' (
}) *
public 
string 
Value 
{ 
get !
;! "
set# &
;& '
}( )
public 
List 
< 
Node 
> 
Children "
{# $
get% (
;( )
set* -
;- .
}/ 0
=1 2
new3 6
List7 ;
<; <
Node< @
>@ A
(A B
)B C
;C D
public 
void 
AddChild 
( 
Node !
node" &
)& '
{ 	
Children 
. 
Add 
( 
node 
) 
; 
} 	
public 
void 
AddChildren 
(  
List  $
<$ %
Node% )
>) *
nodes+ 0
)0 1
{ 	
foreach 
( 
var 
node 
in  
nodes! &
)& '
Children   
.   
Add   
(   
node   !
)  ! "
;  " #
}!! 	
public## 
void## 
Print## 
(## 
string##  
indent##! '
,##' (
bool##) -
last##. 2
)##2 3
{$$ 	
Console%% 
.%% 
Write%% 
(%% 
indent%%  
)%%  !
;%%! "
if&& 
(&& 
last&& 
)&& 
{'' 
Console(( 
.(( 
Write(( 
((( 
$str(( #
)((# $
;(($ %
indent)) 
+=)) 
$str)) 
;)) 
}** 
else++ 
{,, 
Console-- 
.-- 
Write-- 
(-- 
$str-- "
)--" #
;--# $
indent.. 
+=.. 
$str.. 
;.. 
}// 
if00 
(00 
Type00 
==00 
NodeType00 
.00  
CONSTANT00  (
)00( )
Console22 
.22 
	WriteLine22 !
(22! "
$str22" +
+22, -
Value22. 3
)223 4
;224 5
else33 
Console55 
.55 
	WriteLine55 !
(55! "
Type55" &
)55& '
;55' (
for77 
(77 
var77 
i77 
=77 
$num77 
;77 
i77 
<77 
Children77  (
.77( )
Count77) .
;77. /
i770 1
++771 3
)773 4
Children88 
[88 
i88 
]88 
.88 
Print88 !
(88! "
indent88" (
,88( )
i88* +
==88, .
Children88/ 7
.887 8
Count888 =
-88> ?
$num88@ A
)88A B
;88B C
}99 	
}== 
}>> ˇÜ
FF:\Documents\GITrepos\Compil\Compil\Compil\Analyzer\LexicalAnalyzer.cs
	namespace 	
Compil
 
{		 
class

 	
LexicalAnalyzer


 
{ 
private 
readonly 
string 
code  $
;$ %
public 
int 
index 
; 
public 

Dictionary 
< 
string  
,  !
	TokenType" +
>+ ,
keywords- 5
=6 7
new8 ;

Dictionary< F
<F G
stringG M
,M N
	TokenTypeO X
>X Y
(Y Z
)Z [
{ 	
{ 
$str 
, 
	TokenType 
. 
IF 
}  
,  !
{ 
$str 
, 
	TokenType 
. 
ELSE #
}# $
,$ %
{ 
$str 
, 
	TokenType 
. 
FOR !
}! "
," #
{ 
$str 
, 
	TokenType 
.  
WHILE  %
}% &
,& '
{ 
$str 
, 
	TokenType 
. 
DO 
}  
,  !
{ 
$str 
, 
	TokenType  
.  !
SWITCH! '
}' (
,( )
{ 
$str 
, 
	TokenType 
. 
CASE #
}# $
,$ %
{ 
$str 
, 
	TokenType 
. 
INT !
}! "
," #
{ 
$str 
, 
	TokenType 
. 
VOID #
}# $
} 	
;	 

private 
Token 
_currentNextToken '
;' (
private 
int 
_currentTokenLength '
=( )
$num* +
;+ ,
public%% 
LexicalAnalyzer%% 
(%% 
string%% %
code%%& *
,%%* +
int%%, /
index%%0 5
)%%5 6
{&& 	
this'' 
.'' 
code'' 
='' 
code'' 
;'' 
this(( 
.(( 
index(( 
=(( 
index(( 
;(( 
})) 	
public00 
Token00 
Next00 
(00 
)00 
{11 	
if22 
(22 
_currentNextToken22 !
!=22" $
null22% )
)22) *
{33 
return44 
_currentNextToken44 (
;44( )
}55 
var77 
result77 
=77 

DetectNext77 #
(77# $
)77$ %
;77% &
_currentNextToken88 
=88 
result88  &
;88& '
return99 
result99 
;99 
}:: 	
public?? 
void?? 
Skip?? 
(?? 
)?? 
{@@ 	
indexAA 
+=AA 
_currentTokenLengthAA (
;AA( )
_currentTokenLengthBB 
=BB  !
$numBB" #
;BB# $
_currentNextTokenCC 
=CC 
nullCC  $
;CC$ %
}DD 	
publicJJ 
voidJJ 
AcceptJJ 
(JJ 
	TokenTypeJJ $
typeJJ% )
)JJ) *
{KK 	
tryLL 
{MM 
ifNN 
(NN 
NextNN 
(NN 
)NN 
.NN 
TypeNN 
!=NN  "
typeNN# '
)NN' (
{OO 
throwPP 
newPP !
ArgumentNullExceptionPP 3
(PP3 4
$"PP4 6
Bad token: 'PP6 B
{PPB C
typePPC G
.PPG H
ToStringPPH P
(PPP Q
)PPQ R
}PPR S
' expected.PPS ^
"PP^ _
)PP_ `
;PP` a
}QQ 
SkipSS 
(SS 
)SS 
;SS 
}TT 
catchUU 
(UU !
ArgumentNullExceptionUU (
eUU) *
)UU* +
{VV 
ConsoleWW 
.WW 
	WriteLineWW !
(WW! "
eWW" #
.WW# $
MessageWW$ +
)WW+ ,
;WW, -
}XX 
}YY 	
private`` 
Token`` 

DetectNext``  
(``  !
)``! "
{aa 	
ifbb 
(bb 
indexbb 
==bb 
codebb 
.bb 
Lengthbb $
)bb$ %
{cc 
returndd 
newdd 
Tokendd  
(dd  !
)dd! "
{dd# $
Typedd$ (
=dd) *
	TokenTypedd+ 4
.dd4 5
END_OF_FILEdd5 @
}dd@ A
;ddA B
}ee 
whilegg 
(gg 
codegg 
[gg 
indexgg 
]gg 
==gg !
$chargg" %
||gg& (
codegg) -
[gg- .
indexgg. 3
]gg3 4
==gg5 7
$chargg8 <
||gg= ?
codegg@ D
[ggD E
indexggE J
]ggJ K
==ggL N
$charggO S
)ggS T
{hh 
indexii 
++ii 
;ii 
}jj 
ifmm 
(mm 
charmm 
.mm 
IsDigitmm 
(mm 
codemm !
[mm! "
indexmm" '
]mm' (
)mm( )
)mm) *
{nn 
_currentTokenLengthoo #
=oo$ %
$numoo& '
;oo' (
varpp 
bufferpp 
=pp 
codepp !
[pp! "
indexpp" '
]pp' (
.pp( )
ToStringpp) 1
(pp1 2
)pp2 3
;pp3 4
ifrr 
(rr 
indexrr 
==rr 
coderr !
.rr! "
Lengthrr" (
-rr) *
$numrr+ ,
)rr, -
{ss 
returntt 
newtt 
Tokentt $
(tt$ %
)tt% &
{tt' (
Typett( ,
=tt- .
	TokenTypett/ 8
.tt8 9
CONSTANTtt9 A
,ttA B
ValuettC H
=ttI J
intttK N
.ttN O
ParsettO T
(ttT U
bufferttU [
)tt[ \
}tt\ ]
;tt] ^
}uu 
varww 
iww 
=ww 
indexww 
+ww 
$numww  !
;ww! "
whilexx 
(xx 
charxx 
.xx 
IsDigitxx #
(xx# $
codexx$ (
[xx( )
ixx) *
]xx* +
)xx+ ,
)xx, -
{yy 
bufferzz 
+=zz 
codezz "
[zz" #
izz# $
]zz$ %
.zz% &
ToStringzz& .
(zz. /
)zz/ 0
;zz0 1
i{{ 
++{{ 
;{{ 
_currentTokenLength|| '
++||' )
;||) *
}}} 
return 
new 
Token  
(  !
)! "
{# $
Type$ (
=) *
	TokenType+ 4
.4 5
CONSTANT5 =
,= >
Value? D
=E F
intG J
.J K
ParseK P
(P Q
bufferQ W
)W X
}X Y
;Y Z
}
ÄÄ 
if
ÉÉ 
(
ÉÉ 
char
ÉÉ 
.
ÉÉ 
IsLetter
ÉÉ 
(
ÉÉ 
code
ÉÉ "
[
ÉÉ" #
index
ÉÉ# (
]
ÉÉ( )
)
ÉÉ) *
)
ÉÉ* +
{
ÑÑ !
_currentTokenLength
ÖÖ #
=
ÖÖ$ %
$num
ÖÖ& '
;
ÖÖ' (
var
ÜÜ 
buffer
ÜÜ 
=
ÜÜ 
code
ÜÜ !
[
ÜÜ! "
index
ÜÜ" '
]
ÜÜ' (
.
ÜÜ( )
ToString
ÜÜ) 1
(
ÜÜ1 2
)
ÜÜ2 3
;
ÜÜ3 4
if
àà 
(
àà 
index
àà 
==
àà 
code
àà !
.
àà! "
Length
àà" (
-
àà) *
$num
àà+ ,
)
àà, -
{
ââ 
if
ãã 
(
ãã 
keywords
ãã  
.
ãã  !
ContainsKey
ãã! ,
(
ãã, -
buffer
ãã- 3
)
ãã3 4
)
ãã4 5
{
åå 
return
çç 
new
çç "
Token
çç# (
(
çç( )
)
çç) *
{
çç+ ,
Type
çç, 0
=
çç1 2
keywords
çç3 ;
[
çç; <
buffer
çç< B
]
ççB C
,
ççC D
Name
ççE I
=
ççJ K
buffer
ççL R
}
ççR S
;
ççS T
}
éé 
return
êê 
new
êê 
Token
êê $
(
êê$ %
)
êê% &
{
êê' (
Type
êê( ,
=
êê- .
	TokenType
êê/ 8
.
êê8 9

IDENTIFIER
êê9 C
,
êêC D
Name
êêE I
=
êêJ K
buffer
êêL R
}
êêR S
;
êêS T
}
ëë 
var
ìì 
i
ìì 
=
ìì 
index
ìì 
+
ìì 
$num
ìì  !
;
ìì! "
while
îî 
(
îî 
char
îî 
.
îî 
IsLetter
îî $
(
îî$ %
code
îî% )
[
îî) *
i
îî* +
]
îî+ ,
)
îî, -
||
îî. 0
char
îî1 5
.
îî5 6
IsDigit
îî6 =
(
îî= >
code
îî> B
[
îîB C
i
îîC D
]
îîD E
)
îîE F
)
îîF G
{
ïï 
buffer
ññ 
+=
ññ 
code
ññ "
[
ññ" #
i
ññ# $
]
ññ$ %
.
ññ% &
ToString
ññ& .
(
ññ. /
)
ññ/ 0
;
ññ0 1
i
óó 
++
óó 
;
óó !
_currentTokenLength
òò '
++
òò' )
;
òò) *
}
ôô 
if
úú 
(
úú 
keywords
úú 
.
úú 
ContainsKey
úú (
(
úú( )
buffer
úú) /
)
úú/ 0
)
úú0 1
{
ùù 
return
ûû 
new
ûû 
Token
ûû $
(
ûû$ %
)
ûû% &
{
ûû' (
Type
ûû( ,
=
ûû- .
keywords
ûû/ 7
[
ûû7 8
buffer
ûû8 >
]
ûû> ?
,
ûû? @
Name
ûûA E
=
ûûF G
buffer
ûûH N
}
ûûN O
;
ûûO P
}
üü 
return
°° 
new
°° 
Token
°°  
(
°°  !
)
°°! "
{
°°# $
Type
°°$ (
=
°°) *
	TokenType
°°+ 4
.
°°4 5

IDENTIFIER
°°5 ?
,
°°? @
Name
°°A E
=
°°F G
buffer
°°H N
}
°°N O
;
°°O P
}
¢¢ 
if
•• 
(
•• 
code
•• 
[
•• 
index
•• 
]
•• 
==
•• 
$char
•• "
)
••" #
{
¶¶ !
_currentTokenLength
ßß #
=
ßß$ %
$num
ßß& '
;
ßß' (
var
®® 
buffer
®® 
=
®® 
code
®® !
[
®®! "
index
®®" '
]
®®' (
.
®®( )
ToString
®®) 1
(
®®1 2
)
®®2 3
;
®®3 4
if
™™ 
(
™™ 
index
™™ 
==
™™ 
code
™™ !
.
™™! "
Length
™™" (
-
™™) *
$num
™™+ ,
)
™™, -
{
´´ 
return
¨¨ 
new
¨¨ 
Token
¨¨ $
(
¨¨$ %
)
¨¨% &
{
¨¨' (
Type
¨¨( ,
=
¨¨- .
	TokenType
¨¨/ 8
.
¨¨8 9
EQUAL
¨¨9 >
}
¨¨> ?
;
¨¨? @
}
≠≠ 
if
ØØ 
(
ØØ 
code
ØØ 
[
ØØ 
index
ØØ 
+
ØØ  
$num
ØØ! "
]
ØØ" #
==
ØØ$ &
$char
ØØ' *
)
ØØ* +
{
∞∞ !
_currentTokenLength
±± '
++
±±' )
;
±±) *
return
≤≤ 
new
≤≤ 
Token
≤≤ $
(
≤≤$ %
)
≤≤% &
{
≤≤' (
Type
≤≤( ,
=
≤≤- .
	TokenType
≤≤/ 8
.
≤≤8 9

COMP_EQUAL
≤≤9 C
}
≤≤C D
;
≤≤D E
}
≥≥ 
return
µµ 
new
µµ 
Token
µµ  
(
µµ  !
)
µµ! "
{
µµ# $
Type
µµ$ (
=
µµ) *
	TokenType
µµ+ 4
.
µµ4 5
EQUAL
µµ5 :
}
µµ: ;
;
µµ; <
}
∂∂ !
_currentTokenLength
∏∏ 
++
∏∏ !
;
∏∏! "
switch
ππ 
(
ππ 
code
ππ 
[
ππ 
index
ππ 
]
ππ 
)
ππ  
{
∫∫ 
case
ªª 
$char
ªª 
:
ªª 
return
ºº 
new
ºº 
Token
ºº $
(
ºº$ %
)
ºº% &
{
ºº' (
Type
ºº( ,
=
ºº- .
	TokenType
ºº/ 8
.
ºº8 9
PLUS
ºº9 =
}
ºº= >
;
ºº> ?
case
ΩΩ 
$char
ΩΩ 
:
ΩΩ 
return
ææ 
new
ææ 
Token
ææ $
(
ææ$ %
)
ææ% &
{
ææ' (
Type
ææ( ,
=
ææ- .
	TokenType
ææ/ 8
.
ææ8 9
MINUS
ææ9 >
}
ææ> ?
;
ææ? @
case
øø 
$char
øø 
:
øø 
return
¿¿ 
new
¿¿ 
Token
¿¿ $
(
¿¿$ %
)
¿¿% &
{
¿¿' (
Type
¿¿( ,
=
¿¿- .
	TokenType
¿¿/ 8
.
¿¿8 9
MULTIPLY
¿¿9 A
}
¿¿A B
;
¿¿B C
case
¡¡ 
$char
¡¡ 
:
¡¡ 
return
¬¬ 
new
¬¬ 
Token
¬¬ $
(
¬¬$ %
)
¬¬% &
{
¬¬' (
Type
¬¬( ,
=
¬¬- .
	TokenType
¬¬/ 8
.
¬¬8 9
DIVIDE
¬¬9 ?
}
¬¬? @
;
¬¬@ A
case
√√ 
$char
√√ 
:
√√ 
return
ƒƒ 
new
ƒƒ 
Token
ƒƒ $
(
ƒƒ$ %
)
ƒƒ% &
{
ƒƒ' (
Type
ƒƒ( ,
=
ƒƒ- .
	TokenType
ƒƒ/ 8
.
ƒƒ8 9
MODULO
ƒƒ9 ?
}
ƒƒ? @
;
ƒƒ@ A
case
≈≈ 
$char
≈≈ 
:
≈≈ 
return
∆∆ 
new
∆∆ 
Token
∆∆ $
(
∆∆$ %
)
∆∆% &
{
∆∆' (
Type
∆∆( ,
=
∆∆- .
	TokenType
∆∆/ 8
.
∆∆8 9
POWER
∆∆9 >
}
∆∆> ?
;
∆∆? @
case
«« 
$char
«« 
:
«« 
return
»» 
new
»» 
Token
»» $
(
»»$ %
)
»»% &
{
»»' (
Type
»»( ,
=
»»- .
	TokenType
»»/ 8
.
»»8 9
PAR_OPEN
»»9 A
}
»»A B
;
»»B C
case
…… 
$char
…… 
:
…… 
return
   
new
   
Token
   $
(
  $ %
)
  % &
{
  ' (
Type
  ( ,
=
  - .
	TokenType
  / 8
.
  8 9
	PAR_CLOSE
  9 B
}
  B C
;
  C D
case
ÀÀ 
$char
ÀÀ 
:
ÀÀ 
return
ÃÃ 
new
ÃÃ 
Token
ÃÃ $
(
ÃÃ$ %
)
ÃÃ% &
{
ÃÃ' (
Type
ÃÃ( ,
=
ÃÃ- .
	TokenType
ÃÃ/ 8
.
ÃÃ8 9
BRACKET_OPEN
ÃÃ9 E
}
ÃÃE F
;
ÃÃF G
case
ÕÕ 
$char
ÕÕ 
:
ÕÕ 
return
ŒŒ 
new
ŒŒ 
Token
ŒŒ $
(
ŒŒ$ %
)
ŒŒ% &
{
ŒŒ' (
Type
ŒŒ( ,
=
ŒŒ- .
	TokenType
ŒŒ/ 8
.
ŒŒ8 9
BRACKET_CLOSE
ŒŒ9 F
}
ŒŒF G
;
ŒŒG H
case
œœ 
$char
œœ 
:
œœ 
return
–– 
new
–– 
Token
–– $
(
––$ %
)
––% &
{
––' (
Type
––( ,
=
––- .
	TokenType
––/ 8
.
––8 9
AND
––9 <
}
––< =
;
––= >
case
—— 
$char
—— 
:
—— 
return
““ 
new
““ 
Token
““ $
(
““$ %
)
““% &
{
““' (
Type
““( ,
=
““- .
	TokenType
““/ 8
.
““8 9
OR
““9 ;
}
““; <
;
““< =
case
”” 
$char
”” 
:
”” 
return
‘‘ 
new
‘‘ 
Token
‘‘ $
(
‘‘$ %
)
‘‘% &
{
‘‘' (
Type
‘‘( ,
=
‘‘- .
	TokenType
‘‘/ 8
.
‘‘8 9
	SEMICOLON
‘‘9 B
}
‘‘B C
;
‘‘C D
default
’’ 
:
’’ 
break
÷÷ 
;
÷÷ 
}
◊◊ 
throw
ŸŸ 
new
ŸŸ %
NotImplementedException
ŸŸ -
(
ŸŸ- .
)
ŸŸ. /
;
ŸŸ/ 0
}
⁄⁄ 	
}
€€ 
}‹‹ Ö
5F:\Documents\GITrepos\Compil\Compil\Compil\Program.cs
	namespace

 	
Compil


 
{

 
class 	
Program
 
{ 
static 
void 
Main 
( 
string 
[  
]  !
args" &
)& '
{( )
try 
{ 
Console 
. 
	WriteLine !
(! "
$str" 3
+4 5
args6 :
[: ;
args; ?
.? @
Length@ F
-G H
$numI J
]J K
)K L
;L M
string 
pathFile 
=  !
Path" &
.& '
Combine' .
(. /
args/ 3
[3 4
args4 8
.8 9
Length9 ?
-@ A
$numB C
]C D
)D E
;E F
string 
codeTemp 
=  !
File" &
.& '
ReadAllText' 2
(2 3
pathFile3 ;
); <
;< =
Console 
. 
	WriteLine !
(! "
$str" 3
)3 4
;4 5
Console 
. 
	WriteLine !
(! "
codeTemp" *
)* +
;+ ,
Console 
. 
	WriteLine !
(! "
$str" :
): ;
;; <
Console 
. 
ReadKey 
(  
)  !
;! "
Console 
. 
	WriteLine !
(! "
)" #
;# $
var 
lexicalAnalyser #
=$ %
new& )
LexicalAnalyzer* 9
(9 :
codeTemp: B
,B C
$numD E
)E F
;F G
var 
syntaxAnalyzer "
=# $
new% (
SyntaxAnalyzer) 7
(7 8
lexicalAnalyser8 G
)G H
;H I
var!! 
node!! 
=!! 
syntaxAnalyzer!! )
.!!) *

Expression!!* 4
(!!4 5
$num!!5 6
)!!6 7
;!!7 8
node"" 
."" 
Print"" 
("" 
$str"" 
,"" 
false"" $
)""$ %
;""% &
Console$$ 
.$$ 
	WriteLine$$ !
($$! "
)$$" #
;$$# $
Console'' 
.'' 
	WriteLine'' !
(''! "
$str''" 8
)''8 9
;''9 :
Console(( 
.(( 
ReadKey(( 
(((  
)((  !
;((! "
})) 
catch** 
(** $
EncoderFallbackException** +
e**, -
)**- .
{++ 
Console,, 
.,, 
	WriteLine,, !
(,,! "
e,," #
.,,# $

StackTrace,,$ .
),,. /
;,,/ 0
}-- 
}.. 	
}// 
}00 
EF:\Documents\GITrepos\Compil\Compil\Compil\Properties\AssemblyInfo.cs
[ 
assembly 	
:	 

AssemblyTitle 
( 
$str !
)! "
]" #
[		 
assembly		 	
:			 

AssemblyDescription		 
(		 
$str		 !
)		! "
]		" #
[

 
assembly

 	
:

	 
!
AssemblyConfiguration

  
(

  !
$str

! #
)

# $
]

$ %
[ 
assembly 	
:	 

AssemblyCompany 
( 
$str 
) 
] 
[ 
assembly 	
:	 

AssemblyProduct 
( 
$str #
)# $
]$ %
[ 
assembly 	
:	 

AssemblyCopyright 
( 
$str 0
)0 1
]1 2
[ 
assembly 	
:	 

AssemblyTrademark 
( 
$str 
)  
]  !
[ 
assembly 	
:	 

AssemblyCulture 
( 
$str 
) 
] 
[ 
assembly 	
:	 


ComVisible 
( 
false 
) 
] 
[ 
assembly 	
:	 

Guid 
( 
$str 6
)6 7
]7 8
[## 
assembly## 	
:##	 

AssemblyVersion## 
(## 
$str## $
)##$ %
]##% &
[$$ 
assembly$$ 	
:$$	 

AssemblyFileVersion$$ 
($$ 
$str$$ (
)$$( )
]$$) *π
;F:\Documents\GITrepos\Compil\Compil\Compil\Objects\Token.cs
	namespace 	
Compil
 
{		 
class 	
Token
 
{ 
public 
string 
Name 
{ 
get  
;  !
set" %
;% &
}' (
public 
int 
Value 
{ 
get 
; 
set  #
;# $
}% &
public 
int 
Line 
{ 
get 
; 
set "
;" #
}$ %
public 
int 
Column 
{ 
get 
;  
set! $
;$ %
}& '
public 
	TokenType 
Type 
{ 
get "
;" #
set$ '
;' (
}( )
} 
} Ú	
<F:\Documents\GITrepos\Compil\Compil\Compil\Utils\NodeType.cs
	namespace 	
Compil
 
. 
Utils 
{ 
public		 

enum		 
NodeType		 
{

 

IDENTIFIER 
, 
CONSTANT 
, 
MINUS 
, 
PLUS 
, 
NOT 
, 
OP_PLUS 
, 
OP_MINUS 
, 
OP_MULTIPLY 
, 
	OP_DIVIDE 
, 
	OP_MODULO 
, 
OP_POWER 
, 

COMP_EQUAL 
, 
COMP_DIFFERENT 
, 
COMP_SUPPERIOR 
, 
COMP_INFERIOR 
, #
COMP_SUPPERIOR_OR_EQUAL 
,  "
COMP_INFERIOR_OR_EQUAL   
,   
AND## 
,## 
OR$$ 

,$$
 
IF%% 

,%%
 
ELSE&& 
,&& 
FOR'' 
,'' 
WHILE(( 
,(( 
DO)) 

,))
 
SWITCH** 
,** 
CASE++ 
,++ 
INT,, 
,,, 
VOID-- 
}.. 
}// Õ
<F:\Documents\GITrepos\Compil\Compil\Compil\Utils\Operator.cs
	namespace 	
Compil
 
. 
Utils 
{ 
class		 	
Operator		
 
{

 
public 
Token 
Token 
{ 
get  
;  !
set" %
;% &
}' (
public 
Node 
Node 
{ 
get 
; 
set  #
;# $
}% &
public 
int 
Priority 
{ 
get !
;! "
set# &
;& '
}( )
public 
int 
Association 
{  
get! $
;$ %
set& )
;) *
}+ ,
} 
} ’
=F:\Documents\GITrepos\Compil\Compil\Compil\Utils\TokenType.cs
	namespace 	
Compil
 
. 
Utils 
{ 
public		 

enum		 
	TokenType		 
{

 

IDENTIFIER 
, 
CONSTANT 
, 
END_OF_FILE 
, 
NOT 
, 
PLUS 
, 
MINUS 
, 
MULTIPLY 
, 
DIVIDE 
, 
MODULO 
, 
POWER 
, 
IF 

,
 
ELSE 
, 
FOR 
, 
WHILE 
, 
DO 

,
 
SWITCH 
, 
CASE   
,   
INT!! 
,!! 
VOID"" 
,"" 

COMP_EQUAL$$ 
,$$ 
COMP_DIFFERENT%% 
,%% 
COMP_SUPPERIOR&& 
,&& 
COMP_INFERIOR'' 
,'' #
COMP_SUPPERIOR_OR_EQUAL(( 
,((  "
COMP_INFERIOR_OR_EQUAL)) 
,)) 
PAR_OPEN++ 
,++ 
	PAR_CLOSE,, 
,,, 
OR.. 

,..
 
AND// 
,// 
EQUAL11 
,11 
BRACKET_OPEN44 
,44 
BRACKET_CLOSE55 
,55 
	SEMICOLON77 
,77 
COMA88 
,88 
COMMENT_LINE99 
,99 
COMMENT_BLOCK_START:: 
,:: 
COMMENT_BLOCK_END;; 
}<< 
}== 