∞(
GD:\Documents\GITrepos\Compil\Compil\Compil\Analyzer\SemanticAnalyzer.cs
	namespace 	
Compil
 
{ 
public 

class 
SemanticAnalyzer !
{		 
private

 
int

 
_variablesCount

 #
=

$ %
$num

& '
;

' (
private 
readonly 
Stack 
< 

Dictionary )
<) *
string* 0
,0 1
Symbol2 8
>8 9
>9 :
_stack; A
=B C
newD G
StackH M
<M N

DictionaryN X
<X Y
stringY _
,_ `
Symbola g
>g h
>h i
(i j
)j k
;k l
private 
void 

BeginBlock 
(  
)  !
{ 	
_stack 
. 
Push 
( 
new 

Dictionary &
<& '
string' -
,- .
Symbol/ 5
>5 6
(6 7
)7 8
)8 9
;9 :
} 	
private 
void 
EndBlock 
( 
) 
{ 	
_stack 
. 
Pop 
( 
) 
; 
} 	
private 
Symbol 
Declare 
( 
string %
id& (
)( )
{ 	
return 
new 
Symbol 
( 
) 
{  !
Slot" &
=' (
_variablesCount) 8
,8 9
Id: <
== >
id? A
}B C
;C D
} 	
private 
Symbol 
Search 
( 
string $
id% '
)' (
{ 	
foreach 
( 
var 
symbolsTable %
in& (
_stack) /
)/ 0
{ 
if   
(   
symbolsTable    
.    !
TryGetValue  ! ,
(  , -
id  - /
,  / 0
out  1 4
var  5 8
value  9 >
)  > ?
)  ? @
{!! 
return"" 
value""  
;""  !
}## 
}$$ 
throw%% 
new%% !
ArgumentNullException%% +
(%%+ ,
$"%%, .

Variable '%%. 8
{%%8 9
id%%9 ;
}%%; <
' does not exist.'%%< N
"%%N O
)%%O P
;%%P Q
}&& 	
public(( 
void(( 
Analyze(( 
((( 
Node((  
node((! %
)((% &
{)) 	
switch** 
(** 
node** 
.** 
Type** 
)** 
{++ 
default,, 
:,, 
foreach-- 
(-- 
var--  
child--! &
in--' )
node--* .
.--. /
Children--/ 7
)--7 8
{.. 
Analyze// 
(//  
child//  %
)//% &
;//& '
}00 
break11 
;11 
case22 
NodeType22 
.22 
BLOCK22 #
:22# $

BeginBlock33 
(33 
)33  
;33  !
foreach44 
(44 
var44  
child44! &
in44' )
node44* .
.44. /
Children44/ 7
)447 8
{55 
Analyze66 
(66  
child66  %
)66% &
;66& '
}77 
EndBlock88 
(88 
)88 
;88 
break99 
;99 
case:: 
NodeType:: 
.:: 
DECLARE:: %
:::% &
var;; 
s1;; 
=;; 
Declare;; $
(;;$ %
node;;% )
.;;) *
Value;;* /
);;/ 0
;;;0 1
s1<< 
.<< 
Type<< 
=<< 

SymbolType<< (
.<<( )
VARIABLE<<) 1
;<<1 2
s1== 
.== 
Slot== 
=== 
_variablesCount== -
++==- /
;==/ 0
break>> 
;>> 
case?? 
NodeType?? 
.?? 
VARIABLE?? &
:??& '
var@@ 
s2@@ 
=@@ 
Search@@ #
(@@# $
node@@$ (
.@@( )
Value@@) .
)@@. /
;@@/ 0
ifAA 
(AA 
s2AA 
.AA 
TypeAA 
!=AA  "

SymbolTypeAA# -
.AA- .
VARIABLEAA. 6
)AA6 7
{BB 
throwCC 
newCC !!
ArgumentNullExceptionCC" 7
(CC7 8
$strCC8 Y
)CCY Z
;CCZ [
}DD 
nodeFF 
.FF 
SlotFF 
=FF 
s2FF  "
.FF" #
SlotFF# '
;FF' (
breakGG 
;GG 
}HH 
}II 	
}JJ 
}KK ◊ª
ED:\Documents\GITrepos\Compil\Compil\Compil\Analyzer\SyntaxAnalyzer.cs
	namespace 	
Compil
 
{ 
public 

class 
SyntaxAnalyzer 
{ 
private 
readonly 
LexicalAnalyzer (
_lexicalAnalyzer) 9
;9 :
private 
readonly 

Dictionary #
<# $
	TokenType$ -
,- .
(/ 0
NodeType0 8
,8 9
string: @
,@ A
intB E
,E F
intG J
)J K
>K L!
_exprTokenToNodeMatchM b
=c d
newe h

Dictionaryi s
<s t
	TokenTypet }
,} ~
(	 Ä
NodeType
Ä à
,
à â
string
ä ê
,
ê ë
int
í ï
,
ï ñ
int
ó ö
)
ö õ
>
õ ú
(
ú ù
)
ù û
{ 	
{ 
	TokenType 
. 
OR 
, 
( 
NodeType $
.$ %
OR% '
,' (
$str) ,
,, -
$num. /
,/ 0
$num1 2
)2 3
}3 4
,4 5
{ 
	TokenType 
. 
AND 
, 
( 
NodeType %
.% &
AND& )
,) *
$str+ .
,. /
$num0 1
,1 2
$num3 4
)4 5
}5 6
,6 7
{ 
	TokenType 
. 
NOT 
, 
( 
NodeType %
.% &
NOT& )
,) *
$str+ .
,. /
$num0 1
,1 2
$num3 4
)4 5
}5 6
,6 7
{ 
	TokenType 
. 

COMP_EQUAL !
,! "
(# $
NodeType$ ,
., -

COMP_EQUAL- 7
,7 8
$str9 =
,= >
$num? @
,@ A
$numB C
)C D
}D E
,E F
{ 
	TokenType 
. 
PLUS 
, 
( 
NodeType &
.& '
OP_PLUS' .
,. /
$str0 3
,3 4
$num5 6
,6 7
$num8 9
)9 :
}: ;
,; <
{ 
	TokenType 
. 
MINUS 
, 
( 
NodeType '
.' (
OP_MINUS( 0
,0 1
$str2 5
,5 6
$num7 8
,8 9
$num: ;
); <
}< =
,= >
{ 
	TokenType 
. 
POWER 
, 
( 
NodeType '
.' (
OP_POWER( 0
,0 1
$str2 5
,5 6
$num7 8
,8 9
$num: ;
); <
}< =
,= >
{ 
	TokenType 
. 
DIVIDE 
, 
(  
NodeType  (
.( )
	OP_DIVIDE) 2
,2 3
$str4 7
,7 8
$num9 :
,: ;
$num< =
)= >
}> ?
,? @
{ 
	TokenType 
. 
MODULO 
, 
(  
NodeType  (
.( )
	OP_MODULO) 2
,2 3
$str4 7
,7 8
$num9 :
,: ;
$num< =
)= >
}> ?
,? @
{ 
	TokenType 
. 
MULTIPLY 
,  
(! "
NodeType" *
.* +
OP_MULTIPLY+ 6
,6 7
$str8 ;
,; <
$num= >
,> ?
$num@ A
)A B
}B C
,C D
{ 
	TokenType 
. 
COMP_INFERIOR $
,$ %
(& '
NodeType' /
./ 0
COMP_INFERIOR0 =
,= >
$str? B
,B C
$numD E
,E F
$numG H
)H I
}I J
,J K
{ 
	TokenType 
. 
COMP_DIFFERENT %
,% &
(' (
NodeType( 0
.0 1
COMP_DIFFERENT1 ?
,? @
$strA E
,E F
$numG H
,H I
$numJ K
)K L
}L M
,M N
{ 
	TokenType 
. 
COMP_SUPPERIOR %
,% &
(' (
NodeType( 0
.0 1
COMP_SUPPERIOR1 ?
,? @
$strA D
,D E
$numF G
,G H
$numI J
)J K
}K L
,L M
{ 
	TokenType 
. "
COMP_INFERIOR_OR_EQUAL -
,- .
(/ 0
NodeType0 8
.8 9"
COMP_INFERIOR_OR_EQUAL9 O
,O P
$strQ U
,U V
$numW X
,X Y
$numZ [
)[ \
}\ ]
,] ^
{   
	TokenType   
.   #
COMP_SUPPERIOR_OR_EQUAL   .
,  . /
(  0 1
NodeType  1 9
.  9 :#
COMP_SUPPERIOR_OR_EQUAL  : Q
,  Q R
$str  S W
,  W X
$num  Y Z
,  Z [
$num  \ ]
)  ] ^
}  ^ _
,  _ `
{!! 
	TokenType!! 
.!! 
EQUAL!! 
,!! 
(!! 
NodeType!! '
.!!' (
AFFECT!!( .
,!!. /
$str!!0 3
,!!3 4
$num!!5 6
,!!6 7
$num!!8 9
)!!9 :
}!!: ;
}"" 	
;""	 

public(( 
SyntaxAnalyzer(( 
((( 
LexicalAnalyzer(( -
lexicalAnalyser((. =
)((= >
{)) 	
this** 
.** 
_lexicalAnalyzer** !
=**" #
lexicalAnalyser**$ 3
;**3 4
}++ 	
public00 
Node00 
Primary00 
(00 
)00 
{11 	
try22 
{33 
Node44 
node44 
;44 
if77 
(77 
_lexicalAnalyzer77 $
.77$ %
Next77% )
(77) *
)77* +
.77+ ,
Type77, 0
==771 3
	TokenType774 =
.77= >
CONSTANT77> F
)77F G
{88 
node99 
=99 
new99 
Node99 #
(99# $
)99$ %
{99& '
Type99( ,
=99- .
NodeType99/ 7
.997 8
CONSTANT998 @
,99@ A
Value99B G
=99H I
_lexicalAnalyzer99J Z
.99Z [
Next99[ _
(99_ `
)99` a
.99a b
Value99b g
.99g h
ToString99h p
(99p q
)99q r
}99s t
;99t u
_lexicalAnalyzer:: $
.::$ %
Skip::% )
(::) *
)::* +
;::+ ,
return;; 
node;; 
;;;  
}<< 
if?? 
(?? 
_lexicalAnalyzer?? $
.??$ %
Next??% )
(??) *
)??* +
.??+ ,
Type??, 0
==??1 3
	TokenType??4 =
.??= >
PAR_OPEN??> F
)??F G
{@@ 
_lexicalAnalyzerAA $
.AA$ %
SkipAA% )
(AA) *
)AA* +
;AA+ ,
nodeBB 
=BB 

ExpressionBB %
(BB% &
$numBB& '
)BB' (
;BB( )
_lexicalAnalyzerCC $
.CC$ %
AcceptCC% +
(CC+ ,
	TokenTypeCC, 5
.CC5 6
	PAR_CLOSECC6 ?
)CC? @
;CC@ A
returnDD 
nodeDD 
;DD  
}EE 
ifHH 
(HH 
_lexicalAnalyzerHH $
.HH$ %
NextHH% )
(HH) *
)HH* +
.HH+ ,
TypeHH, 0
==HH1 3
	TokenTypeHH4 =
.HH= >
MINUSHH> C
||HHD F
_lexicalAnalyzerII $
.II$ %
NextII% )
(II) *
)II* +
.II+ ,
TypeII, 0
==II1 3
	TokenTypeII4 =
.II= >
PLUSII> B
||IIC E
_lexicalAnalyzerJJ $
.JJ$ %
NextJJ% )
(JJ) *
)JJ* +
.JJ+ ,
TypeJJ, 0
==JJ1 3
	TokenTypeJJ4 =
.JJ= >
NOTJJ> A
)JJA B
{KK 
varLL 
(LL 
nodeTypeLL !
,LL! "
valLL# &
,LL& '
_LL( )
,LL) *
_LL+ ,
)LL, -
=LL. /!
_exprTokenToNodeMatchLL0 E
[LLE F
_lexicalAnalyzerLLF V
.LLV W
NextLLW [
(LL[ \
)LL\ ]
.LL] ^
TypeLL^ b
]LLb c
;LLc d
nodeMM 
=MM 
newMM 
NodeMM #
(MM# $
)MM$ %
{MM& '
TypeMM( ,
=MM- .
nodeTypeMM/ 7
,MM7 8
ValueMM9 >
=MM? @
valMMA D
}MME F
;MMF G
_lexicalAnalyzerNN $
.NN$ %
SkipNN% )
(NN) *
)NN* +
;NN+ ,
nodeOO 
.OO 
AddChildOO !
(OO! "

ExpressionOO" ,
(OO, -
$numOO- .
)OO. /
)OO/ 0
;OO0 1
returnPP 
nodePP 
;PP  
}QQ 
ifTT 
(TT 
_lexicalAnalyzerTT $
.TT$ %
NextTT% )
(TT) *
)TT* +
.TT+ ,
TypeTT, 0
==TT1 3
	TokenTypeTT4 =
.TT= >

IDENTIFIERTT> H
)TTH I
{UU 
nodeVV 
=VV 
newVV 
NodeVV #
(VV# $
)VV$ %
{VV& '
TypeVV( ,
=VV- .
NodeTypeVV/ 7
.VV7 8
VARIABLEVV8 @
,VV@ A
ValueVVB G
=VVH I
_lexicalAnalyzerVVJ Z
.VVZ [
NextVV[ _
(VV_ `
)VV` a
.VVa b
NameVVb f
.VVf g
ToStringVVg o
(VVo p
)VVp q
}VVr s
;VVs t
_lexicalAnalyzerWW $
.WW$ %
SkipWW% )
(WW) *
)WW* +
;WW+ ,
returnXX 
nodeXX 
;XX  
}YY 
throw\\ 
new\\ !
ArgumentNullException\\ /
(\\/ 0
$str\\0 C
)\\C D
;\\D E
}]] 
catch^^ 
(^^ #
NotImplementedException^^ *
e^^+ ,
)^^, -
{__ 
Console`` 
.`` 
	WriteLine`` !
(``! "
$str``" <
)``< =
;``= >
Consoleaa 
.aa 
	WriteLineaa !
(aa! "
eaa" #
.aa# $

StackTraceaa$ .
)aa. /
;aa/ 0
returnbb 
nullbb 
;bb 
}cc 
catchdd 
(dd !
ArgumentNullExceptiondd (
edd) *
)dd* +
{ee 
Consoleff 
.ff 
	WriteLineff !
(ff! "
eff" #
.ff# $
Messageff$ +
)ff+ ,
;ff, -
Consolegg 
.gg 
	WriteLinegg !
(gg! "
egg" #
.gg# $

StackTracegg$ .
)gg. /
;gg/ 0
returnhh 
nullhh 
;hh 
}ii 
}jj 	
publicqq 
Nodeqq 

Expressionqq 
(qq 
intqq "
pMinqq# '
=qq( )
$numqq* +
)qq+ ,
{rr 	
varss 
leftNodess 
=ss 
Primaryss "
(ss" #
)ss# $
;ss$ %
whileuu 
(uu 
trueuu 
)uu 
{vv 
ifww 
(ww 
_lexicalAnalyzerww $
.ww$ %
Nextww% )
(ww) *
)ww* +
==ww, .
nullww/ 3
)ww3 4
returnxx 
leftNodexx #
;xx# $
varzz 
opzz 
=zz 
SearchOpzz !
(zz! "
_lexicalAnalyzerzz" 2
.zz2 3
Nextzz3 7
(zz7 8
)zz8 9
)zz9 :
;zz: ;
if|| 
(|| 
op|| 
==|| 
null|| 
|||| !
op||" $
.||$ %
Priority||% -
<||. /
pMin||0 4
)||4 5
return}} 
leftNode}} #
;}}# $
_lexicalAnalyzer  
.  !
Skip! %
(% &
)& '
;' (
var
ÄÄ 
	rightNode
ÄÄ 
=
ÄÄ 

Expression
ÄÄ  *
(
ÄÄ* +
op
ÄÄ+ -
.
ÄÄ- .
Priority
ÄÄ. 6
+
ÄÄ7 8
op
ÄÄ9 ;
.
ÄÄ; <
Association
ÄÄ< G
)
ÄÄG H
;
ÄÄH I
var
ÅÅ 
tree
ÅÅ 
=
ÅÅ 
new
ÅÅ 
Node
ÅÅ #
(
ÅÅ# $
)
ÅÅ$ %
{
ÅÅ& '
Type
ÅÅ( ,
=
ÅÅ- .
op
ÅÅ/ 1
.
ÅÅ1 2
Node
ÅÅ2 6
.
ÅÅ6 7
Type
ÅÅ7 ;
}
ÅÅ< =
;
ÅÅ= >
tree
ÇÇ 
.
ÇÇ 
AddChild
ÇÇ 
(
ÇÇ 
leftNode
ÇÇ &
)
ÇÇ& '
;
ÇÇ' (
tree
ÉÉ 
.
ÉÉ 
AddChild
ÉÉ 
(
ÉÉ 
	rightNode
ÉÉ '
)
ÉÉ' (
;
ÉÉ( )
leftNode
ÑÑ 
=
ÑÑ 
tree
ÑÑ 
;
ÑÑ  
}
ÖÖ 
}
ÜÜ 	
public
çç 
Operator
çç 
SearchOp
çç  
(
çç  !
Token
çç! &
token
çç' ,
)
çç, -
{
éé 	
if
èè 
(
èè #
_exprTokenToNodeMatch
èè %
.
èè% &
TryGetValue
èè& 1
(
èè1 2
token
èè2 7
.
èè7 8
Type
èè8 <
,
èè< =
out
èè> A
var
èèB E
vals
èèF J
)
èèJ K
)
èèK L
{
êê 
var
ëë 
(
ëë 
nodetype
ëë 
,
ëë 
val
ëë "
,
ëë" #
priority
ëë$ ,
,
ëë, -
assos
ëë. 3
)
ëë3 4
=
ëë5 6
vals
ëë7 ;
;
ëë; <
return
íí 
new
íí 
Operator
íí #
(
íí# $
)
íí$ %
{
íí& '
Token
íí( -
=
íí. /
token
íí0 5
,
íí5 6
Node
íí7 ;
=
íí< =
new
íí> A
Node
ííB F
(
ííF G
)
ííG H
{
ííI J
Type
ííK O
=
ííP Q
nodetype
ííR Z
}
íí[ \
,
íí\ ]
Priority
íí^ f
=
ííg h
priority
ííi q
,
ííq r
Association
íís ~
=íí Ä
assosííÅ Ü
}ííá à
;ííà â
}
ìì 
return
îî 
null
îî 
;
îî 
}
ïï 	
public
óó 
Node
óó 
Instruction
óó 
(
óó  
)
óó  !
{
òò 	
if
ôô 
(
ôô 
_lexicalAnalyzer
ôô  
.
ôô  !
Next
ôô! %
(
ôô% &
)
ôô& '
.
ôô' (
Type
ôô( ,
==
ôô- /
	TokenType
ôô0 9
.
ôô9 :
IF
ôô: <
)
ôô< =
{
öö 
_lexicalAnalyzer
õõ  
.
õõ  !
Skip
õõ! %
(
õõ% &
)
õõ& '
;
õõ' (
_lexicalAnalyzer
úú  
.
úú  !
Accept
úú! '
(
úú' (
	TokenType
úú( 1
.
úú1 2
PAR_OPEN
úú2 :
)
úú: ;
;
úú; <
var
ùù 
aTest
ùù 
=
ùù 

Expression
ùù &
(
ùù& '
)
ùù' (
;
ùù( )
_lexicalAnalyzer
ûû  
.
ûû  !
Accept
ûû! '
(
ûû' (
	TokenType
ûû( 1
.
ûû1 2
	PAR_CLOSE
ûû2 ;
)
ûû; <
;
ûû< =
var
üü 
aCode
üü 
=
üü 
Instruction
üü '
(
üü' (
)
üü( )
;
üü) *
var
†† 
node
†† 
=
†† 
new
†† 
Node
†† #
(
††# $
)
††$ %
{
††& '
Type
††' +
=
††, -
NodeType
††. 6
.
††6 7
	CONDITION
††7 @
}
††@ A
;
††A B
node
°° 
.
°° 
AddChild
°° 
(
°° 
aTest
°° #
)
°°# $
;
°°$ %
node
¢¢ 
.
¢¢ 
AddChild
¢¢ 
(
¢¢ 
aCode
¢¢ #
)
¢¢# $
;
¢¢$ %
return
££ 
node
££ 
;
££ 
}
§§ 
else
•• 
if
•• 
(
•• 
_lexicalAnalyzer
•• $
.
••$ %
Next
••% )
(
••) *
)
••* +
.
••+ ,
Type
••, 0
==
••1 3
	TokenType
••4 =
.
••= >
WHILE
••> C
)
••C D
{
¶¶ 
_lexicalAnalyzer
ßß  
.
ßß  !
Skip
ßß! %
(
ßß% &
)
ßß& '
;
ßß' (
_lexicalAnalyzer
®®  
.
®®  !
Accept
®®! '
(
®®' (
	TokenType
®®( 1
.
®®1 2
PAR_OPEN
®®2 :
)
®®: ;
;
®®; <
var
©© 
aTest
©© 
=
©© 

Expression
©© &
(
©©& '
)
©©' (
;
©©( )
_lexicalAnalyzer
™™  
.
™™  !
Accept
™™! '
(
™™' (
	TokenType
™™( 1
.
™™1 2
	PAR_CLOSE
™™2 ;
)
™™; <
;
™™< =
var
´´ 
aCode
´´ 
=
´´ 
Instruction
´´ '
(
´´' (
)
´´( )
;
´´) *
var
¨¨ 
node
¨¨ 
=
¨¨ 
new
¨¨ 
Node
¨¨ #
(
¨¨# $
)
¨¨$ %
{
¨¨& '
Type
¨¨( ,
=
¨¨- .
NodeType
¨¨/ 7
.
¨¨7 8
WHILE
¨¨8 =
}
¨¨> ?
;
¨¨? @
node
≠≠ 
.
≠≠ 
AddChild
≠≠ 
(
≠≠ 
aTest
≠≠ #
)
≠≠# $
;
≠≠$ %
node
ÆÆ 
.
ÆÆ 
AddChild
ÆÆ 
(
ÆÆ 
aCode
ÆÆ #
)
ÆÆ# $
;
ÆÆ$ %
return
ØØ 
node
ØØ 
;
ØØ 
}
∞∞ 
else
±± 
if
±± 
(
±± 
_lexicalAnalyzer
±± %
.
±±% &
Next
±±& *
(
±±* +
)
±±+ ,
.
±±, -
Type
±±- 1
==
±±2 4
	TokenType
±±5 >
.
±±> ?
BRACKET_OPEN
±±? K
)
±±K L
{
≤≤ 
var
≥≥ 
node
≥≥ 
=
≥≥ 
new
≥≥ 
Node
≥≥ #
(
≥≥# $
)
≥≥$ %
{
≥≥& '
Type
≥≥' +
=
≥≥, -
NodeType
≥≥. 6
.
≥≥6 7
BLOCK
≥≥7 <
}
≥≥< =
;
≥≥= >
_lexicalAnalyzer
¥¥  
.
¥¥  !
Accept
¥¥! '
(
¥¥' (
	TokenType
¥¥( 1
.
¥¥1 2
BRACKET_OPEN
¥¥2 >
)
¥¥> ?
;
¥¥? @
while
µµ 
(
µµ 
_lexicalAnalyzer
µµ '
.
µµ' (
Next
µµ( ,
(
µµ, -
)
µµ- .
.
µµ. /
Type
µµ/ 3
!=
µµ4 6
	TokenType
µµ7 @
.
µµ@ A
BRACKET_CLOSE
µµA N
)
µµN O
{
∂∂ 
var
∑∑ 
x
∑∑ 
=
∑∑ 
Instruction
∑∑ '
(
∑∑' (
)
∑∑( )
;
∑∑) *
node
∏∏ 
.
∏∏ 
AddChild
∏∏ !
(
∏∏! "
x
∏∏" #
)
∏∏# $
;
∏∏$ %
}
ππ 
_lexicalAnalyzer
∫∫  
.
∫∫  !
Accept
∫∫! '
(
∫∫' (
	TokenType
∫∫( 1
.
∫∫1 2
BRACKET_CLOSE
∫∫2 ?
)
∫∫? @
;
∫∫@ A
return
ªª 
node
ªª 
;
ªª 
}
ºº 
else
ΩΩ 
if
ΩΩ 
(
ΩΩ 
_lexicalAnalyzer
ΩΩ %
.
ΩΩ% &
Next
ΩΩ& *
(
ΩΩ* +
)
ΩΩ+ ,
.
ΩΩ, -
Type
ΩΩ- 1
==
ΩΩ2 4
	TokenType
ΩΩ5 >
.
ΩΩ> ?
VAR
ΩΩ? B
)
ΩΩB C
{
ΩΩD E
_lexicalAnalyzer
ææ  
.
ææ  !
Skip
ææ! %
(
ææ% &
)
ææ& '
;
ææ' (
if
øø 
(
øø 
_lexicalAnalyzer
øø $
.
øø$ %
Next
øø% )
(
øø) *
)
øø* +
.
øø+ ,
Type
øø, 0
==
øø1 3
	TokenType
øø4 =
.
øø= >

IDENTIFIER
øø> H
)
øøH I
{
øøJ K
var
¿¿ 
variableName
¿¿ $
=
¿¿% &
_lexicalAnalyzer
¿¿' 7
.
¿¿7 8
Next
¿¿8 <
(
¿¿< =
)
¿¿= >
.
¿¿> ?
Name
¿¿? C
;
¿¿C D
var
¡¡ 
nodeVariable
¡¡ $
=
¡¡% &
new
¡¡' *
Node
¡¡+ /
(
¡¡/ 0
)
¡¡0 1
{
¡¡2 3
Type
¡¡4 8
=
¡¡9 :
NodeType
¡¡; C
.
¡¡C D
DECLARE
¡¡D K
}
¡¡L M
;
¡¡M N
nodeVariable
¬¬  
.
¬¬  !
AddChild
¬¬! )
(
¬¬) *
new
¬¬* -
Node
¬¬. 2
(
¬¬2 3
)
¬¬3 4
{
¬¬5 6
Type
¬¬6 :
=
¬¬; <
NodeType
¬¬= E
.
¬¬E F
VARIABLE
¬¬F N
,
¬¬N O
Value
¬¬P U
=
¬¬V W
variableName
¬¬X d
}
¬¬d e
)
¬¬e f
;
¬¬f g
var
√√ 
ex
√√ 
=
√√ 

Expression
√√ '
(
√√' (
)
√√( )
;
√√) *
if
≈≈ 
(
≈≈ 
ex
≈≈ 
.
≈≈ 
Children
≈≈ #
[
≈≈# $
$num
≈≈$ %
]
≈≈% &
.
≈≈& '
Type
≈≈' +
!=
≈≈, .
NodeType
≈≈/ 7
.
≈≈7 8
AFFECT
≈≈8 >
)
≈≈> ?
{
≈≈@ A
throw
∆∆ 
new
∆∆ !
	Exception
∆∆" +
(
∆∆+ ,
$str
∆∆, <
)
∆∆< =
;
∆∆= >
}
«« 
nodeVariable
……  
.
……  !
AddChild
……! )
(
……) *
ex
……* ,
)
……, -
;
……- .
return
   
nodeVariable
   '
;
  ' (
}
ÀÀ 
throw
ÃÃ 
new
ÃÃ 
	Exception
ÃÃ #
(
ÃÃ# $
$str
ÃÃ$ ;
)
ÃÃ; <
;
ÃÃ< =
}
ÕÕ 
else
ŒŒ 
{
œœ 
var
–– 
ex
–– 
=
–– 

Expression
–– #
(
––# $
)
––$ %
;
––% &
_lexicalAnalyzer
——  
.
——  !
Accept
——! '
(
——' (
	TokenType
——( 1
.
——1 2
	SEMICOLON
——2 ;
)
——; <
;
——< =
var
““ 
node
““ 
=
““ 
new
““ 
Node
““ #
(
““# $
)
““$ %
{
““& '
Type
““' +
=
““, -
NodeType
““. 6
.
““6 7

EXPRESSION
““7 A
}
““A B
;
““B C
node
”” 
.
”” 
AddChild
”” 
(
”” 
ex
””  
)
””  !
;
””! "
return
‘‘ 
node
‘‘ 
;
‘‘ 
}
’’ 
}
÷÷ 	
}
ÿÿ 
}ŸŸ ´
8D:\Documents\GITrepos\Compil\Compil\Compil\Compilator.cs
	namespace 	
Compil
 
{ 
public 

class 

Compilator 
{		 
public

 
void

 
Compile

 
(

 
string

 "
	inputCode

# ,
,

, -
string

. 4

outputPath

5 ?
)

? @
{ 	
var 
lexicalAnalyser 
=  !
new" %
LexicalAnalyzer& 5
(5 6
	inputCode6 ?
,? @
$numA B
)B C
;C D
var 
syntaxAnalyzer 
=  
new! $
SyntaxAnalyzer% 3
(3 4
lexicalAnalyser4 C
)C D
;D E
var 

fileWriter 
= 
new  

FileWriter! +
(+ ,
), -
;- .
var 
node 
= 
syntaxAnalyzer %
.% &

Expression& 0
(0 1
$num1 2
)2 3
;3 4
var 
codeGenerator 
= 
new  #
CodeGenerator$ 1
(1 2

fileWriter2 <
)< =
;= >
codeGenerator 
. 
GenerateCode &
(& '
node' +
)+ ,
;, -
} 	
} 
} Å
ND:\Documents\GITrepos\Compil\Compil\Compil\Exceptions\NotValidCharException.cs
	namespace 	
Compil
 
. 

Exceptions 
{ 
class 	!
NotValidCharException
 
{ 
public !
NotValidCharException $
($ %
)% &
{		 	
} 	
} 
} ¸x
ED:\Documents\GITrepos\Compil\Compil\Compil\Generator\CodeGenerator.cs
	namespace 	
Compil
 
. 
	Generator 
{ 
public 

class 
CodeGenerator 
{		 
private 
readonly 

FileWriter #
_fileWriter$ /
;/ 0
private 
readonly 

Dictionary #
<# $
NodeType$ ,
,, -
string. 4
>4 5
_operatorsToCode6 F
=G H
newI L

DictionaryM W
<W X
NodeTypeX `
,` a
stringb h
>h i
(i j
)j k
{ 	
{ 
NodeType 
. 
OP_PLUS 
, 
$str  %
}& '
,' (
{ 
NodeType 
. 
OP_MINUS 
,  
$str! &
}' (
,( )
{ 
NodeType 
. 
OP_MULTIPLY "
," #
$str$ )
}* +
,+ ,
{ 
NodeType 
. 
	OP_DIVIDE  
,  !
$str" '
}( )
,) *
{ 
NodeType 
. 
	OP_MODULO  
,  !
$str" '
}( )
,) *
{ 
NodeType 
. 
AND 
, 
$str !
}" #
,# $
{ 
NodeType 
. 
OR 
, 
$str 
}  !
} 	
;	 

public 
CodeGenerator 
( 

FileWriter '

fileWriter( 2
)2 3
{ 	
_fileWriter 
= 

fileWriter $
;$ %
} 	
public&& 
void&& 
GenerateCode&&  
(&&  !
Node&&! %
node&&& *
)&&* +
{'' 	
if)) 
()) 
node)) 
.)) 
Type)) 
==)) 
NodeType)) %
.))% &
CONSTANT))& .
))). /
{** 
_fileWriter++ 
.++ 
WriteCommand++ (
(++( )
$str++) 0
+++1 2
node++2 6
.++6 7
Value++7 <
,++< =
true++> B
)++B C
;++C D
},, 
if// 
(// 
_operatorsToCode//  
.//  !
ContainsKey//! ,
(//, -
node//- 1
.//1 2
Type//2 6
)//6 7
)//7 8
{00 
GenerateCode11 
(11 
node11 !
.11! "
Children11" *
[11* +
$num11+ ,
]11, -
)11- .
;11. /
GenerateCode22 
(22 
node22 !
.22! "
Children22" *
[22* +
$num22+ ,
]22, -
)22- .
;22. /
_fileWriter33 
.33 
WriteCommand33 (
(33( )
_operatorsToCode33) 9
[339 :
node33: >
.33> ?
Type33? C
]33C D
,33D E
true33F J
)33J K
;33K L
}44 
switch77 
(77 
node77 
.77 
Type77 
)77 
{88 
case:: 
NodeType:: 
.:: 
MINUS:: #
:::# $
_fileWriter;; 
.;;  
WriteCommand;;  ,
(;;, -
$str;;- 5
,;;5 6
true;;7 ;
);;; <
;;;< =
GenerateCode<<  
(<<  !
node<<! %
.<<% &
Children<<& .
[<<. /
$num<</ 0
]<<0 1
)<<1 2
;<<2 3
_fileWriter== 
.==  
WriteCommand==  ,
(==, -
$str==- 2
,==2 3
true==4 8
)==8 9
;==9 :
break>> 
;>> 
case?? 
NodeType?? 
.?? 
PLUS?? "
:??" #
_fileWriter@@ 
.@@  
WriteCommand@@  ,
(@@, -
$str@@- 5
,@@5 6
true@@7 ;
)@@; <
;@@< =
GenerateCodeAA  
(AA  !
nodeAA! %
.AA% &
ChildrenAA& .
[AA. /
$numAA/ 0
]AA0 1
)AA1 2
;AA2 3
_fileWriterBB 
.BB  
WriteCommandBB  ,
(BB, -
$strBB- 2
,BB2 3
trueBB4 8
)BB8 9
;BB9 :
breakCC 
;CC 
}DD 
ifGG 
(GG 
nodeGG 
.GG 
TypeGG 
==GG 
NodeTypeGG %
.GG% &
VARIABLEGG& .
)GG. /
{HH 
_fileWriterII 
.II 
WriteCommandII (
(II( )
$strII) 0
,II0 1
trueII2 6
)II6 7
;II7 8
}JJ 
ifLL 
(LL 
nodeLL 
.LL 
TypeLL 
==LL 
NodeTypeLL %
.LL% &
AFFECTLL& ,
)LL, -
{MM 
GenerateCodeNN 
(NN 
nodeNN !
.NN! "
ChildrenNN" *
[NN* +
$numNN+ ,
]NN, -
)NN- .
;NN. /
_fileWriterOO 
.OO 
WriteCommandOO (
(OO( )
$strOO) .
,OO. /
falseOO0 5
)OO5 6
;OO6 7
_fileWriterPP 
.PP 
WriteCommandPP (
(PP( )
$strPP) 0
,PP0 1
falsePP2 7
)PP7 8
;PP8 9
}QQ 
ifTT 
(TT 
nodeTT 
.TT 
TypeTT 
==TT 
NodeTypeTT %
.TT% &
BLOCKTT& +
)TT+ ,
{UU 
foreachVV 
(VV 
varVV 
childVV "
inVV# %
nodeVV& *
.VV* +
ChildrenVV+ 3
)VV3 4
{WW 
GenerateCodeXX  
(XX  !
childXX! &
)XX& '
;XX' (
}YY 
}ZZ 
if]] 
(]] 
node]] 
.]] 
Type]] 
==]] 
NodeType]] %
.]]% &

EXPRESSION]]& 0
)]]0 1
{^^ 
GenerateCode__ 
(__ 
node__ !
.__! "
Children__" *
[__* +
$num__+ ,
]__, -
)__- .
;__. /
_fileWriter`` 
.`` 
WriteCommand`` (
(``( )
$str``) /
)``/ 0
;``0 1
}aa 
ifdd 
(dd 
nodedd 
.dd 
Typedd 
==dd 
NodeTypedd %
.dd% &
	CONDITIONdd& /
)dd/ 0
{ee 
varff 
nodeTestff 
=ff 
nodeff #
.ff# $
Childrenff$ ,
[ff, -
$numff- .
]ff. /
;ff/ 0
vargg 
nodeCodegg 
=gg 
nodegg #
.gg# $
Childrengg$ ,
[gg, -
$numgg- .
]gg. /
;gg/ 0
GenerateCodeii 
(ii 
nodeTestii %
)ii% &
;ii& '
_fileWriterkk 
.kk 
WriteCommandkk (
(kk( )
$strkk) 6
,kk6 7
falsekk8 =
)kk= >
;kk> ?
foreachmm 
(mm 
varmm 
childmm "
inmm# %
nodeCodemm& .
.mm. /
Childrenmm/ 7
)mm7 8
{nn 
GenerateCodeoo  
(oo  !
childoo! &
)oo& '
;oo' (
}pp 
_fileWriterrr 
.rr 
WriteCommandrr (
(rr( )
$strrr) 1
,rr1 2
falserr3 8
)rr8 9
;rr9 :
}ss 
ifuu 
(uu 
nodeuu 
.uu 
Typeuu 
==uu 
NodeTypeuu $
.uu$ %
ELSEuu% )
)uu) *
{vv 
varww 
nodeCodeww 
=ww 
nodeww #
.ww# $
Childrenww$ ,
[ww, -
$numww- .
]ww. /
;ww/ 0
foreachyy 
(yy 
varyy 
childyy !
inyy" $
nodeCodeyy% -
.yy- .
Childrenyy. 6
)yy6 7
{zz 
GenerateCode{{  
({{  !
child{{! &
){{& '
;{{' (
}|| 
}}} 
if
ÄÄ 
(
ÄÄ 
node
ÄÄ 
.
ÄÄ 
Type
ÄÄ 
==
ÄÄ 
NodeType
ÄÄ $
.
ÄÄ$ %
WHILE
ÄÄ% *
)
ÄÄ* +
{
ÅÅ 
_fileWriter
ÉÉ 
.
ÉÉ 
WriteCommand
ÉÉ (
(
ÉÉ( )
$str
ÉÉ) :
,
ÉÉ: ;
false
ÉÉ< A
)
ÉÉA B
;
ÉÉB C
var
ÖÖ 
nodeTest
ÖÖ 
=
ÖÖ 
node
ÖÖ #
.
ÖÖ# $
Children
ÖÖ$ ,
[
ÖÖ, -
$num
ÖÖ- .
]
ÖÖ. /
;
ÖÖ/ 0
var
ÜÜ 
nodeCode
ÜÜ 
=
ÜÜ 
node
ÜÜ #
.
ÜÜ# $
Children
ÜÜ$ ,
[
ÜÜ, -
$num
ÜÜ- .
]
ÜÜ. /
;
ÜÜ/ 0
GenerateCode
àà 
(
àà 
nodeTest
àà %
)
àà% &
;
àà& '
_fileWriter
ää 
.
ää 
WriteCommand
ää (
(
ää( )
$str
ää) 9
,
ää9 :
false
ää; @
)
ää@ A
;
ääA B
foreach
åå 
(
åå 
var
åå 
child
åå "
in
åå# %
nodeCode
åå& .
.
åå. /
Children
åå/ 7
)
åå7 8
{
çç 
GenerateCode
éé  
(
éé  !
child
éé! &
)
éé& '
;
éé' (
}
èè 
_fileWriter
íí 
.
íí 
WriteCommand
íí (
(
íí( )
$str
íí) >
,
íí> ?
false
íí@ E
)
ííE F
;
ííF G
_fileWriter
ìì 
.
ìì 
WriteCommand
ìì (
(
ìì( )
$str
ìì) 4
,
ìì4 5
false
ìì6 ;
)
ìì; <
;
ìì< =
}
îî 
if
óó 
(
óó 
node
óó 
.
óó 
Type
óó 
==
óó 
NodeType
óó %
.
óó% &
DECLARE
óó& -
)
óó- .
{
òò 
}
öö 
if
ûû 
(
ûû 
node
ûû 
.
ûû 
Type
ûû 
==
ûû 
NodeType
ûû %
.
ûû% &

COMP_EQUAL
ûû& 0
)
ûû0 1
{
üü 
GenerateCode
†† 
(
†† 
node
†† !
.
††! "
Children
††" *
[
††* +
$num
††+ ,
]
††, -
)
††- .
;
††. /
GenerateCode
°° 
(
°° 
node
°° !
.
°°! "
Children
°°" *
[
°°* +
$num
°°+ ,
]
°°, -
)
°°- .
;
°°. /
_fileWriter
¢¢ 
.
¢¢ 
WriteCommand
¢¢ (
(
¢¢( )
$str
¢¢) 0
,
¢¢0 1
true
¢¢2 6
)
¢¢6 7
;
¢¢7 8
}
££ 
if
¶¶ 
(
¶¶ 
node
¶¶ 
.
¶¶ 
Type
¶¶ 
==
¶¶ 
NodeType
¶¶ %
.
¶¶% &
COMP_DIFFERENT
¶¶& 4
)
¶¶4 5
{
ßß 
GenerateCode
®® 
(
®® 
node
®® !
.
®®! "
Children
®®" *
[
®®* +
$num
®®+ ,
]
®®, -
)
®®- .
;
®®. /
GenerateCode
©© 
(
©© 
node
©© !
.
©©! "
Children
©©" *
[
©©* +
$num
©©+ ,
]
©©, -
)
©©- .
;
©©. /
_fileWriter
™™ 
.
™™ 
WriteCommand
™™ (
(
™™( )
$str
™™) 0
,
™™0 1
true
™™2 6
)
™™6 7
;
™™7 8
}
´´ 
if
ÆÆ 
(
ÆÆ 
node
ÆÆ 
.
ÆÆ 
Type
ÆÆ 
==
ÆÆ 
NodeType
ÆÆ %
.
ÆÆ% &
COMP_INFERIOR
ÆÆ& 3
)
ÆÆ3 4
{
ØØ 
GenerateCode
∞∞ 
(
∞∞ 
node
∞∞ !
.
∞∞! "
Children
∞∞" *
[
∞∞* +
$num
∞∞+ ,
]
∞∞, -
)
∞∞- .
;
∞∞. /
GenerateCode
±± 
(
±± 
node
±± !
.
±±! "
Children
±±" *
[
±±* +
$num
±±+ ,
]
±±, -
)
±±- .
;
±±. /
_fileWriter
≤≤ 
.
≤≤ 
WriteCommand
≤≤ (
(
≤≤( )
$str
≤≤) 0
,
≤≤0 1
true
≤≤2 6
)
≤≤6 7
;
≤≤7 8
}
≥≥ 
if
∂∂ 
(
∂∂ 
node
∂∂ 
.
∂∂ 
Type
∂∂ 
==
∂∂ 
NodeType
∂∂ %
.
∂∂% &$
COMP_INFERIOR_OR_EQUAL
∂∂& <
)
∂∂< =
{
∑∑ 
GenerateCode
∏∏ 
(
∏∏ 
node
∏∏ !
.
∏∏! "
Children
∏∏" *
[
∏∏* +
$num
∏∏+ ,
]
∏∏, -
)
∏∏- .
;
∏∏. /
GenerateCode
ππ 
(
ππ 
node
ππ !
.
ππ! "
Children
ππ" *
[
ππ* +
$num
ππ+ ,
]
ππ, -
)
ππ- .
;
ππ. /
_fileWriter
∫∫ 
.
∫∫ 
WriteCommand
∫∫ (
(
∫∫( )
$str
∫∫) 0
,
∫∫0 1
true
∫∫2 6
)
∫∫6 7
;
∫∫7 8
}
ªª 
if
ææ 
(
ææ 
node
ææ 
.
ææ 
Type
ææ 
==
ææ 
NodeType
ææ %
.
ææ% &
COMP_SUPPERIOR
ææ& 4
)
ææ4 5
{
øø 
GenerateCode
¿¿ 
(
¿¿ 
node
¿¿ !
.
¿¿! "
Children
¿¿" *
[
¿¿* +
$num
¿¿+ ,
]
¿¿, -
)
¿¿- .
;
¿¿. /
GenerateCode
¡¡ 
(
¡¡ 
node
¡¡ !
.
¡¡! "
Children
¡¡" *
[
¡¡* +
$num
¡¡+ ,
]
¡¡, -
)
¡¡- .
;
¡¡. /
_fileWriter
¬¬ 
.
¬¬ 
WriteCommand
¬¬ (
(
¬¬( )
$str
¬¬) 0
,
¬¬0 1
true
¬¬2 6
)
¬¬6 7
;
¬¬7 8
}
√√ 
if
∆∆ 
(
∆∆ 
node
∆∆ 
.
∆∆ 
Type
∆∆ 
==
∆∆ 
NodeType
∆∆ %
.
∆∆% &%
COMP_SUPPERIOR_OR_EQUAL
∆∆& =
)
∆∆= >
{
«« 
GenerateCode
»» 
(
»» 
node
»» !
.
»»! "
Children
»»" *
[
»»* +
$num
»»+ ,
]
»», -
)
»»- .
;
»». /
GenerateCode
…… 
(
…… 
node
…… !
.
……! "
Children
……" *
[
……* +
$num
……+ ,
]
……, -
)
……- .
;
……. /
_fileWriter
   
.
   
WriteCommand
   (
(
  ( )
$str
  ) 0
,
  0 1
true
  2 6
)
  6 7
;
  7 8
}
ÀÀ 
}
ÃÃ 	
}
ÕÕ 
}ŒŒ ˙¡
FD:\Documents\GITrepos\Compil\Compil\Compil\Analyzer\LexicalAnalyzer.cs
	namespace 	
Compil
 
{		 
public

 

class

 
LexicalAnalyzer

  
{ 
private 
readonly 
string 
code  $
;$ %
private 
int 
index 
; 
private 
readonly 

Dictionary #
<# $
string$ *
,* +
	TokenType, 5
>5 6
keywords7 ?
=@ A
newB E

DictionaryF P
<P Q
stringQ W
,W X
	TokenTypeY b
>b c
(c d
)d e
{ 	
{ 
$str 
, 
	TokenType 
. 
IF 
}  
,  !
{ 
$str 
, 
	TokenType 
. 
ELSE #
}# $
,$ %
{ 
$str 
, 
	TokenType 
. 
FOR !
}! "
," #
{ 
$str 
, 
	TokenType 
.  
WHILE  %
}% &
,& '
{ 
$str 
, 
	TokenType 
. 
DO 
}  
,  !
{ 
$str 
, 
	TokenType  
.  !
SWITCH! '
}' (
,( )
{ 
$str 
, 
	TokenType 
. 
CASE #
}# $
,$ %
{ 
$str 
, 
	TokenType 
. 
INT !
}! "
," #
{ 
$str 
, 
	TokenType 
. 
VOID #
}# $
} 	
;	 

private 
Token 
_currentNextToken '
;' (
private 
int 
_currentTokenLength '
=( )
$num* +
;+ ,
public%% 
LexicalAnalyzer%% 
(%% 
string%% %
code%%& *
,%%* +
int%%, /
index%%0 5
)%%5 6
{&& 	
this'' 
.'' 
code'' 
='' 
code'' 
;'' 
this(( 
.(( 
index(( 
=(( 
index(( 
;(( 
})) 	
public00 
Token00 
Next00 
(00 
)00 
{11 	
if22 
(22 
_currentNextToken22 !
!=22" $
null22% )
)22) *
{33 
return44 
_currentNextToken44 (
;44( )
}55 
var77 
result77 
=77 

DetectNext77 #
(77# $
)77$ %
;77% &
_currentNextToken88 
=88 
result88  &
;88& '
return99 
result99 
;99 
}:: 	
public?? 
void?? 
Skip?? 
(?? 
)?? 
{@@ 	
indexAA 
+=AA 
_currentTokenLengthAA (
;AA( )
_currentTokenLengthBB 
=BB  !
$numBB" #
;BB# $
_currentNextTokenCC 
=CC 
nullCC  $
;CC$ %
}DD 	
publicJJ 
voidJJ 
AcceptJJ 
(JJ 
	TokenTypeJJ $
typeJJ% )
)JJ) *
{KK 	
tryLL 
{MM 
ifNN 
(NN 
NextNN 
(NN 
)NN 
.NN 
TypeNN 
!=NN  "
typeNN# '
)NN' (
{OO 
throwPP 
newPP !
ArgumentNullExceptionPP 3
(PP3 4
$"PP4 6
Bad token: 'PP6 B
{PPB C
typePPC G
.PPG H
ToStringPPH P
(PPP Q
)PPQ R
}PPR S
' expected.PPS ^
"PP^ _
)PP_ `
;PP` a
}QQ 
SkipSS 
(SS 
)SS 
;SS 
}TT 
catchUU 
(UU !
ArgumentNullExceptionUU (
eUU) *
)UU* +
{VV 
ConsoleWW 
.WW 
	WriteLineWW !
(WW! "
eWW" #
.WW# $
MessageWW$ +
)WW+ ,
;WW, -
}XX 
}YY 	
private`` 
Token`` 

DetectNext``  
(``  !
)``! "
{aa 	
trybb 
{cc 
StringBuilderdd 
builderdd %
=dd& '
newdd( +
StringBuilderdd, 9
(dd9 :
)dd: ;
;dd; <
ifff 
(ff 
indexff 
==ff 
codeff !
.ff! "
Lengthff" (
)ff( )
{gg 
returnhh 
newhh 
Tokenhh $
(hh$ %
)hh% &
{hh' (
Typehh) -
=hh. /
	TokenTypehh0 9
.hh9 :
END_OF_FILEhh: E
}hhF G
;hhG H
}ii 
whilekk 
(kk 
codekk 
[kk 
indexkk !
]kk! "
==kk# %
$charkk& )
||kk* ,
codekk- 1
[kk1 2
indexkk2 7
]kk7 8
==kk9 ;
$charkk< @
||kkA C
codekkD H
[kkH I
indexkkI N
]kkN O
==kkP R
$charkkS W
||kkX Z
codekk[ _
[kk_ `
indexkk` e
]kke f
==kkg i
$charkkj n
)kkn o
{ll 
indexmm 
++mm 
;mm 
}nn 
ifqq 
(qq 
charqq 
.qq 
IsDigitqq  
(qq  !
codeqq! %
[qq% &
indexqq& +
]qq+ ,
)qq, -
)qq- .
{rr 
_currentTokenLengthss '
=ss( )
$numss* +
;ss+ ,
builderuu 
.uu 
Appenduu "
(uu" #
codeuu# '
[uu' (
indexuu( -
]uu- .
.uu. /
ToStringuu/ 7
(uu7 8
)uu8 9
)uu9 :
;uu: ;
ifww 
(ww 
indexww 
==ww  
codeww! %
.ww% &
Lengthww& ,
-ww- .
$numww/ 0
)ww0 1
{xx 
returnyy 
newyy "
Tokenyy# (
(yy( )
)yy) *
{yy+ ,
Typeyy- 1
=yy2 3
	TokenTypeyy4 =
.yy= >
CONSTANTyy> F
,yyF G
ValueyyH M
=yyN O
intyyP S
.yyS T
ParseyyT Y
(yyY Z
builderyyZ a
.yya b
ToStringyyb j
(yyj k
)yyk l
)yyl m
}yyn o
;yyo p
}zz 
var|| 
i|| 
=|| 
index|| !
+||" #
$num||$ %
;||% &
while}} 
(}} 
i}} 
<}} 
code}} #
.}}# $
Length}}$ *
&&}}+ -
char}}. 2
.}}2 3
IsDigit}}3 :
(}}: ;
code}}; ?
[}}? @
i}}@ A
]}}A B
)}}B C
)}}C D
{~~ 
builder 
.  
Append  &
(& '
code' +
[+ ,
i, -
]- .
.. /
ToString/ 7
(7 8
)8 9
)9 :
;: ;
i
ÄÄ 
++
ÄÄ 
;
ÄÄ !
_currentTokenLength
ÅÅ +
++
ÅÅ+ -
;
ÅÅ- .
}
ÇÇ 
return
ÑÑ 
new
ÑÑ 
Token
ÑÑ $
(
ÑÑ$ %
)
ÑÑ% &
{
ÑÑ' (
Type
ÑÑ) -
=
ÑÑ. /
	TokenType
ÑÑ0 9
.
ÑÑ9 :
CONSTANT
ÑÑ: B
,
ÑÑB C
Value
ÑÑD I
=
ÑÑJ K
int
ÑÑL O
.
ÑÑO P
Parse
ÑÑP U
(
ÑÑU V
builder
ÑÑV ]
.
ÑÑ] ^
ToString
ÑÑ^ f
(
ÑÑf g
)
ÑÑg h
)
ÑÑh i
}
ÑÑj k
;
ÑÑk l
}
ÖÖ 
if
àà 
(
àà 
char
àà 
.
àà 
IsLetter
àà !
(
àà! "
code
àà" &
[
àà& '
index
àà' ,
]
àà, -
)
àà- .
)
àà. /
{
ââ !
_currentTokenLength
ää '
=
ää( )
$num
ää* +
;
ää+ ,
builder
ãã 
.
ãã 
Append
ãã "
(
ãã" #
code
ãã# '
[
ãã' (
index
ãã( -
]
ãã- .
.
ãã. /
ToString
ãã/ 7
(
ãã7 8
)
ãã8 9
)
ãã9 :
;
ãã: ;
if
çç 
(
çç 
index
çç 
==
çç  
code
çç! %
.
çç% &
Length
çç& ,
-
çç- .
$num
çç/ 0
)
çç0 1
{
éé 
if
êê 
(
êê 
keywords
êê $
.
êê$ %
ContainsKey
êê% 0
(
êê0 1
builder
êê1 8
.
êê8 9
ToString
êê9 A
(
êêA B
)
êêB C
)
êêC D
)
êêD E
{
ëë 
return
íí "
new
íí# &
Token
íí' ,
(
íí, -
)
íí- .
{
íí/ 0
Type
íí1 5
=
íí6 7
keywords
íí8 @
[
íí@ A
builder
ííA H
.
ííH I
ToString
ííI Q
(
ííQ R
)
ííR S
]
ííS T
,
ííT U
Name
ííV Z
=
íí[ \
builder
íí] d
.
ííd e
ToString
ííe m
(
íím n
)
íín o
}
ííp q
;
ííq r
}
ìì 
return
ïï 
new
ïï "
Token
ïï# (
(
ïï( )
)
ïï) *
{
ïï+ ,
Type
ïï- 1
=
ïï2 3
	TokenType
ïï4 =
.
ïï= >

IDENTIFIER
ïï> H
,
ïïH I
Name
ïïJ N
=
ïïO P
builder
ïïQ X
.
ïïX Y
ToString
ïïY a
(
ïïa b
)
ïïb c
}
ïïd e
;
ïïe f
}
ññ 
var
òò 
i
òò 
=
òò 
index
òò !
+
òò" #
$num
òò$ %
;
òò% &
while
ôô 
(
ôô 
i
ôô 
<
ôô 
code
ôô #
.
ôô# $
Length
ôô$ *
&&
ôô+ -
(
ôô. /
char
ôô/ 3
.
ôô3 4
IsLetter
ôô4 <
(
ôô< =
code
ôô= A
[
ôôA B
i
ôôB C
]
ôôC D
)
ôôD E
||
ôôF H
char
ôôI M
.
ôôM N
IsDigit
ôôN U
(
ôôU V
code
ôôV Z
[
ôôZ [
i
ôô[ \
]
ôô\ ]
)
ôô] ^
)
ôô^ _
)
ôô_ `
{
öö 
builder
õõ 
.
õõ  
Append
õõ  &
(
õõ& '
code
õõ' +
[
õõ+ ,
i
õõ, -
]
õõ- .
.
õõ. /
ToString
õõ/ 7
(
õõ7 8
)
õõ8 9
)
õõ9 :
;
õõ: ;
i
úú 
++
úú 
;
úú !
_currentTokenLength
ùù +
++
ùù+ -
;
ùù- .
}
ûû 
if
°° 
(
°° 
keywords
°°  
.
°°  !
ContainsKey
°°! ,
(
°°, -
builder
°°- 4
.
°°4 5
ToString
°°5 =
(
°°= >
)
°°> ?
)
°°? @
)
°°@ A
{
¢¢ 
return
££ 
new
££ "
Token
££# (
(
££( )
)
££) *
{
££+ ,
Type
££- 1
=
££2 3
keywords
££4 <
[
££< =
builder
££= D
.
££D E
ToString
££E M
(
££M N
)
££N O
]
££O P
,
££P Q
Name
££R V
=
££W X
builder
££Y `
.
££` a
ToString
££a i
(
££i j
)
££j k
}
££l m
;
££m n
}
§§ 
return
¶¶ 
new
¶¶ 
Token
¶¶ $
(
¶¶$ %
)
¶¶% &
{
¶¶' (
Type
¶¶) -
=
¶¶. /
	TokenType
¶¶0 9
.
¶¶9 :

IDENTIFIER
¶¶: D
,
¶¶D E
Name
¶¶F J
=
¶¶K L
builder
¶¶M T
.
¶¶T U
ToString
¶¶U ]
(
¶¶] ^
)
¶¶^ _
}
¶¶` a
;
¶¶a b
}
ßß 
if
™™ 
(
™™ 
code
™™ 
[
™™ 
index
™™ 
]
™™ 
==
™™  "
$char
™™# &
)
™™& '
{
´´ !
_currentTokenLength
¨¨ '
=
¨¨( )
$num
¨¨* +
;
¨¨+ ,
builder
≠≠ 
.
≠≠ 
Append
≠≠ "
(
≠≠" #
code
≠≠# '
[
≠≠' (
index
≠≠( -
]
≠≠- .
.
≠≠. /
ToString
≠≠/ 7
(
≠≠7 8
)
≠≠8 9
)
≠≠9 :
;
≠≠: ;
if
ØØ 
(
ØØ 
index
ØØ 
==
ØØ  
code
ØØ! %
.
ØØ% &
Length
ØØ& ,
-
ØØ- .
$num
ØØ/ 0
)
ØØ0 1
{
∞∞ 
return
±± 
new
±± "
Token
±±# (
(
±±( )
)
±±) *
{
±±+ ,
Type
±±- 1
=
±±2 3
	TokenType
±±4 =
.
±±= >
EQUAL
±±> C
}
±±D E
;
±±E F
}
≤≤ 
if
¥¥ 
(
¥¥ 
code
¥¥ 
[
¥¥ 
index
¥¥ "
+
¥¥# $
$num
¥¥% &
]
¥¥& '
==
¥¥( *
$char
¥¥+ .
)
¥¥. /
{
µµ !
_currentTokenLength
∂∂ +
++
∂∂+ -
;
∂∂- .
return
∑∑ 
new
∑∑ "
Token
∑∑# (
(
∑∑( )
)
∑∑) *
{
∑∑+ ,
Type
∑∑- 1
=
∑∑2 3
	TokenType
∑∑4 =
.
∑∑= >

COMP_EQUAL
∑∑> H
}
∑∑I J
;
∑∑J K
}
∏∏ 
return
∫∫ 
new
∫∫ 
Token
∫∫ $
(
∫∫$ %
)
∫∫% &
{
∫∫' (
Type
∫∫) -
=
∫∫. /
	TokenType
∫∫0 9
.
∫∫9 :
EQUAL
∫∫: ?
}
∫∫@ A
;
∫∫A B
}
ªª 
if
ææ 
(
ææ 
code
ææ 
[
ææ 
index
ææ 
]
ææ 
==
ææ  "
$char
ææ# &
)
ææ& '
{
øø !
_currentTokenLength
¿¿ '
=
¿¿( )
$num
¿¿* +
;
¿¿+ ,
builder
¡¡ 
.
¡¡ 
Append
¡¡ "
(
¡¡" #
code
¡¡# '
[
¡¡' (
index
¡¡( -
]
¡¡- .
.
¡¡. /
ToString
¡¡/ 7
(
¡¡7 8
)
¡¡8 9
)
¡¡9 :
;
¡¡: ;
if
√√ 
(
√√ 
index
√√ 
==
√√  
code
√√! %
.
√√% &
Length
√√& ,
-
√√- .
$num
√√/ 0
)
√√0 1
{
ƒƒ 
return
≈≈ 
new
≈≈ "
Token
≈≈# (
(
≈≈( )
)
≈≈) *
{
≈≈+ ,
Type
≈≈- 1
=
≈≈2 3
	TokenType
≈≈4 =
.
≈≈= >
COMP_SUPPERIOR
≈≈> L
}
≈≈M N
;
≈≈N O
}
∆∆ 
if
»» 
(
»» 
code
»» 
[
»» 
index
»» "
+
»»# $
$num
»»% &
]
»»& '
==
»»( *
$char
»»+ .
)
»». /
{
…… !
_currentTokenLength
   +
++
  + -
;
  - .
return
ÀÀ 
new
ÀÀ "
Token
ÀÀ# (
(
ÀÀ( )
)
ÀÀ) *
{
ÀÀ+ ,
Type
ÀÀ- 1
=
ÀÀ2 3
	TokenType
ÀÀ4 =
.
ÀÀ= >%
COMP_SUPPERIOR_OR_EQUAL
ÀÀ> U
}
ÀÀV W
;
ÀÀW X
}
ÃÃ 
return
ŒŒ 
new
ŒŒ 
Token
ŒŒ $
(
ŒŒ$ %
)
ŒŒ% &
{
ŒŒ' (
Type
ŒŒ) -
=
ŒŒ. /
	TokenType
ŒŒ0 9
.
ŒŒ9 :
COMP_SUPPERIOR
ŒŒ: H
}
ŒŒI J
;
ŒŒJ K
}
œœ 
if
““ 
(
““ 
code
““ 
[
““ 
index
““ 
]
““ 
==
““  "
$char
““# &
)
““& '
{
”” !
_currentTokenLength
‘‘ '
=
‘‘( )
$num
‘‘* +
;
‘‘+ ,
builder
’’ 
.
’’ 
Append
’’ "
(
’’" #
code
’’# '
[
’’' (
index
’’( -
]
’’- .
.
’’. /
ToString
’’/ 7
(
’’7 8
)
’’8 9
)
’’9 :
;
’’: ;
if
◊◊ 
(
◊◊ 
index
◊◊ 
==
◊◊  
code
◊◊! %
.
◊◊% &
Length
◊◊& ,
-
◊◊- .
$num
◊◊/ 0
)
◊◊0 1
{
ÿÿ 
return
ŸŸ 
new
ŸŸ "
Token
ŸŸ# (
(
ŸŸ( )
)
ŸŸ) *
{
ŸŸ+ ,
Type
ŸŸ- 1
=
ŸŸ2 3
	TokenType
ŸŸ4 =
.
ŸŸ= >
COMP_INFERIOR
ŸŸ> K
}
ŸŸL M
;
ŸŸM N
}
⁄⁄ 
if
‹‹ 
(
‹‹ 
code
‹‹ 
[
‹‹ 
index
‹‹ "
+
‹‹# $
$num
‹‹% &
]
‹‹& '
==
‹‹( *
$char
‹‹+ .
)
‹‹. /
{
›› !
_currentTokenLength
ﬁﬁ +
++
ﬁﬁ+ -
;
ﬁﬁ- .
return
ﬂﬂ 
new
ﬂﬂ "
Token
ﬂﬂ# (
(
ﬂﬂ( )
)
ﬂﬂ) *
{
ﬂﬂ+ ,
Type
ﬂﬂ- 1
=
ﬂﬂ2 3
	TokenType
ﬂﬂ4 =
.
ﬂﬂ= >$
COMP_INFERIOR_OR_EQUAL
ﬂﬂ> T
}
ﬂﬂU V
;
ﬂﬂV W
}
‡‡ 
return
‚‚ 
new
‚‚ 
Token
‚‚ $
(
‚‚$ %
)
‚‚% &
{
‚‚' (
Type
‚‚) -
=
‚‚. /
	TokenType
‚‚0 9
.
‚‚9 :
COMP_INFERIOR
‚‚: G
}
‚‚H I
;
‚‚I J
}
„„ 
if
ÊÊ 
(
ÊÊ 
code
ÊÊ 
[
ÊÊ 
index
ÊÊ 
]
ÊÊ 
==
ÊÊ  "
$char
ÊÊ# &
)
ÊÊ& '
{
ÁÁ !
_currentTokenLength
ËË '
=
ËË( )
$num
ËË* +
;
ËË+ ,
builder
ÈÈ 
.
ÈÈ 
Append
ÈÈ "
(
ÈÈ" #
code
ÈÈ# '
[
ÈÈ' (
index
ÈÈ( -
]
ÈÈ- .
.
ÈÈ. /
ToString
ÈÈ/ 7
(
ÈÈ7 8
)
ÈÈ8 9
)
ÈÈ9 :
;
ÈÈ: ;
if
ÎÎ 
(
ÎÎ 
index
ÎÎ 
==
ÎÎ  
code
ÎÎ! %
.
ÎÎ% &
Length
ÎÎ& ,
-
ÎÎ- .
$num
ÎÎ/ 0
)
ÎÎ0 1
{
ÏÏ 
return
ÌÌ 
new
ÌÌ "
Token
ÌÌ# (
(
ÌÌ( )
)
ÌÌ) *
{
ÌÌ+ ,
Type
ÌÌ- 1
=
ÌÌ2 3
	TokenType
ÌÌ4 =
.
ÌÌ= >
NOT
ÌÌ> A
}
ÌÌB C
;
ÌÌC D
}
ÓÓ 
if
 
(
 
code
 
[
 
index
 "
+
# $
$num
% &
]
& '
==
( *
$char
+ .
)
. /
{
ÒÒ !
_currentTokenLength
ÚÚ +
++
ÚÚ+ -
;
ÚÚ- .
return
ÛÛ 
new
ÛÛ "
Token
ÛÛ# (
(
ÛÛ( )
)
ÛÛ) *
{
ÛÛ+ ,
Type
ÛÛ- 1
=
ÛÛ2 3
	TokenType
ÛÛ4 =
.
ÛÛ= >
COMP_DIFFERENT
ÛÛ> L
}
ÛÛM N
;
ÛÛN O
}
ÙÙ 
return
ˆˆ 
new
ˆˆ 
Token
ˆˆ $
(
ˆˆ$ %
)
ˆˆ% &
{
ˆˆ' (
Type
ˆˆ) -
=
ˆˆ. /
	TokenType
ˆˆ0 9
.
ˆˆ9 :
NOT
ˆˆ: =
}
ˆˆ> ?
;
ˆˆ? @
}
˜˜ !
_currentTokenLength
˘˘ #
++
˘˘# %
;
˘˘% &
switch
˙˙ 
(
˙˙ 
code
˙˙ 
[
˙˙ 
index
˙˙ "
]
˙˙" #
)
˙˙# $
{
˚˚ 
case
¸¸ 
$char
¸¸ 
:
¸¸ 
return
˝˝ 
new
˝˝ "
Token
˝˝# (
(
˝˝( )
)
˝˝) *
{
˝˝+ ,
Type
˝˝- 1
=
˝˝2 3
	TokenType
˝˝4 =
.
˝˝= >
PLUS
˝˝> B
}
˝˝C D
;
˝˝D E
case
˛˛ 
$char
˛˛ 
:
˛˛ 
return
ˇˇ 
new
ˇˇ "
Token
ˇˇ# (
(
ˇˇ( )
)
ˇˇ) *
{
ˇˇ+ ,
Type
ˇˇ- 1
=
ˇˇ2 3
	TokenType
ˇˇ4 =
.
ˇˇ= >
MINUS
ˇˇ> C
}
ˇˇD E
;
ˇˇE F
case
ÄÄ 
$char
ÄÄ 
:
ÄÄ 
return
ÅÅ 
new
ÅÅ "
Token
ÅÅ# (
(
ÅÅ( )
)
ÅÅ) *
{
ÅÅ+ ,
Type
ÅÅ- 1
=
ÅÅ2 3
	TokenType
ÅÅ4 =
.
ÅÅ= >
MULTIPLY
ÅÅ> F
}
ÅÅG H
;
ÅÅH I
case
ÇÇ 
$char
ÇÇ 
:
ÇÇ 
return
ÉÉ 
new
ÉÉ "
Token
ÉÉ# (
(
ÉÉ( )
)
ÉÉ) *
{
ÉÉ+ ,
Type
ÉÉ- 1
=
ÉÉ2 3
	TokenType
ÉÉ4 =
.
ÉÉ= >
DIVIDE
ÉÉ> D
}
ÉÉE F
;
ÉÉF G
case
ÑÑ 
$char
ÑÑ 
:
ÑÑ 
return
ÖÖ 
new
ÖÖ "
Token
ÖÖ# (
(
ÖÖ( )
)
ÖÖ) *
{
ÖÖ+ ,
Type
ÖÖ- 1
=
ÖÖ2 3
	TokenType
ÖÖ4 =
.
ÖÖ= >
MODULO
ÖÖ> D
}
ÖÖE F
;
ÖÖF G
case
ÜÜ 
$char
ÜÜ 
:
ÜÜ 
return
áá 
new
áá "
Token
áá# (
(
áá( )
)
áá) *
{
áá+ ,
Type
áá- 1
=
áá2 3
	TokenType
áá4 =
.
áá= >
POWER
áá> C
}
ááD E
;
ááE F
case
àà 
$char
àà 
:
àà 
return
ââ 
new
ââ "
Token
ââ# (
(
ââ( )
)
ââ) *
{
ââ+ ,
Type
ââ- 1
=
ââ2 3
	TokenType
ââ4 =
.
ââ= >
PAR_OPEN
ââ> F
}
ââG H
;
ââH I
case
ää 
$char
ää 
:
ää 
return
ãã 
new
ãã "
Token
ãã# (
(
ãã( )
)
ãã) *
{
ãã+ ,
Type
ãã- 1
=
ãã2 3
	TokenType
ãã4 =
.
ãã= >
	PAR_CLOSE
ãã> G
}
ããH I
;
ããI J
case
åå 
$char
åå 
:
åå 
return
çç 
new
çç "
Token
çç# (
(
çç( )
)
çç) *
{
çç+ ,
Type
çç- 1
=
çç2 3
	TokenType
çç4 =
.
çç= >
BRACKET_OPEN
çç> J
}
ççK L
;
ççL M
case
éé 
$char
éé 
:
éé 
return
èè 
new
èè "
Token
èè# (
(
èè( )
)
èè) *
{
èè+ ,
Type
èè- 1
=
èè2 3
	TokenType
èè4 =
.
èè= >
BRACKET_CLOSE
èè> K
}
èèL M
;
èèM N
case
êê 
$char
êê 
:
êê 
return
ëë 
new
ëë "
Token
ëë# (
(
ëë( )
)
ëë) *
{
ëë+ ,
Type
ëë- 1
=
ëë2 3
	TokenType
ëë4 =
.
ëë= >
AND
ëë> A
}
ëëB C
;
ëëC D
case
íí 
$char
íí 
:
íí 
return
ìì 
new
ìì "
Token
ìì# (
(
ìì( )
)
ìì) *
{
ìì+ ,
Type
ìì- 1
=
ìì2 3
	TokenType
ìì4 =
.
ìì= >
OR
ìì> @
}
ììA B
;
ììB C
case
îî 
$char
îî 
:
îî 
return
ïï 
new
ïï "
Token
ïï# (
(
ïï( )
)
ïï) *
{
ïï+ ,
Type
ïï- 1
=
ïï2 3
	TokenType
ïï4 =
.
ïï= >
	SEMICOLON
ïï> G
}
ïïH I
;
ïïI J
default
ññ 
:
ññ 
break
óó 
;
óó 
}
òò 
throw
öö 
new
öö %
NotImplementedException
öö 1
(
öö1 2
)
öö2 3
;
öö3 4
}
õõ 
catch
úú 
(
úú %
NotImplementedException
úú *
e
úú+ ,
)
úú, -
{
ùù 
Console
ûû 
.
ûû 
	WriteLine
ûû !
(
ûû! "
e
ûû" #
.
ûû# $
Message
ûû$ +
)
ûû+ ,
;
ûû, -
return
üü 
null
üü 
;
üü 
}
†† 
}
°° 	
}
¢¢ 
}££ ˘
AD:\Documents\GITrepos\Compil\Compil\Compil\LauncherVM\Launcher.cs
	namespace

 	
Compil


 
.

 

LauncherVM

 
{ 
public 

class 
Launcher 
{ 
private 
readonly 
string 
pathMsm  '
;' (
private 
readonly 
string 
msmProgrammName  /
;/ 0
public 
Launcher 
( 
string 
pathMsm &
,& '
string( .
msmProgrammName/ >
)> ?
{ 	
this 
. 
pathMsm 
= 
pathMsm "
;" #
this 
. 
msmProgrammName  
=! "
msmProgrammName# 2
;2 3
} 	
public 
void 
CopyOutFile 
(  
)  !
{ 	
File 
. 
Copy 
( 
Path 
. 
Combine "
(" #
Environment# .
.. /
CurrentDirectory/ ?
,? @
$strA K
)K L
,L M
Path 
. 
Combine 
( 
pathMsm $
,$ %
$str& 0
)0 1
,1 2
true 
) 
; 
} 	
public 
void 
LaunchCodeOnVm "
(" #
)# $
{   	
Process!! 
process!! 
=!! 
new!! !
Process!!" )
(!!) *
)!!* +
;!!+ ,
process"" 
."" 
	StartInfo"" 
."" 
FileName"" &
=""' (
Path"") -
.""- .
Combine"". 5
(""5 6
$str	""6 †
,
""† °
$str
""¢ Æ
)
""Æ Ø
;
""Ø ∞
process## 
.## 
	StartInfo## 
.## 
WorkingDirectory## .
=##/ 0
this##1 5
.##5 6
pathMsm##6 =
;##= >
process$$ 
.$$ 
	StartInfo$$ 
.$$ 
	Arguments$$ '
=$$( )
$str$$* .
+$$/ 0
msmProgrammName$$1 @
+$$A B
$str$$B Z
;$$Z [
process%% 
.%% 
	StartInfo%% 
.%% 
CreateNoWindow%% ,
=%%- .
false%%/ 4
;%%4 5
process&& 
.&& 
Start&& 
(&& 
)&& 
;&& 
Thread(( 
.(( 
Sleep(( 
((( 
$num(( 
)(( 
;(( 
})) 	
}++ 
},, ñ
8D:\Documents\GITrepos\Compil\Compil\Compil\Nodes\Node.cs
	namespace 	
Compil
 
{ 
public 

class 
Node 
{ 
public 
NodeType 
Type 
{ 
get "
;" #
set$ '
;' (
}) *
public 
string 
Value 
{ 
get !
;! "
set# &
;& '
}( )
public 
List 
< 
Node 
> 
Children "
{# $
get% (
;( )
set* -
;- .
}/ 0
=1 2
new3 6
List7 ;
<; <
Node< @
>@ A
(A B
)B C
;C D
public 
int 
Slot 
{ 
get 
; 
set "
;" #
}$ %
public 
void 
AddChild 
( 
Node !
node" &
)& '
{ 	
Children 
. 
Add 
( 
node 
) 
; 
} 	
public$$ 
void$$ 
AddChildren$$ 
($$  
List$$  $
<$$$ %
Node$$% )
>$$) *
nodes$$+ 0
)$$0 1
{%% 	
foreach&& 
(&& 
var&& 
node&& 
in&&  
nodes&&! &
)&&& '
Children'' 
.'' 
Add'' 
('' 
node'' !
)''! "
;''" #
}(( 	
public// 
void// 
Print// 
(// 
string//  
indent//! '
,//' (
bool//) -
last//. 2
)//2 3
{00 	
Console11 
.11 
Write11 
(11 
indent11  
)11  !
;11! "
if22 
(22 
last22 
)22 
{33 
Console44 
.44 
Write44 
(44 
$str44 #
)44# $
;44$ %
indent55 
+=55 
$str55 
;55 
}66 
else77 
{88 
Console99 
.99 
Write99 
(99 
$str99 "
)99" #
;99# $
indent:: 
+=:: 
$str:: 
;:: 
};; 
if<< 
(<< 
Type<< 
==<< 
NodeType<<  
.<<  !
CONSTANT<<! )
)<<) *
Console>> 
.>> 
	WriteLine>> !
(>>! "
$">>" $
VALUE: >>$ +
{>>+ ,
Value>>, 1
}>>1 2
">>2 3
)>>3 4
;>>4 5
else?? 
if?? 
(?? 
Type?? 
==?? 
NodeType?? $
.??$ %
VARIABLE??% -
)??- .
Console@@ 
.@@ 
	WriteLine@@ !
(@@! "
$"@@" $
VARIABLE: name=@@$ 3
{@@3 4
Value@@4 9
}@@9 :
"@@: ;
)@@; <
;@@< =
elseAA 
ConsoleCC 
.CC 
	WriteLineCC !
(CC! "
TypeCC" &
)CC& '
;CC' (
forEE 
(EE 
varEE 
iEE 
=EE 
$numEE 
;EE 
iEE 
<EE 
ChildrenEE  (
.EE( )
CountEE) .
;EE. /
iEE0 1
++EE1 3
)EE3 4
ChildrenFF 
[FF 
iFF 
]FF 
.FF 
PrintFF !
(FF! "
indentFF" (
,FF( )
iFF* +
==FF, .
ChildrenFF/ 7
.FF7 8
CountFF8 =
-FF> ?
$numFF@ A
)FFA B
;FFB C
}GG 	
}KK 
}LL á
<D:\Documents\GITrepos\Compil\Compil\Compil\Nodes\NodeType.cs
	namespace 	
Compil
 
. 
Nodes 
{ 
public		 

enum		 
NodeType		 
{

 
VARIABLE 
, 
CONSTANT 
, 
MINUS 
, 
PLUS 
, 
NOT 
, 
OP_PLUS 
, 
OP_MINUS 
, 
OP_MULTIPLY 
, 
	OP_DIVIDE 
, 
	OP_MODULO 
, 
OP_POWER 
, 
AFFECT 
, 

COMP_EQUAL 
, 
COMP_DIFFERENT 
, 
COMP_SUPPERIOR 
, 
COMP_INFERIOR   
,   #
COMP_SUPPERIOR_OR_EQUAL!! 
,!!  "
COMP_INFERIOR_OR_EQUAL"" 
,"" 
AND%% 
,%% 
OR&& 

,&&
 
	CONDITION'' 
,'' 
ELSE(( 
,(( 
FOR)) 
,)) 
WHILE** 
,** 
DO++ 

,++
 
SWITCH,, 
,,, 
CASE-- 
,-- 
INT.. 
,.. 
VOID// 
,// 
BLOCK11 
,11 

EXPRESSION22 
,22 
DECLARE33 
}44 
}55 ß&
5D:\Documents\GITrepos\Compil\Compil\Compil\Program.cs
	namespace 	
Compil
 
{ 
static 

class 
Program 
{ 
static 
void 
Main 
( 
string 
[  
]  !
args" &
)& '
{ 	
try 
{ 
if 
( 
args 
. 
Length 
==  "
$num# $
)$ %
{ 
Help 
( 
) 
; 
Console 
. 
ReadKey #
(# $
)$ %
;% &
return 
; 
} 
Console 
. 
	WriteLine !
(! "
$str" 3
+4 5
args6 :
[: ;
args; ?
.? @
Length@ F
-G H
$numI J
]J K
)K L
;L M
string 
pathFile 
=  !
Path" &
.& '
Combine' .
(. /
args/ 3
[3 4
args4 8
.8 9
Length9 ?
-@ A
$numB C
]C D
)D E
;E F
string 
codeTemp 
=  !
File" &
.& '
ReadAllText' 2
(2 3
pathFile3 ;
); <
;< =
Console   
.   
	WriteLine   !
(  ! "
$str  " 3
)  3 4
;  4 5
Console!! 
.!! 
	WriteLine!! !
(!!! "
codeTemp!!" *
)!!* +
;!!+ ,
Console## 
.## 
	WriteLine## !
(##! "
$str##" >
)##> ?
;##? @
Console$$ 
.$$ 
ReadKey$$ 
($$  
)$$  !
;$$! "
Console%% 
.%% 
	WriteLine%% !
(%%! "
)%%" #
;%%# $
var(( 
lexicalAnalyser(( #
=(($ %
new((& )
LexicalAnalyzer((* 9
(((9 :
codeTemp((: B
,((B C
$num((D E
)((E F
;((F G
var** 
syntaxAnalyzer** "
=**# $
new**% (
SyntaxAnalyzer**) 7
(**7 8
lexicalAnalyser**8 G
)**G H
;**H I
var,, 

fileWriter,, 
=,,  
new,,! $

FileWriter,,% /
(,,/ 0
),,0 1
;,,1 2

fileWriter.. 
... 
InitFile.. #
(..# $
)..$ %
;..% &
var11 
node11 
=11 
syntaxAnalyzer11 )
.11) *
Instruction11* 5
(115 6
)116 7
;117 8
node22 
.22 
Print22 
(22 
$str22 
,22 
false22 $
)22$ %
;22% &
var44 
codeGenerator44 !
=44" #
new44$ '
CodeGenerator44( 5
(445 6

fileWriter446 @
)44@ A
;44A B
codeGenerator55 
.55 
GenerateCode55 *
(55* +
node55+ /
)55/ 0
;550 1

fileWriter88 
.88 
	WriteFile88 $
(88$ %
)88% &
;88& '
ConsoleBB 
.BB 
	WriteLineBB !
(BB! "
$strBB" <
)BB< =
;BB= >
ConsoleCC 
.CC 
ReadKeyCC 
(CC  
)CC  !
;CC! "
}DD 
catchEE 
(EE $
EncoderFallbackExceptionEE +
eEE, -
)EE- .
{FF 
ConsoleGG 
.GG 
	WriteLineGG !
(GG! "
eGG" #
.GG# $

StackTraceGG$ .
)GG. /
;GG/ 0
}HH 
catchII 
(II !
ArgumentNullExceptionII (
eII) *
)II* +
{JJ 
ConsoleKK 
.KK 
	WriteLineKK !
(KK! "
$strKK" K
)KKK L
;KKL M
ConsoleLL 
.LL 
	WriteLineLL !
(LL! "
eLL" #
.LL# $
MessageLL$ +
)LL+ ,
;LL, -
}MM 
}NN 	
publicTT 
staticTT 
voidTT 
HelpTT 
(TT  
)TT  !
{UU 	
ConsoleVV 
.VV 
	WriteLineVV 
(VV 
$strVV :
)VV: ;
;VV; <
ConsoleWW 
.WW 
	WriteLineWW 
(WW 
$strWW 8
)WW8 9
;WW9 :
ConsoleXX 
.XX 
	WriteLineXX 
(XX 
$strXX 6
)XX6 7
;XX7 8
}YY 	
}ZZ 
}[[ 
ED:\Documents\GITrepos\Compil\Compil\Compil\Properties\AssemblyInfo.cs
[ 
assembly 	
:	 

AssemblyTitle 
( 
$str !
)! "
]" #
[ 
assembly 	
:	 

AssemblyDescription 
( 
$str !
)! "
]" #
[		 
assembly		 	
:			 
!
AssemblyConfiguration		  
(		  !
$str		! #
)		# $
]		$ %
[

 
assembly

 	
:

	 

AssemblyCompany

 
(

 
$str

 
)

 
]

 
[ 
assembly 	
:	 

AssemblyProduct 
( 
$str #
)# $
]$ %
[ 
assembly 	
:	 

AssemblyCopyright 
( 
$str 0
)0 1
]1 2
[ 
assembly 	
:	 

AssemblyTrademark 
( 
$str 
)  
]  !
[ 
assembly 	
:	 

AssemblyCulture 
( 
$str 
) 
] 
[ 
assembly 	
:	 


ComVisible 
( 
false 
) 
] 
[ 
assembly 	
:	 

Guid 
( 
$str 6
)6 7
]7 8
["" 
assembly"" 	
:""	 

AssemblyVersion"" 
("" 
$str"" $
)""$ %
]""% &
[## 
assembly## 	
:##	 

AssemblyFileVersion## 
(## 
$str## (
)##( )
]##) *æ
>D:\Documents\GITrepos\Compil\Compil\Compil\Symbols\NodeType.cs
	namespace 	
Compil
 
. 
Symbols 
{		 
public

 

enum

 

SymbolType

 
{ 
VARIABLE 
, 
FUNCTION 
} 
} ≈
<D:\Documents\GITrepos\Compil\Compil\Compil\Symbols\Symbol.cs
	namespace 	
Compil
 
. 
Symbols 
{ 
public 

class 
Symbol 
{ 
public 
string 
Id 
{ 
get 
; 
set  #
;# $
}% &
public 

SymbolType 
Type 
{  
get! $
;$ %
set& )
;) *
}+ ,
public 
int 
Slot 
{ 
get 
; 
set "
;" #
}$ %
} 
}		 ƒ
>D:\Documents\GITrepos\Compil\Compil\Compil\Utils\FileWriter.cs
	namespace 	
Compil
 
. 
Utils 
{ 
public		 

class		 

FileWriter		 
{

 
private 
readonly 
string 
pathFileCode  ,
;, -
private 
string 
code 
; 
public 

FileWriter 
( 
) 
{ 	
code 
= 
String 
. 
Empty 
;  
pathFileCode 
= 
Path 
.  
Combine  '
(' (
Environment( 3
.3 4
CurrentDirectory4 D
,D E
$strF P
)P Q
;Q R
} 	
public 
void 
InitFile 
( 
) 
{ 	
code 
+= 
$str 
+ 
$str #
;# $
} 	
public$$ 
void$$ 
WriteCommand$$  
($$  !
string$$! '
cmd$$( +
,$$+ ,
bool$$- 1
debug$$2 7
=$$8 9
false$$: ?
)$$? @
{%% 	
code&& 
+=&& 
cmd&& 
+&& 
$str&& 
;&& 
if'' 
('' 
debug'' 
)'' 
{(( 
code)) 
+=)) 
$str)) 
+)) 
$str))  $
;))$ %
code** 
+=** 
$str** 
+** 
$str**  $
;**$ %
}++ 
},, 	
public11 
void11 
	WriteFile11 
(11 
)11 
{22 	
try33 
{44 
code55 
+=55 
$str55 
;55  
code66 
+=66 
$str66 
;66 
if77 
(77 
File77 
.77 
Exists77 
(77  
pathFileCode77  ,
)77, -
)77- .
File88 
.88 
Delete88 
(88  
pathFileCode88  ,
)88, -
;88- .
Console:: 
.:: 
	WriteLine:: !
(::! "
)::" #
;::# $
Console;; 
.;; 
	WriteLine;; !
(;;! "
$str;;" 4
);;4 5
;;;5 6
Console<< 
.<< 
	WriteLine<< !
(<<! "
code<<" &
)<<& '
;<<' (
File>> 
.>> 
WriteAllText>> !
(>>! "
pathFileCode>>" .
,>>. /
code>>0 4
)>>4 5
;>>5 6
}?? 
catch@@ 
(@@ 
	Exception@@ 
e@@ 
)@@ 
{AA 
ConsoleBB 
.BB 
	WriteLineBB !
(BB! "
eBB" #
.BB# $
MessageBB$ +
)BB+ ,
;BB, -
ConsoleCC 
.CC 
	WriteLineCC !
(CC! "
eCC" #
.CC# $

StackTraceCC$ .
)CC. /
;CC/ 0
}DD 
}EE 	
}FF 
}GG Ã
:D:\Documents\GITrepos\Compil\Compil\Compil\Tokens\Token.cs
	namespace 	
Compil
 
{ 
public		 

class		 
Token		 
{

 
public 
string 
Name 
{ 
get  
;  !
set" %
;% &
}' (
public 
int 
Value 
{ 
get 
; 
set  #
;# $
}% &
public 
int 
Line 
{ 
get 
; 
set "
;" #
}$ %
public 
int 
Column 
{ 
get 
;  
set! $
;$ %
}& '
public 
	TokenType 
Type 
{ 
get  #
;# $
set% (
;( )
}* +
} 
} ˜
>D:\Documents\GITrepos\Compil\Compil\Compil\Tokens\TokenType.cs
	namespace 	
Compil
 
. 
Tokens 
{ 
public 

enum 
	TokenType 
{ 

IDENTIFIER 
, 
CONSTANT 
, 
END_OF_FILE		 
,		 
NOT 
, 
PLUS 
, 
MINUS 
, 
MULTIPLY 
, 
DIVIDE 
, 
MODULO 
, 
POWER 
, 
IF 

,
 
ELSE 
, 
FOR 
, 
WHILE 
, 
DO 

,
 
SWITCH 
, 
CASE 
, 
INT 
, 
VOID 
, 

COMP_EQUAL 
, 
COMP_DIFFERENT 
, 
COMP_SUPPERIOR   
,   
COMP_INFERIOR!! 
,!! #
COMP_SUPPERIOR_OR_EQUAL"" 
,""  "
COMP_INFERIOR_OR_EQUAL## 
,## 
PAR_OPEN%% 
,%% 
	PAR_CLOSE&& 
,&& 
OR(( 

,((
 
AND)) 
,)) 
EQUAL++ 
,++ 
BRACKET_OPEN.. 
,.. 
BRACKET_CLOSE// 
,// 
	SEMICOLON11 
,11 
COMA22 
,22 
COMMENT_LINE33 
,33 
COMMENT_BLOCK_START44 
,44 
COMMENT_BLOCK_END55 
,55 
VAR77 
}88 
}99 ·
<D:\Documents\GITrepos\Compil\Compil\Compil\Utils\Operator.cs
	namespace 	
Compil
 
. 
Utils 
{ 
public 

class 
Operator 
{ 
public 
Token 
Token 
{ 
get  
;  !
set" %
;% &
}' (
public 
Node 
Node 
{ 
get 
; 
set  #
;# $
}% &
public 
int 
Priority 
{ 
get !
;! "
set# &
;& '
}( )
public 
int 
Association 
{  
get! $
;$ %
set& )
;) *
}+ ,
}		 
}

 