⁄4
GD:\Documents\GITrepos\Compil\Compil\Compil\Analyzer\SemanticAnalyzer.cs
	namespace 	
Compil
 
{ 
public 

class 
SemanticAnalyzer !
{		 
private

 
int

 
_variablesCount

 #
=

$ %
$num

& '
;

' (
private 
readonly 
Stack 
< 

Dictionary )
<) *
string* 0
,0 1
Symbol2 8
>8 9
>9 :
_stack; A
=B C
newD G
StackH M
<M N

DictionaryN X
<X Y
stringY _
,_ `
Symbola g
>g h
>h i
(i j
)j k
;k l
public 
int 
VariablesCount !
{ 	
get 
=> 
_variablesCount "
;" #
set 
=> 
_variablesCount "
=# $
value% *
;* +
} 	
private 
void 

BeginBlock 
(  
)  !
{ 	
_stack 
. 
Push 
( 
new 

Dictionary &
<& '
string' -
,- .
Symbol/ 5
>5 6
(6 7
)7 8
)8 9
;9 :
} 	
private!! 
void!! 
EndBlock!! 
(!! 
)!! 
{"" 	
_stack## 
.## 
Pop## 
(## 
)## 
;## 
}$$ 	
private++ 
Symbol++ 
Declare++ 
(++ 
string++ %
id++& (
)++( )
{,, 	
var-- 
s-- 
=-- 
new-- 
Symbol-- 
(-- 
)--  
{--! "
Slot--# '
=--( )
_variablesCount--* 9
,--9 :
Id--; =
=--> ?
id--@ B
}--C D
;--D E
if// 
(// 
_stack// 
.// 
Peek// 
(// 
)// 
.// 
ContainsKey// )
(//) *
id//* ,
)//, -
)//- .
{00 
throw11 
new11 
	Exception11 #
(11# $
$"11$ &

Variable '11& 0
{110 1
id111 3
}113 40
$' is already declared in this scope.114 X
"11X Y
)11Y Z
;11Z [
}22 
_stack44 
.44 
Peek44 
(44 
)44 
.44 
Add44 
(44 
id44  
,44  !
s44" #
)44# $
;44$ %
return55 
s55 
;55 
}66 	
private== 
Symbol== 
Search== 
(== 
string== $
id==% '
)==' (
{>> 	
foreach?? 
(?? 
var?? 
symbolsTable?? %
in??& (
_stack??) /
)??/ 0
{@@ 
ifAA 
(AA 
symbolsTableAA  
.AA  !
TryGetValueAA! ,
(AA, -
idAA- /
,AA/ 0
outAA1 4
varAA5 8
valueAA9 >
)AA> ?
)AA? @
{BB 
returnCC 
valueCC  
;CC  !
}DD 
}EE 
throwFF 
newFF !
ArgumentNullExceptionFF +
(FF+ ,
$"FF, .

Variable 'FF. 8
{FF8 9
idFF9 ;
}FF; <
' does not exist.FF< M
"FFM N
)FFN O
;FFO P
}GG 	
publicMM 
voidMM 
AnalyzeMM 
(MM 
NodeMM  
nodeMM! %
)MM% &
{NN 	
switchOO 
(OO 
nodeOO 
.OO 
TypeOO 
)OO 
{PP 
defaultQQ 
:QQ 
foreachRR 
(RR 
varRR  
childRR! &
inRR' )
nodeRR* .
.RR. /
ChildrenRR/ 7
)RR7 8
{SS 
AnalyzeTT 
(TT  
childTT  %
)TT% &
;TT& '
}UU 
breakVV 
;VV 
caseWW 
NodeTypeWW 
.WW 
BLOCKWW #
:WW# $

BeginBlockXX 
(XX 
)XX  
;XX  !
foreachYY 
(YY 
varYY  
childYY! &
inYY' )
nodeYY* .
.YY. /
ChildrenYY/ 7
)YY7 8
{ZZ 
Analyze[[ 
([[  
child[[  %
)[[% &
;[[& '
}\\ 
EndBlock]] 
(]] 
)]] 
;]] 
break^^ 
;^^ 
case__ 
NodeType__ 
.__ 
DECLARE__ %
:__% &
var`` 
s1`` 
=`` 
Declare`` $
(``$ %
node``% )
.``) *
Children``* 2
[``2 3
$num``3 4
]``4 5
.``5 6
Value``6 ;
)``; <
;``< =
s1aa 
.aa 
Typeaa 
=aa 

SymbolTypeaa (
.aa( )
VARIABLEaa) 1
;aa1 2
s1bb 
.bb 
Slotbb 
=bb 
_variablesCountbb -
;bb- .
_variablesCountcc #
++cc# %
;cc% &
nodedd 
.dd 
Childrendd !
[dd! "
$numdd" #
]dd# $
.dd$ %
Slotdd% )
=dd* +
s1dd, .
.dd. /
Slotdd/ 3
;dd3 4
Analyzeee 
(ee 
nodeee  
.ee  !
Childrenee! )
[ee) *
$numee* +
]ee+ ,
)ee, -
;ee- .
breakff 
;ff 
casegg 
NodeTypegg 
.gg 
VARIABLEgg &
:gg& '
varhh 
s2hh 
=hh 
Searchhh #
(hh# $
nodehh$ (
.hh( )
Valuehh) .
)hh. /
;hh/ 0
ifii 
(ii 
s2ii 
.ii 
Typeii 
!=ii  "

SymbolTypeii# -
.ii- .
VARIABLEii. 6
)ii6 7
{jj 
throwkk 
newkk !!
ArgumentNullExceptionkk" 7
(kk7 8
$strkk8 Y
)kkY Z
;kkZ [
}ll 
nodenn 
.nn 
Slotnn 
=nn 
s2nn  "
.nn" #
Slotnn# '
;nn' (
breakoo 
;oo 
}pp 
}qq 	
}rr 
}ss àˇ
ED:\Documents\GITrepos\Compil\Compil\Compil\Analyzer\SyntaxAnalyzer.cs
	namespace 	
Compil
 
{ 
public 

class 
SyntaxAnalyzer 
{ 
private 
readonly 
LexicalAnalyzer (
_lexicalAnalyzer) 9
;9 :
private 
readonly 

Dictionary #
<# $
	TokenType$ -
,- .
(/ 0
NodeType0 8
,8 9
string: @
,@ A
intB E
,E F
intG J
)J K
>K L!
_exprTokenToNodeMatchM b
=c d
newe h

Dictionaryi s
<s t
	TokenTypet }
,} ~
(	 Ä
NodeType
Ä à
,
à â
string
ä ê
,
ê ë
int
í ï
,
ï ñ
int
ó ö
)
ö õ
>
õ ú
(
ú ù
)
ù û
{ 	
{ 
	TokenType 
. 
OR 
, 
( 
NodeType $
.$ %
OR% '
,' (
$str) ,
,, -
$num. /
,/ 0
$num1 2
)2 3
}3 4
,4 5
{ 
	TokenType 
. 
AND 
, 
( 
NodeType %
.% &
AND& )
,) *
$str+ .
,. /
$num0 1
,1 2
$num3 4
)4 5
}5 6
,6 7
{ 
	TokenType 
. 
NOT 
, 
( 
NodeType %
.% &
NOT& )
,) *
$str+ .
,. /
$num0 1
,1 2
$num3 4
)4 5
}5 6
,6 7
{ 
	TokenType 
. 

COMP_EQUAL !
,! "
(# $
NodeType$ ,
., -

COMP_EQUAL- 7
,7 8
$str9 =
,= >
$num? @
,@ A
$numB C
)C D
}D E
,E F
{ 
	TokenType 
. 
PLUS 
, 
( 
NodeType &
.& '
OP_PLUS' .
,. /
$str0 3
,3 4
$num5 6
,6 7
$num8 9
)9 :
}: ;
,; <
{ 
	TokenType 
. 
MINUS 
, 
( 
NodeType '
.' (
OP_MINUS( 0
,0 1
$str2 5
,5 6
$num7 8
,8 9
$num: ;
); <
}< =
,= >
{ 
	TokenType 
. 
POWER 
, 
( 
NodeType '
.' (
OP_POWER( 0
,0 1
$str2 5
,5 6
$num7 8
,8 9
$num: ;
); <
}< =
,= >
{ 
	TokenType 
. 
DIVIDE 
, 
(  
NodeType  (
.( )
	OP_DIVIDE) 2
,2 3
$str4 7
,7 8
$num9 :
,: ;
$num< =
)= >
}> ?
,? @
{ 
	TokenType 
. 
MODULO 
, 
(  
NodeType  (
.( )
	OP_MODULO) 2
,2 3
$str4 7
,7 8
$num9 :
,: ;
$num< =
)= >
}> ?
,? @
{ 
	TokenType 
. 
MULTIPLY 
,  
(! "
NodeType" *
.* +
OP_MULTIPLY+ 6
,6 7
$str8 ;
,; <
$num= >
,> ?
$num@ A
)A B
}B C
,C D
{ 
	TokenType 
. 
COMP_INFERIOR $
,$ %
(& '
NodeType' /
./ 0
COMP_INFERIOR0 =
,= >
$str? B
,B C
$numD E
,E F
$numG H
)H I
}I J
,J K
{ 
	TokenType 
. 
COMP_DIFFERENT %
,% &
(' (
NodeType( 0
.0 1
COMP_DIFFERENT1 ?
,? @
$strA E
,E F
$numG H
,H I
$numJ K
)K L
}L M
,M N
{ 
	TokenType 
. 
COMP_SUPPERIOR %
,% &
(' (
NodeType( 0
.0 1
COMP_SUPPERIOR1 ?
,? @
$strA D
,D E
$numF G
,G H
$numI J
)J K
}K L
,L M
{ 
	TokenType 
. "
COMP_INFERIOR_OR_EQUAL -
,- .
(/ 0
NodeType0 8
.8 9"
COMP_INFERIOR_OR_EQUAL9 O
,O P
$strQ U
,U V
$numW X
,X Y
$numZ [
)[ \
}\ ]
,] ^
{   
	TokenType   
.   #
COMP_SUPPERIOR_OR_EQUAL   .
,  . /
(  0 1
NodeType  1 9
.  9 :#
COMP_SUPPERIOR_OR_EQUAL  : Q
,  Q R
$str  S W
,  W X
$num  Y Z
,  Z [
$num  \ ]
)  ] ^
}  ^ _
,  _ `
{!! 
	TokenType!! 
.!! 
EQUAL!! 
,!! 
(!! 
NodeType!! '
.!!' (
AFFECT!!( .
,!!. /
$str!!0 3
,!!3 4
$num!!5 6
,!!6 7
$num!!8 9
)!!9 :
}!!: ;
}"" 	
;""	 

public(( 
SyntaxAnalyzer(( 
((( 
LexicalAnalyzer(( -
lexicalAnalyser((. =
)((= >
{)) 	
this** 
.** 
_lexicalAnalyzer** !
=**" #
lexicalAnalyser**$ 3
;**3 4
}++ 	
public00 
Node00 
Primary00 
(00 
)00 
{11 	
try22 
{33 
Node44 
node44 
;44 
if77 
(77 
_lexicalAnalyzer77 $
.77$ %
Next77% )
(77) *
)77* +
.77+ ,
Type77, 0
==771 3
	TokenType774 =
.77= >
CONSTANT77> F
)77F G
{88 
node99 
=99 
new99 
Node99 #
(99# $
)99$ %
{99& '
Type99( ,
=99- .
NodeType99/ 7
.997 8
CONSTANT998 @
,99@ A
Value99B G
=99H I
_lexicalAnalyzer99J Z
.99Z [
Next99[ _
(99_ `
)99` a
.99a b
Value99b g
.99g h
ToString99h p
(99p q
)99q r
}99s t
;99t u
_lexicalAnalyzer:: $
.::$ %
Skip::% )
(::) *
)::* +
;::+ ,
return;; 
node;; 
;;;  
}<< 
if?? 
(?? 
_lexicalAnalyzer?? $
.??$ %
Next??% )
(??) *
)??* +
.??+ ,
Type??, 0
==??1 3
	TokenType??4 =
.??= >
PAR_OPEN??> F
)??F G
{@@ 
_lexicalAnalyzerAA $
.AA$ %
SkipAA% )
(AA) *
)AA* +
;AA+ ,
nodeBB 
=BB 

ExpressionBB %
(BB% &
$numBB& '
)BB' (
;BB( )
_lexicalAnalyzerCC $
.CC$ %
AcceptCC% +
(CC+ ,
	TokenTypeCC, 5
.CC5 6
	PAR_CLOSECC6 ?
)CC? @
;CC@ A
returnDD 
nodeDD 
;DD  
}EE 
ifHH 
(HH 
_lexicalAnalyzerHH $
.HH$ %
NextHH% )
(HH) *
)HH* +
.HH+ ,
TypeHH, 0
==HH1 3
	TokenTypeHH4 =
.HH= >
MINUSHH> C
)HHC D
{II 
varJJ 
(JJ 
nodeTypeJJ !
,JJ! "
valJJ# &
,JJ& '
_JJ( )
,JJ) *
_JJ+ ,
)JJ, -
=JJ. /!
_exprTokenToNodeMatchJJ0 E
[JJE F
_lexicalAnalyzerJJF V
.JJV W
NextJJW [
(JJ[ \
)JJ\ ]
.JJ] ^
TypeJJ^ b
]JJb c
;JJc d
nodeKK 
=KK 
newKK 
NodeKK #
(KK# $
)KK$ %
{KK& '
TypeKK( ,
=KK- .
NodeTypeKK/ 7
.KK7 8
MINUSKK8 =
,KK= >
ValueKK? D
=KKE F
valKKG J
}KKK L
;KKL M
_lexicalAnalyzerLL $
.LL$ %
SkipLL% )
(LL) *
)LL* +
;LL+ ,
nodeMM 
.MM 
AddChildMM !
(MM! "

ExpressionMM" ,
(MM, -
$numMM- .
)MM. /
)MM/ 0
;MM0 1
returnNN 
nodeNN 
;NN  
}OO 
ifQQ 
(QQ 
_lexicalAnalyzerQQ $
.QQ$ %
NextQQ% )
(QQ) *
)QQ* +
.QQ+ ,
TypeQQ, 0
==QQ1 3
	TokenTypeQQ4 =
.QQ= >
PLUSQQ> B
)QQB C
{RR 
varSS 
(SS 
nodeTypeSS !
,SS! "
valSS# &
,SS& '
_SS( )
,SS) *
_SS+ ,
)SS, -
=SS. /!
_exprTokenToNodeMatchSS0 E
[SSE F
_lexicalAnalyzerSSF V
.SSV W
NextSSW [
(SS[ \
)SS\ ]
.SS] ^
TypeSS^ b
]SSb c
;SSc d
nodeTT 
=TT 
newTT 
NodeTT #
(TT# $
)TT$ %
{TT& '
TypeTT( ,
=TT- .
NodeTypeTT/ 7
.TT7 8
PLUSTT8 <
,TT< =
ValueTT> C
=TTD E
valTTF I
}TTJ K
;TTK L
_lexicalAnalyzerUU $
.UU$ %
SkipUU% )
(UU) *
)UU* +
;UU+ ,
nodeVV 
.VV 
AddChildVV !
(VV! "

ExpressionVV" ,
(VV, -
$numVV- .
)VV. /
)VV/ 0
;VV0 1
returnWW 
nodeWW 
;WW  
}XX 
if[[ 
([[ 
_lexicalAnalyzer[[ $
.[[$ %
Next[[% )
([[) *
)[[* +
.[[+ ,
Type[[, 0
==[[1 3
	TokenType[[4 =
.[[= >
NOT[[> A
)[[A B
{\\ 
var]] 
(]] 
nodeType]] !
,]]! "
val]]# &
,]]& '
_]]( )
,]]) *
_]]+ ,
)]], -
=]]. /!
_exprTokenToNodeMatch]]0 E
[]]E F
_lexicalAnalyzer]]F V
.]]V W
Next]]W [
(]][ \
)]]\ ]
.]]] ^
Type]]^ b
]]]b c
;]]c d
node^^ 
=^^ 
new^^ 
Node^^ #
(^^# $
)^^$ %
{^^& '
Type^^( ,
=^^- .
NodeType^^/ 7
.^^7 8
NOT^^8 ;
,^^; <
Value^^= B
=^^C D
val^^E H
}^^I J
;^^J K
_lexicalAnalyzer__ $
.__$ %
Skip__% )
(__) *
)__* +
;__+ ,
node`` 
.`` 
AddChild`` !
(``! "

Expression``" ,
(``, -
$num``- .
)``. /
)``/ 0
;``0 1
returnaa 
nodeaa 
;aa  
}bb 
ifff 
(ff 
_lexicalAnalyzerff $
.ff$ %
Nextff% )
(ff) *
)ff* +
.ff+ ,
Typeff, 0
==ff1 3
	TokenTypeff4 =
.ff= >

IDENTIFIERff> H
)ffH I
{gg 
nodehh 
=hh 
newhh 
Nodehh #
(hh# $
)hh$ %
{hh& '
Typehh( ,
=hh- .
NodeTypehh/ 7
.hh7 8
VARIABLEhh8 @
,hh@ A
ValuehhB G
=hhH I
_lexicalAnalyzerhhJ Z
.hhZ [
Nexthh[ _
(hh_ `
)hh` a
.hha b
Namehhb f
.hhf g
ToStringhhg o
(hho p
)hhp q
}hhr s
;hhs t
_lexicalAnalyzerii $
.ii$ %
Skipii% )
(ii) *
)ii* +
;ii+ ,
returnjj 
nodejj 
;jj  
}kk 
thrownn 
newnn !
ArgumentNullExceptionnn /
(nn/ 0
$strnn0 C
)nnC D
;nnD E
}oo 
catchpp 
(pp #
NotImplementedExceptionpp *
epp+ ,
)pp, -
{qq 
Consolerr 
.rr 
	WriteLinerr !
(rr! "
$strrr" <
)rr< =
;rr= >
Consoless 
.ss 
	WriteLiness !
(ss! "
ess" #
.ss# $

StackTracess$ .
)ss. /
;ss/ 0
returntt 
nulltt 
;tt 
}uu 
catchvv 
(vv !
ArgumentNullExceptionvv (
evv) *
)vv* +
{ww 
Consolexx 
.xx 
	WriteLinexx !
(xx! "
exx" #
.xx# $
Messagexx$ +
)xx+ ,
;xx, -
Consoleyy 
.yy 
	WriteLineyy !
(yy! "
eyy" #
.yy# $

StackTraceyy$ .
)yy. /
;yy/ 0
returnzz 
nullzz 
;zz 
}{{ 
}|| 	
public
ÉÉ 
Node
ÉÉ 

Expression
ÉÉ 
(
ÉÉ 
int
ÉÉ "
pMin
ÉÉ# '
=
ÉÉ( )
$num
ÉÉ* +
)
ÉÉ+ ,
{
ÑÑ 	
var
ÖÖ 
leftNode
ÖÖ 
=
ÖÖ 
Primary
ÖÖ "
(
ÖÖ" #
)
ÖÖ# $
;
ÖÖ$ %
while
áá 
(
áá 
true
áá 
)
áá 
{
àà 
if
ââ 
(
ââ 
_lexicalAnalyzer
ââ $
.
ââ$ %
Next
ââ% )
(
ââ) *
)
ââ* +
==
ââ, .
null
ââ/ 3
)
ââ3 4
return
ää 
leftNode
ää #
;
ää# $
var
åå 
op
åå 
=
åå 
SearchOp
åå !
(
åå! "
_lexicalAnalyzer
åå" 2
.
åå2 3
Next
åå3 7
(
åå7 8
)
åå8 9
)
åå9 :
;
åå: ;
if
éé 
(
éé 
op
éé 
==
éé 
null
éé 
||
éé !
op
éé" $
.
éé$ %
Priority
éé% -
<
éé. /
pMin
éé0 4
)
éé4 5
return
èè 
leftNode
èè #
;
èè# $
_lexicalAnalyzer
ëë  
.
ëë  !
Skip
ëë! %
(
ëë% &
)
ëë& '
;
ëë' (
var
íí 
	rightNode
íí 
=
íí 

Expression
íí  *
(
íí* +
op
íí+ -
.
íí- .
Priority
íí. 6
+
íí7 8
op
íí9 ;
.
íí; <
Association
íí< G
)
ííG H
;
ííH I
var
ìì 
tree
ìì 
=
ìì 
new
ìì 
Node
ìì #
(
ìì# $
)
ìì$ %
{
ìì& '
Type
ìì( ,
=
ìì- .
op
ìì/ 1
.
ìì1 2
Node
ìì2 6
.
ìì6 7
Type
ìì7 ;
}
ìì< =
;
ìì= >
tree
îî 
.
îî 
AddChild
îî 
(
îî 
leftNode
îî &
)
îî& '
;
îî' (
tree
ïï 
.
ïï 
AddChild
ïï 
(
ïï 
	rightNode
ïï '
)
ïï' (
;
ïï( )
leftNode
ññ 
=
ññ 
tree
ññ 
;
ññ  
}
óó 
}
òò 	
public
üü 
Operator
üü 
SearchOp
üü  
(
üü  !
Token
üü! &
token
üü' ,
)
üü, -
{
†† 	
if
°° 
(
°° #
_exprTokenToNodeMatch
°° %
.
°°% &
TryGetValue
°°& 1
(
°°1 2
token
°°2 7
.
°°7 8
Type
°°8 <
,
°°< =
out
°°> A
var
°°B E
vals
°°F J
)
°°J K
)
°°K L
{
¢¢ 
var
££ 
(
££ 
nodetype
££ 
,
££ 
val
££ "
,
££" #
priority
££$ ,
,
££, -
assos
££. 3
)
££3 4
=
££5 6
vals
££7 ;
;
££; <
return
§§ 
new
§§ 
Operator
§§ #
(
§§# $
)
§§$ %
{
§§& '
Token
§§( -
=
§§. /
token
§§0 5
,
§§5 6
Node
§§7 ;
=
§§< =
new
§§> A
Node
§§B F
(
§§F G
)
§§G H
{
§§I J
Type
§§K O
=
§§P Q
nodetype
§§R Z
}
§§[ \
,
§§\ ]
Priority
§§^ f
=
§§g h
priority
§§i q
,
§§q r
Association
§§s ~
=§§ Ä
assos§§Å Ü
}§§á à
;§§à â
}
•• 
return
¶¶ 
null
¶¶ 
;
¶¶ 
}
ßß 	
public
≠≠ 
Node
≠≠ 
Instruction
≠≠ 
(
≠≠  
)
≠≠  !
{
ÆÆ 	
if
ØØ 
(
ØØ 
_lexicalAnalyzer
ØØ  
.
ØØ  !
Next
ØØ! %
(
ØØ% &
)
ØØ& '
.
ØØ' (
Type
ØØ( ,
==
ØØ- /
	TokenType
ØØ0 9
.
ØØ9 :
IF
ØØ: <
)
ØØ< =
{
∞∞ 
_lexicalAnalyzer
±±  
.
±±  !
Skip
±±! %
(
±±% &
)
±±& '
;
±±' (
_lexicalAnalyzer
≤≤  
.
≤≤  !
Accept
≤≤! '
(
≤≤' (
	TokenType
≤≤( 1
.
≤≤1 2
PAR_OPEN
≤≤2 :
)
≤≤: ;
;
≤≤; <
var
≥≥ 
aTest
≥≥ 
=
≥≥ 

Expression
≥≥ &
(
≥≥& '
)
≥≥' (
;
≥≥( )
_lexicalAnalyzer
¥¥  
.
¥¥  !
Accept
¥¥! '
(
¥¥' (
	TokenType
¥¥( 1
.
¥¥1 2
	PAR_CLOSE
¥¥2 ;
)
¥¥; <
;
¥¥< =
var
µµ 
aCode
µµ 
=
µµ 
Instruction
µµ '
(
µµ' (
)
µµ( )
;
µµ) *
var
∂∂ 
node
∂∂ 
=
∂∂ 
new
∂∂ 
Node
∂∂ #
(
∂∂# $
)
∂∂$ %
{
∂∂& '
Type
∂∂' +
=
∂∂, -
NodeType
∂∂. 6
.
∂∂6 7
	CONDITION
∂∂7 @
}
∂∂@ A
;
∂∂A B
node
∑∑ 
.
∑∑ 
AddChild
∑∑ 
(
∑∑ 
aTest
∑∑ #
)
∑∑# $
;
∑∑$ %
node
∏∏ 
.
∏∏ 
AddChild
∏∏ 
(
∏∏ 
aCode
∏∏ #
)
∏∏# $
;
∏∏$ %
if
∫∫ 
(
∫∫ 
_lexicalAnalyzer
∫∫ #
.
∫∫# $
Next
∫∫$ (
(
∫∫( )
)
∫∫) *
.
∫∫* +
Type
∫∫+ /
==
∫∫0 2
	TokenType
∫∫3 <
.
∫∫< =
ELSE
∫∫= A
)
∫∫A B
{
ªª 
_lexicalAnalyzer
ºº $
.
ºº$ %
Skip
ºº% )
(
ºº) *
)
ºº* +
;
ºº+ ,
var
ΩΩ 
aElse
ΩΩ 
=
ΩΩ 
Instruction
ΩΩ  +
(
ΩΩ+ ,
)
ΩΩ, -
;
ΩΩ- .
node
ææ 
.
ææ 
AddChild
ææ !
(
ææ! "
aElse
ææ" '
)
ææ' (
;
ææ( )
}
øø 
return
¡¡ 
node
¡¡ 
;
¡¡ 
}
¬¬ 
else
√√ 
if
√√ 
(
√√ 
_lexicalAnalyzer
√√ %
.
√√% &
Next
√√& *
(
√√* +
)
√√+ ,
.
√√, -
Type
√√- 1
==
√√2 4
	TokenType
√√5 >
.
√√> ?
FOR
√√? B
)
√√B C
{
ƒƒ 
_lexicalAnalyzer
≈≈  
.
≈≈  !
Skip
≈≈! %
(
≈≈% &
)
≈≈& '
;
≈≈' (
_lexicalAnalyzer
∆∆  
.
∆∆  !
Accept
∆∆! '
(
∆∆' (
	TokenType
∆∆( 1
.
∆∆1 2
PAR_OPEN
∆∆2 :
)
∆∆: ;
;
∆∆; <
Node
…… 
	initValue
…… 
=
……  

Expression
……! +
(
……+ ,
)
……, -
;
……- .
_lexicalAnalyzer
    
.
    !
Accept
  ! '
(
  ' (
	TokenType
  ( 1
.
  1 2
	SEMICOLON
  2 ;
)
  ; <
;
  < =
Node
ÀÀ 
	condition
ÀÀ 
=
ÀÀ  

Expression
ÀÀ! +
(
ÀÀ+ ,
)
ÀÀ, -
;
ÀÀ- .
_lexicalAnalyzer
ÃÃ  
.
ÃÃ  !
Accept
ÃÃ! '
(
ÃÃ' (
	TokenType
ÃÃ( 1
.
ÃÃ1 2
	SEMICOLON
ÃÃ2 ;
)
ÃÃ; <
;
ÃÃ< =
Node
ÕÕ 
step
ÕÕ 
=
ÕÕ 

Expression
ÕÕ &
(
ÕÕ& '
)
ÕÕ' (
;
ÕÕ( )
_lexicalAnalyzer
ŒŒ  
.
ŒŒ  !
Accept
ŒŒ! '
(
ŒŒ' (
	TokenType
ŒŒ( 1
.
ŒŒ1 2
	PAR_CLOSE
ŒŒ2 ;
)
ŒŒ; <
;
ŒŒ< =
Node
—— 
block
—— 
=
—— 
Instruction
—— (
(
——( )
)
——) *
;
——* +
Node
”” 
loopNode
”” 
=
”” 
new
””  #
Node
””$ (
(
””( )
)
””) *
{
””+ ,
Type
””, 0
=
””1 2
NodeType
””3 ;
.
””; <
LOOP
””< @
}
””@ A
;
””A B
Node
‘‘ 
conditionNode
‘‘ "
=
‘‘# $
new
‘‘% (
Node
‘‘) -
(
‘‘- .
)
‘‘. /
{
‘‘0 1
Type
‘‘1 5
=
‘‘6 7
NodeType
‘‘8 @
.
‘‘@ A
	CONDITION
‘‘A J
}
‘‘J K
;
‘‘K L
Node
’’ 
variableBlock
’’ "
=
’’# $
new
’’% (
Node
’’) -
(
’’- .
)
’’. /
{
’’0 1
Type
’’1 5
=
’’6 7
NodeType
’’8 @
.
’’@ A
BLOCK
’’A F
}
’’F G
;
’’G H
Node
÷÷ 
loopBlockNode
÷÷ "
=
÷÷# $
new
÷÷% (
Node
÷÷) -
(
÷÷- .
)
÷÷. /
{
÷÷0 1
Type
÷÷2 6
=
÷÷7 8
NodeType
÷÷9 A
.
÷÷A B
BLOCK
÷÷B G
}
÷÷G H
;
÷÷H I
Node
◊◊ 
	breakLoop
◊◊ 
=
◊◊  
new
◊◊! $
Node
◊◊% )
(
◊◊) *
)
◊◊* +
{
◊◊, -
Type
◊◊- 1
=
◊◊2 3
NodeType
◊◊4 <
.
◊◊< =
BREAK
◊◊= B
}
◊◊B C
;
◊◊C D
variableBlock
ŸŸ 
.
ŸŸ 
AddChild
ŸŸ &
(
ŸŸ& '
	initValue
ŸŸ' 0
)
ŸŸ0 1
;
ŸŸ1 2
variableBlock
⁄⁄ 
.
⁄⁄ 
AddChild
⁄⁄ &
(
⁄⁄& '
loopNode
⁄⁄' /
)
⁄⁄/ 0
;
⁄⁄0 1
loopNode
‹‹ 
.
‹‹ 
AddChild
‹‹ !
(
‹‹! "
conditionNode
‹‹" /
)
‹‹/ 0
;
‹‹0 1
conditionNode
ﬁﬁ 
.
ﬁﬁ 
AddChild
ﬁﬁ &
(
ﬁﬁ& '
	condition
ﬁﬁ' 0
)
ﬁﬁ0 1
;
ﬁﬁ1 2
conditionNode
ﬂﬂ 
.
ﬂﬂ 
AddChild
ﬂﬂ &
(
ﬂﬂ& '
loopBlockNode
ﬂﬂ' 4
)
ﬂﬂ4 5
;
ﬂﬂ5 6
conditionNode
‡‡ 
.
‡‡ 
AddChild
‡‡ &
(
‡‡& '
	breakLoop
‡‡' 0
)
‡‡0 1
;
‡‡1 2
loopBlockNode
‚‚ 
.
‚‚ 
AddChild
‚‚ &
(
‚‚& '
block
‚‚' ,
)
‚‚, -
;
‚‚- .
loopBlockNode
„„ 
.
„„ 
AddChild
„„ &
(
„„& '
step
„„' +
)
„„+ ,
;
„„, -
return
ÂÂ 
variableBlock
ÂÂ $
;
ÂÂ$ %
}
ÊÊ 
else
ÁÁ 
if
ÁÁ 
(
ÁÁ 
_lexicalAnalyzer
ÁÁ $
.
ÁÁ$ %
Next
ÁÁ% )
(
ÁÁ) *
)
ÁÁ* +
.
ÁÁ+ ,
Type
ÁÁ, 0
==
ÁÁ1 3
	TokenType
ÁÁ4 =
.
ÁÁ= >
WHILE
ÁÁ> C
)
ÁÁC D
{
ËË 
_lexicalAnalyzer
ÈÈ  
.
ÈÈ  !
Skip
ÈÈ! %
(
ÈÈ% &
)
ÈÈ& '
;
ÈÈ' (
_lexicalAnalyzer
ÍÍ  
.
ÍÍ  !
Accept
ÍÍ! '
(
ÍÍ' (
	TokenType
ÍÍ( 1
.
ÍÍ1 2
PAR_OPEN
ÍÍ2 :
)
ÍÍ: ;
;
ÍÍ; <
var
ÎÎ 
aTest
ÎÎ 
=
ÎÎ 

Expression
ÎÎ &
(
ÎÎ& '
)
ÎÎ' (
;
ÎÎ( )
_lexicalAnalyzer
ÏÏ  
.
ÏÏ  !
Accept
ÏÏ! '
(
ÏÏ' (
	TokenType
ÏÏ( 1
.
ÏÏ1 2
	PAR_CLOSE
ÏÏ2 ;
)
ÏÏ; <
;
ÏÏ< =
var
ÌÌ 
aCode
ÌÌ 
=
ÌÌ 
Instruction
ÌÌ '
(
ÌÌ' (
)
ÌÌ( )
;
ÌÌ) *
var
ÓÓ 
node
ÓÓ 
=
ÓÓ 
new
ÓÓ 
Node
ÓÓ #
(
ÓÓ# $
)
ÓÓ$ %
{
ÓÓ& '
Type
ÓÓ( ,
=
ÓÓ- .
NodeType
ÓÓ/ 7
.
ÓÓ7 8
LOOP
ÓÓ8 <
}
ÓÓ= >
;
ÓÓ> ?
var
ÔÔ 
cond
ÔÔ 
=
ÔÔ 
new
ÔÔ 
Node
ÔÔ #
(
ÔÔ# $
)
ÔÔ$ %
{
ÔÔ& '
Type
ÔÔ' +
=
ÔÔ, -
NodeType
ÔÔ. 6
.
ÔÔ6 7
	CONDITION
ÔÔ7 @
}
ÔÔ@ A
;
ÔÔA B
cond
 
.
 
AddChild
 
(
 
aTest
 #
)
# $
;
$ %
cond
ÒÒ 
.
ÒÒ 
AddChild
ÒÒ 
(
ÒÒ 
aCode
ÒÒ #
)
ÒÒ# $
;
ÒÒ$ %
cond
ÚÚ 
.
ÚÚ 
AddChild
ÚÚ 
(
ÚÚ 
new
ÚÚ !
Node
ÚÚ" &
(
ÚÚ& '
)
ÚÚ' (
{
ÚÚ) *
Type
ÚÚ+ /
=
ÚÚ0 1
NodeType
ÚÚ2 :
.
ÚÚ: ;
BREAK
ÚÚ; @
}
ÚÚA B
)
ÚÚB C
;
ÚÚC D
node
ÙÙ 
.
ÙÙ 
AddChild
ÙÙ 
(
ÙÙ 
cond
ÙÙ "
)
ÙÙ" #
;
ÙÙ# $
return
ıı 
node
ıı 
;
ıı 
}
ˆˆ 
else
˜˜ 
if
˜˜ 
(
˜˜ 
_lexicalAnalyzer
˜˜ %
.
˜˜% &
Next
˜˜& *
(
˜˜* +
)
˜˜+ ,
.
˜˜, -
Type
˜˜- 1
==
˜˜2 4
	TokenType
˜˜5 >
.
˜˜> ?
BRACKET_OPEN
˜˜? K
)
˜˜K L
{
¯¯ 
var
˘˘ 
node
˘˘ 
=
˘˘ 
new
˘˘ 
Node
˘˘ #
(
˘˘# $
)
˘˘$ %
{
˘˘& '
Type
˘˘' +
=
˘˘, -
NodeType
˘˘. 6
.
˘˘6 7
BLOCK
˘˘7 <
}
˘˘< =
;
˘˘= >
_lexicalAnalyzer
˙˙  
.
˙˙  !
Accept
˙˙! '
(
˙˙' (
	TokenType
˙˙( 1
.
˙˙1 2
BRACKET_OPEN
˙˙2 >
)
˙˙> ?
;
˙˙? @
while
˚˚ 
(
˚˚ 
_lexicalAnalyzer
˚˚ '
.
˚˚' (
Next
˚˚( ,
(
˚˚, -
)
˚˚- .
.
˚˚. /
Type
˚˚/ 3
!=
˚˚4 6
	TokenType
˚˚7 @
.
˚˚@ A
BRACKET_CLOSE
˚˚A N
)
˚˚N O
{
¸¸ 
var
˝˝ 
x
˝˝ 
=
˝˝ 
Instruction
˝˝ '
(
˝˝' (
)
˝˝( )
;
˝˝) *
node
˛˛ 
.
˛˛ 
AddChild
˛˛ !
(
˛˛! "
x
˛˛" #
)
˛˛# $
;
˛˛$ %
}
ˇˇ 
_lexicalAnalyzer
ÄÄ  
.
ÄÄ  !
Accept
ÄÄ! '
(
ÄÄ' (
	TokenType
ÄÄ( 1
.
ÄÄ1 2
BRACKET_CLOSE
ÄÄ2 ?
)
ÄÄ? @
;
ÄÄ@ A
return
ÅÅ 
node
ÅÅ 
;
ÅÅ 
}
ÇÇ 
else
ÉÉ 
if
ÉÉ 
(
ÉÉ 
_lexicalAnalyzer
ÉÉ %
.
ÉÉ% &
Next
ÉÉ& *
(
ÉÉ* +
)
ÉÉ+ ,
.
ÉÉ, -
Type
ÉÉ- 1
==
ÉÉ2 4
	TokenType
ÉÉ5 >
.
ÉÉ> ?
VAR
ÉÉ? B
)
ÉÉB C
{
ÉÉD E
_lexicalAnalyzer
ÑÑ  
.
ÑÑ  !
Skip
ÑÑ! %
(
ÑÑ% &
)
ÑÑ& '
;
ÑÑ' (
if
ÖÖ 
(
ÖÖ 
_lexicalAnalyzer
ÖÖ $
.
ÖÖ$ %
Next
ÖÖ% )
(
ÖÖ) *
)
ÖÖ* +
.
ÖÖ+ ,
Type
ÖÖ, 0
==
ÖÖ1 3
	TokenType
ÖÖ4 =
.
ÖÖ= >

IDENTIFIER
ÖÖ> H
)
ÖÖH I
{
ÖÖJ K
var
ÜÜ 
variableName
ÜÜ $
=
ÜÜ% &
_lexicalAnalyzer
ÜÜ' 7
.
ÜÜ7 8
Next
ÜÜ8 <
(
ÜÜ< =
)
ÜÜ= >
.
ÜÜ> ?
Name
ÜÜ? C
;
ÜÜC D
var
áá 
nodeVariable
áá $
=
áá% &
new
áá' *
Node
áá+ /
(
áá/ 0
)
áá0 1
{
áá2 3
Type
áá4 8
=
áá9 :
NodeType
áá; C
.
ááC D
DECLARE
ááD K
}
ááL M
;
ááM N
nodeVariable
àà  
.
àà  !
AddChild
àà! )
(
àà) *
new
àà* -
Node
àà. 2
(
àà2 3
)
àà3 4
{
àà5 6
Type
àà6 :
=
àà; <
NodeType
àà= E
.
ààE F
VARIABLE
ààF N
,
ààN O
Value
ààP U
=
ààV W
variableName
ààX d
}
ààd e
)
ààe f
;
ààf g
var
ââ 
ex
ââ 
=
ââ 

Expression
ââ '
(
ââ' (
)
ââ( )
;
ââ) *
_lexicalAnalyzer
ãã $
.
ãã$ %
Accept
ãã% +
(
ãã+ ,
	TokenType
ãã, 5
.
ãã5 6
	SEMICOLON
ãã6 ?
)
ãã? @
;
ãã@ A
if
çç 
(
çç 
ex
çç 
.
çç 
Type
çç 
!=
çç  "
NodeType
çç# +
.
çç+ ,
AFFECT
çç, 2
)
çç2 3
{
çç4 5
if
éé 
(
éé 
ex
éé 
.
éé 
Children
éé &
.
éé& '
Count
éé' ,
!=
éé- /
$num
éé0 1
)
éé1 2
throw
èè !
new
èè" %
	Exception
èè& /
(
èè/ 0
$str
èè0 @
)
èè@ A
;
èèA B
}
êê 
nodeVariable
íí  
.
íí  !
AddChild
íí! )
(
íí) *
ex
íí* ,
)
íí, -
;
íí- .
return
îî 
nodeVariable
îî '
;
îî' (
}
ïï 
_lexicalAnalyzer
óó  
.
óó  !
Accept
óó! '
(
óó' (
	TokenType
óó( 1
.
óó1 2
	SEMICOLON
óó2 ;
)
óó; <
;
óó< =
throw
òò 
new
òò 
	Exception
òò #
(
òò# $
$str
òò$ ;
)
òò; <
;
òò< =
}
ôô 
else
öö 
{
õõ 
var
úú 
ex
úú 
=
úú 

Expression
úú #
(
úú# $
)
úú$ %
;
úú% &
_lexicalAnalyzer
ùù  
.
ùù  !
Accept
ùù! '
(
ùù' (
	TokenType
ùù( 1
.
ùù1 2
	SEMICOLON
ùù2 ;
)
ùù; <
;
ùù< =
var
ûû 
node
ûû 
=
ûû 
new
ûû 
Node
ûû #
(
ûû# $
)
ûû$ %
{
ûû& '
Type
ûû' +
=
ûû, -
NodeType
ûû. 6
.
ûû6 7

EXPRESSION
ûû7 A
}
ûûA B
;
ûûB C
node
üü 
.
üü 
AddChild
üü 
(
üü 
ex
üü  
)
üü  !
;
üü! "
return
†† 
node
†† 
;
†† 
}
°° 
}
¢¢ 	
}
££ 
}§§ Ú
8D:\Documents\GITrepos\Compil\Compil\Compil\Compilator.cs
	namespace 	
Compil
 
{ 
public 

class 

Compilator 
{		 
public

 
void

 
Compile

 
(

 
string

 "
	inputCode

# ,
,

, -
string

. 4

outputPath

5 ?
)

? @
{ 	
var 
lexicalAnalyser 
=  !
new" %
LexicalAnalyzer& 5
(5 6
	inputCode6 ?
,? @
$numA B
)B C
;C D
var 
syntaxAnalyzer 
=  
new! $
SyntaxAnalyzer% 3
(3 4
lexicalAnalyser4 C
)C D
;D E
var 

fileWriter 
= 
new  

FileWriter! +
(+ ,
), -
;- .
var 
node 
= 
syntaxAnalyzer %
.% &

Expression& 0
(0 1
$num1 2
)2 3
;3 4
var 
semanticAnalyzer  
=! "
new# &
SemanticAnalyzer' 7
(7 8
)8 9
;9 :
var 
codeGenerator 
= 
new  #
CodeGenerator$ 1
(1 2
semanticAnalyzer2 B
,B C

fileWriterD N
)N O
;O P
codeGenerator 
. 
GenerateCode &
(& '
node' +
)+ ,
;, -
} 	
} 
} Å
ND:\Documents\GITrepos\Compil\Compil\Compil\Exceptions\NotValidCharException.cs
	namespace 	
Compil
 
. 

Exceptions 
{ 
class 	!
NotValidCharException
 
{ 
public !
NotValidCharException $
($ %
)% &
{		 	
} 	
} 
} Ôä
ED:\Documents\GITrepos\Compil\Compil\Compil\Generator\CodeGenerator.cs
	namespace 	
Compil
 
. 
	Generator 
{ 
public 

class 
CodeGenerator 
{		 
private 
readonly 

FileWriter #
_fileWriter$ /
;/ 0
private 
int 
	countLoop 
; 
private 
int 

countLabel 
; 
private 
readonly 
Stack 
< 
int "
>" #

_stackLoop$ .
=/ 0
new1 4
Stack5 :
<: ;
int; >
>> ?
(? @
)@ A
;A B
private 
readonly 

Dictionary #
<# $
NodeType$ ,
,, -
string. 4
>4 5
_operatorsToCode6 F
=G H
newI L

DictionaryM W
<W X
NodeTypeX `
,` a
stringb h
>h i
(i j
)j k
{ 	
{ 
NodeType 
. 
OP_PLUS 
, 
$str  %
}& '
,' (
{ 
NodeType 
. 
OP_MINUS 
,  
$str! &
}' (
,( )
{ 
NodeType 
. 
OP_MULTIPLY "
," #
$str$ )
}* +
,+ ,
{ 
NodeType 
. 
	OP_DIVIDE  
,  !
$str" '
}( )
,) *
{ 
NodeType 
. 
	OP_MODULO  
,  !
$str" '
}( )
,) *
{ 
NodeType 
. 
AND 
, 
$str !
}" #
,# $
{ 
NodeType 
. 
OR 
, 
$str 
}  !
} 	
;	 

public   
CodeGenerator   
(   
SemanticAnalyzer   -
semanticAnalyzer  . >
,  > ?

FileWriter  @ J

fileWriter  K U
)  U V
{!! 	
_fileWriter"" 
="" 

fileWriter"" $
;""$ %
	countLoop## 
=## 
$num## 
;## 

countLabel$$ 
=$$ 
$num$$ 
;$$ 
_fileWriter%% 
.%% 
WriteCommand%% $
(%%$ %
$str%%% ,
+%%- .
semanticAnalyzer%%/ ?
.%%? @
VariablesCount%%@ N
)%%N O
;%%O P
}&& 	
public.. 
void.. 
GenerateCode..  
(..  !
Node..! %
node..& *
)..* +
{// 	
if11 
(11 
node11 
.11 
Type11 
==11 
NodeType11 %
.11% &
CONSTANT11& .
)11. /
{22 
_fileWriter33 
.33 
WriteCommand33 (
(33( )
$str33) 0
+331 2
node332 6
.336 7
Value337 <
,33< =
true33> B
)33B C
;33C D
}44 
if77 
(77 
_operatorsToCode77  
.77  !
ContainsKey77! ,
(77, -
node77- 1
.771 2
Type772 6
)776 7
)777 8
{88 
GenerateCode99 
(99 
node99 !
.99! "
Children99" *
[99* +
$num99+ ,
]99, -
)99- .
;99. /
GenerateCode:: 
(:: 
node:: !
.::! "
Children::" *
[::* +
$num::+ ,
]::, -
)::- .
;::. /
_fileWriter;; 
.;; 
WriteCommand;; (
(;;( )
_operatorsToCode;;) 9
[;;9 :
node;;: >
.;;> ?
Type;;? C
];;C D
,;;D E
true;;F J
);;J K
;;;K L
}<< 
switch?? 
(?? 
node?? 
.?? 
Type?? 
)?? 
{@@ 
caseBB 
NodeTypeBB 
.BB 
MINUSBB #
:BB# $
_fileWriterCC 
.CC  
WriteCommandCC  ,
(CC, -
$strCC- 5
,CC5 6
trueCC7 ;
)CC; <
;CC< =
GenerateCodeDD  
(DD  !
nodeDD! %
.DD% &
ChildrenDD& .
[DD. /
$numDD/ 0
]DD0 1
)DD1 2
;DD2 3
_fileWriterEE 
.EE  
WriteCommandEE  ,
(EE, -
$strEE- 2
,EE2 3
trueEE4 8
)EE8 9
;EE9 :
breakFF 
;FF 
caseGG 
NodeTypeGG 
.GG 
PLUSGG "
:GG" #
_fileWriterHH 
.HH  
WriteCommandHH  ,
(HH, -
$strHH- 5
,HH5 6
trueHH7 ;
)HH; <
;HH< =
GenerateCodeII  
(II  !
nodeII! %
.II% &
ChildrenII& .
[II. /
$numII/ 0
]II0 1
)II1 2
;II2 3
_fileWriterJJ 
.JJ  
WriteCommandJJ  ,
(JJ, -
$strJJ- 2
,JJ2 3
trueJJ4 8
)JJ8 9
;JJ9 :
breakKK 
;KK 
caseLL 
NodeTypeLL 
.LL 
NOTLL !
:LL! "
GenerateCodeMM  
(MM  !
nodeMM! %
.MM% &
ChildrenMM& .
[MM. /
$numMM/ 0
]MM0 1
)MM1 2
;MM2 3
_fileWriterNN 
.NN  
WriteCommandNN  ,
(NN, -
$strNN- 2
,NN2 3
falseNN4 9
)NN9 :
;NN: ;
breakOO 
;OO 
}PP 
ifSS 
(SS 
nodeSS 
.SS 
TypeSS 
==SS 
NodeTypeSS %
.SS% &
VARIABLESS& .
)SS. /
{TT 
_fileWriterUU 
.UU 
WriteCommandUU (
(UU( )
$"UU) +
get UU+ /
{UU/ 0
nodeUU0 4
.UU4 5
SlotUU5 9
}UU9 :
"UU: ;
,UU; <
trueUU= A
)UUA B
;UUB C
}VV 
ifXX 
(XX 
nodeXX 
.XX 
TypeXX 
==XX 
NodeTypeXX %
.XX% &
AFFECTXX& ,
)XX, -
{YY 
GenerateCodeZZ 
(ZZ 
nodeZZ !
.ZZ! "
ChildrenZZ" *
[ZZ* +
$numZZ+ ,
]ZZ, -
)ZZ- .
;ZZ. /
_fileWriter[[ 
.[[ 
WriteCommand[[ (
([[( )
$str[[) .
,[[. /
false[[0 5
)[[5 6
;[[6 7
_fileWriter\\ 
.\\ 
WriteCommand\\ (
(\\( )
$"\\) +
set \\+ /
{\\/ 0
node\\0 4
.\\4 5
Children\\5 =
[\\= >
$num\\> ?
]\\? @
.\\@ A
Slot\\A E
}\\E F
"\\F G
,\\G H
false\\I N
)\\N O
;\\O P
}]] 
if`` 
(`` 
node`` 
.`` 
Type`` 
==`` 
NodeType`` %
.``% &
BLOCK``& +
)``+ ,
{aa 
foreachbb 
(bb 
varbb 
childbb "
inbb# %
nodebb& *
.bb* +
Childrenbb+ 3
)bb3 4
{cc 
GenerateCodedd  
(dd  !
childdd! &
)dd& '
;dd' (
}ee 
}ff 
ifii 
(ii 
nodeii 
.ii 
Typeii 
==ii 
NodeTypeii %
.ii% &

EXPRESSIONii& 0
)ii0 1
{jj 
GenerateCodekk 
(kk 
nodekk !
.kk! "
Childrenkk" *
[kk* +
$numkk+ ,
]kk, -
)kk- .
;kk. /
_fileWriterll 
.ll 
WriteCommandll (
(ll( )
$strll) /
)ll/ 0
;ll0 1
}mm 
ifpp 
(pp 
nodepp 
.pp 
Typepp 
==pp 
NodeTypepp %
.pp% &
	CONDITIONpp& /
)pp/ 0
{qq 
varrr 
cpt1rr 
=rr 

countLabelrr %
++rr% '
;rr' (
varss 
cpt2ss 
=ss 

countLabelss %
++ss% '
;ss' (
GenerateCodett 
(tt 
nodett !
.tt! "
Childrentt" *
[tt* +
$numtt+ ,
]tt, -
)tt- .
;tt. /
_fileWriteruu 
.uu 
WriteCommanduu (
(uu( )
$struu) 2
+uu3 4
cpt1uu5 9
,uu9 :
falseuu; @
)uu@ A
;uuA B
GenerateCodevv 
(vv 
nodevv !
.vv! "
Childrenvv" *
[vv* +
$numvv+ ,
]vv, -
)vv- .
;vv. /
ifww 
(ww 
nodeww 
.ww 
Childrenww !
.ww! "
Countww" '
>ww( )
$numww* +
)ww+ ,
{xx 
_fileWriteryy 
.yy  
WriteCommandyy  ,
(yy, -
$stryy- 5
+yy6 7
cpt2yy8 <
,yy< =
falseyy> C
)yyC D
;yyD E
_fileWriterzz 
.zz  
WriteCommandzz  ,
(zz, -
$strzz- 1
+zz2 3
cpt1zz4 8
,zz8 9
falsezz: ?
)zz? @
;zz@ A
GenerateCode{{  
({{  !
node{{! %
.{{% &
Children{{& .
[{{. /
$num{{/ 0
]{{0 1
){{1 2
;{{2 3
_fileWriter|| 
.||  
WriteCommand||  ,
(||, -
$str||- 1
+||2 3
cpt2||4 8
,||8 9
false||: ?
)||? @
;||@ A
}}} 
else~~ 
{ 
_fileWriter
ÄÄ 
.
ÄÄ  
WriteCommand
ÄÄ  ,
(
ÄÄ, -
$str
ÄÄ- 1
+
ÄÄ2 3
cpt1
ÄÄ4 8
,
ÄÄ8 9
false
ÄÄ: ?
)
ÄÄ? @
;
ÄÄ@ A
}
ÅÅ 
}
ÉÉ 
if
ÖÖ 
(
ÖÖ 
node
ÖÖ 
.
ÖÖ 
Type
ÖÖ 
==
ÖÖ 
NodeType
ÖÖ %
.
ÖÖ% &
LOOP
ÖÖ& *
)
ÖÖ* +
{
ÜÜ 
var
áá 
l
áá 
=
áá 
	countLoop
áá !
++
áá! #
;
áá# $
_fileWriter
ââ 
.
ââ 
WriteCommand
ââ (
(
ââ( )
$str
ââ) 0
+
ââ1 2
l
ââ3 4
,
ââ4 5
false
ââ6 ;
)
ââ; <
;
ââ< =
GenerateCode
ää 
(
ää 
node
ää !
.
ää! "
Children
ää" *
[
ää* +
$num
ää+ ,
]
ää, -
)
ää- .
;
ää. /
_fileWriter
çç 
.
çç 
WriteCommand
çç (
(
çç( )
$str
çç) 4
+
çç5 6
l
çç7 8
,
çç8 9
false
çç: ?
)
çç? @
;
çç@ A
_fileWriter
éé 
.
éé 
WriteCommand
éé (
(
éé( )
$str
éé) 3
+
éé4 5

_stackLoop
éé6 @
.
éé@ A
Pop
ééA D
(
ééD E
)
ééE F
,
ééF G
false
ééH M
)
ééM N
;
ééN O
}
èè 
if
ëë 
(
ëë 
node
ëë 
.
ëë 
Type
ëë 
==
ëë 
NodeType
ëë %
.
ëë% &
BREAK
ëë& +
)
ëë+ ,
{
íí 

_stackLoop
ìì 
.
ìì 
Push
ìì 
(
ìì  
	countLoop
ìì  )
++
ìì) +
)
ìì+ ,
;
ìì, -
_fileWriter
îî 
.
îî 
WriteCommand
îî (
(
îî( )
$str
îî) 7
+
îî8 9
(
îî: ;
	countLoop
îî; D
-
îîE F
$num
îîG H
)
îîH I
,
îîI J
false
îîK P
)
îîP Q
;
îîQ R
}
ïï 
if
óó 
(
óó 
node
óó 
.
óó 
Type
óó 
==
óó 
NodeType
óó %
.
óó% &
DECLARE
óó& -
)
óó- .
{
òò 
GenerateCode
ôô 
(
ôô 
node
ôô !
.
ôô! "
Children
ôô" *
[
ôô* +
$num
ôô+ ,
]
ôô, -
)
ôô- .
;
ôô. /
}
öö 
if
ûû 
(
ûû 
node
ûû 
.
ûû 
Type
ûû 
==
ûû 
NodeType
ûû %
.
ûû% &

COMP_EQUAL
ûû& 0
)
ûû0 1
{
üü 
GenerateCode
†† 
(
†† 
node
†† !
.
††! "
Children
††" *
[
††* +
$num
††+ ,
]
††, -
)
††- .
;
††. /
GenerateCode
°° 
(
°° 
node
°° !
.
°°! "
Children
°°" *
[
°°* +
$num
°°+ ,
]
°°, -
)
°°- .
;
°°. /
_fileWriter
¢¢ 
.
¢¢ 
WriteCommand
¢¢ (
(
¢¢( )
$str
¢¢) 0
,
¢¢0 1
true
¢¢2 6
)
¢¢6 7
;
¢¢7 8
}
££ 
if
¶¶ 
(
¶¶ 
node
¶¶ 
.
¶¶ 
Type
¶¶ 
==
¶¶ 
NodeType
¶¶ %
.
¶¶% &
COMP_DIFFERENT
¶¶& 4
)
¶¶4 5
{
ßß 
GenerateCode
®® 
(
®® 
node
®® !
.
®®! "
Children
®®" *
[
®®* +
$num
®®+ ,
]
®®, -
)
®®- .
;
®®. /
GenerateCode
©© 
(
©© 
node
©© !
.
©©! "
Children
©©" *
[
©©* +
$num
©©+ ,
]
©©, -
)
©©- .
;
©©. /
_fileWriter
™™ 
.
™™ 
WriteCommand
™™ (
(
™™( )
$str
™™) 0
,
™™0 1
true
™™2 6
)
™™6 7
;
™™7 8
}
´´ 
if
ÆÆ 
(
ÆÆ 
node
ÆÆ 
.
ÆÆ 
Type
ÆÆ 
==
ÆÆ 
NodeType
ÆÆ %
.
ÆÆ% &
COMP_INFERIOR
ÆÆ& 3
)
ÆÆ3 4
{
ØØ 
GenerateCode
∞∞ 
(
∞∞ 
node
∞∞ !
.
∞∞! "
Children
∞∞" *
[
∞∞* +
$num
∞∞+ ,
]
∞∞, -
)
∞∞- .
;
∞∞. /
GenerateCode
±± 
(
±± 
node
±± !
.
±±! "
Children
±±" *
[
±±* +
$num
±±+ ,
]
±±, -
)
±±- .
;
±±. /
_fileWriter
≤≤ 
.
≤≤ 
WriteCommand
≤≤ (
(
≤≤( )
$str
≤≤) 0
,
≤≤0 1
true
≤≤2 6
)
≤≤6 7
;
≤≤7 8
}
≥≥ 
if
∂∂ 
(
∂∂ 
node
∂∂ 
.
∂∂ 
Type
∂∂ 
==
∂∂ 
NodeType
∂∂ %
.
∂∂% &$
COMP_INFERIOR_OR_EQUAL
∂∂& <
)
∂∂< =
{
∑∑ 
GenerateCode
∏∏ 
(
∏∏ 
node
∏∏ !
.
∏∏! "
Children
∏∏" *
[
∏∏* +
$num
∏∏+ ,
]
∏∏, -
)
∏∏- .
;
∏∏. /
GenerateCode
ππ 
(
ππ 
node
ππ !
.
ππ! "
Children
ππ" *
[
ππ* +
$num
ππ+ ,
]
ππ, -
)
ππ- .
;
ππ. /
_fileWriter
∫∫ 
.
∫∫ 
WriteCommand
∫∫ (
(
∫∫( )
$str
∫∫) 0
,
∫∫0 1
true
∫∫2 6
)
∫∫6 7
;
∫∫7 8
}
ªª 
if
ææ 
(
ææ 
node
ææ 
.
ææ 
Type
ææ 
==
ææ 
NodeType
ææ %
.
ææ% &
COMP_SUPPERIOR
ææ& 4
)
ææ4 5
{
øø 
GenerateCode
¿¿ 
(
¿¿ 
node
¿¿ !
.
¿¿! "
Children
¿¿" *
[
¿¿* +
$num
¿¿+ ,
]
¿¿, -
)
¿¿- .
;
¿¿. /
GenerateCode
¡¡ 
(
¡¡ 
node
¡¡ !
.
¡¡! "
Children
¡¡" *
[
¡¡* +
$num
¡¡+ ,
]
¡¡, -
)
¡¡- .
;
¡¡. /
_fileWriter
¬¬ 
.
¬¬ 
WriteCommand
¬¬ (
(
¬¬( )
$str
¬¬) 0
,
¬¬0 1
true
¬¬2 6
)
¬¬6 7
;
¬¬7 8
}
√√ 
if
∆∆ 
(
∆∆ 
node
∆∆ 
.
∆∆ 
Type
∆∆ 
==
∆∆ 
NodeType
∆∆ %
.
∆∆% &%
COMP_SUPPERIOR_OR_EQUAL
∆∆& =
)
∆∆= >
{
«« 
GenerateCode
»» 
(
»» 
node
»» !
.
»»! "
Children
»»" *
[
»»* +
$num
»»+ ,
]
»», -
)
»»- .
;
»». /
GenerateCode
…… 
(
…… 
node
…… !
.
……! "
Children
……" *
[
……* +
$num
……+ ,
]
……, -
)
……- .
;
……. /
_fileWriter
   
.
   
WriteCommand
   (
(
  ( )
$str
  ) 0
,
  0 1
true
  2 6
)
  6 7
;
  7 8
}
ÀÀ 
}
ÃÃ 	
}
ÕÕ 
}ŒŒ õ√
FD:\Documents\GITrepos\Compil\Compil\Compil\Analyzer\LexicalAnalyzer.cs
	namespace 	
Compil
 
{		 
public

 

class

 
LexicalAnalyzer

  
{ 
private 
readonly 
string 
code  $
;$ %
private 
int 
index 
; 
private 
readonly 

Dictionary #
<# $
string$ *
,* +
	TokenType, 5
>5 6
keywords7 ?
=@ A
newB E

DictionaryF P
<P Q
stringQ W
,W X
	TokenTypeY b
>b c
(c d
)d e
{ 	
{ 
$str 
, 
	TokenType 
. 
IF 
}  
,  !
{ 
$str 
, 
	TokenType 
. 
ELSE #
}# $
,$ %
{ 
$str 
, 
	TokenType 
. 
FOR !
}! "
," #
{ 
$str 
, 
	TokenType 
.  
WHILE  %
}% &
,& '
{ 
$str 
, 
	TokenType 
. 
DO 
}  
,  !
{ 
$str 
, 
	TokenType  
.  !
SWITCH! '
}' (
,( )
{ 
$str 
, 
	TokenType 
. 
CASE #
}# $
,$ %
{ 
$str 
, 
	TokenType 
. 
INT !
}! "
," #
{ 
$str 
, 
	TokenType 
. 
VOID #
}# $
,$ %
{ 
$str 
, 
	TokenType 
. 
VAR !
}! "
} 	
;	 

private 
Token 
_currentNextToken '
;' (
private 
int 
_currentTokenLength '
=( )
$num* +
;+ ,
public&& 
LexicalAnalyzer&& 
(&& 
string&& %
code&&& *
,&&* +
int&&, /
index&&0 5
)&&5 6
{'' 	
this(( 
.(( 
code(( 
=(( 
code(( 
;(( 
this)) 
.)) 
index)) 
=)) 
index)) 
;)) 
}** 	
public11 
Token11 
Next11 
(11 
)11 
{22 	
if33 
(33 
_currentNextToken33 !
!=33" $
null33% )
)33) *
{44 
return55 
_currentNextToken55 (
;55( )
}66 
var88 
result88 
=88 

DetectNext88 #
(88# $
)88$ %
;88% &
_currentNextToken99 
=99 
result99  &
;99& '
return:: 
result:: 
;:: 
};; 	
public@@ 
void@@ 
Skip@@ 
(@@ 
)@@ 
{AA 	
indexBB 
+=BB 
_currentTokenLengthBB (
;BB( )
_currentTokenLengthCC 
=CC  !
$numCC" #
;CC# $
_currentNextTokenDD 
=DD 
nullDD  $
;DD$ %
}EE 	
publicKK 
voidKK 
AcceptKK 
(KK 
	TokenTypeKK $
typeKK% )
)KK) *
{LL 	
tryMM 
{NN 
ifOO 
(OO 
NextOO 
(OO 
)OO 
.OO 
TypeOO 
!=OO  "
typeOO# '
)OO' (
{PP 
throwQQ 
newQQ !
ArgumentNullExceptionQQ 3
(QQ3 4
$"QQ4 6
Bad token: 'QQ6 B
{QQB C
typeQQC G
.QQG H
ToStringQQH P
(QQP Q
)QQQ R
}QQR S
' expected.QQS ^
"QQ^ _
)QQ_ `
;QQ` a
}RR 
SkipTT 
(TT 
)TT 
;TT 
}UU 
catchVV 
(VV !
ArgumentNullExceptionVV (
eVV) *
)VV* +
{WW 
ConsoleXX 
.XX 
	WriteLineXX !
(XX! "
eXX" #
.XX# $
MessageXX$ +
)XX+ ,
;XX, -
}YY 
}ZZ 	
privateaa 
Tokenaa 

DetectNextaa  
(aa  !
)aa! "
{bb 	
trycc 
{dd 
StringBuilderee 
builderee %
=ee& '
newee( +
StringBuilderee, 9
(ee9 :
)ee: ;
;ee; <
ifgg 
(gg 
indexgg 
==gg 
codegg !
.gg! "
Lengthgg" (
)gg( )
{hh 
returnii 
newii 
Tokenii $
(ii$ %
)ii% &
{ii' (
Typeii) -
=ii. /
	TokenTypeii0 9
.ii9 :
END_OF_FILEii: E
}iiF G
;iiG H
}jj 
whilell 
(ll 
codell 
[ll 
indexll !
]ll! "
==ll# %
$charll& )
||ll* ,
codell- 1
[ll1 2
indexll2 7
]ll7 8
==ll9 ;
$charll< @
||llA C
codellD H
[llH I
indexllI N
]llN O
==llP R
$charllS W
||llX Z
codell[ _
[ll_ `
indexll` e
]lle f
==llg i
$charllj n
)lln o
{mm 
indexnn 
++nn 
;nn 
}oo 
ifrr 
(rr 
charrr 
.rr 
IsDigitrr  
(rr  !
coderr! %
[rr% &
indexrr& +
]rr+ ,
)rr, -
)rr- .
{ss 
_currentTokenLengthtt '
=tt( )
$numtt* +
;tt+ ,
buildervv 
.vv 
Appendvv "
(vv" #
codevv# '
[vv' (
indexvv( -
]vv- .
.vv. /
ToStringvv/ 7
(vv7 8
)vv8 9
)vv9 :
;vv: ;
ifxx 
(xx 
indexxx 
==xx  
codexx! %
.xx% &
Lengthxx& ,
-xx- .
$numxx/ 0
)xx0 1
{yy 
returnzz 
newzz "
Tokenzz# (
(zz( )
)zz) *
{zz+ ,
Typezz- 1
=zz2 3
	TokenTypezz4 =
.zz= >
CONSTANTzz> F
,zzF G
ValuezzH M
=zzN O
intzzP S
.zzS T
ParsezzT Y
(zzY Z
builderzzZ a
.zza b
ToStringzzb j
(zzj k
)zzk l
)zzl m
}zzn o
;zzo p
}{{ 
var}} 
i}} 
=}} 
index}} !
+}}" #
$num}}$ %
;}}% &
while~~ 
(~~ 
i~~ 
<~~ 
code~~ #
.~~# $
Length~~$ *
&&~~+ -
char~~. 2
.~~2 3
IsDigit~~3 :
(~~: ;
code~~; ?
[~~? @
i~~@ A
]~~A B
)~~B C
)~~C D
{ 
builder
ÄÄ 
.
ÄÄ  
Append
ÄÄ  &
(
ÄÄ& '
code
ÄÄ' +
[
ÄÄ+ ,
i
ÄÄ, -
]
ÄÄ- .
.
ÄÄ. /
ToString
ÄÄ/ 7
(
ÄÄ7 8
)
ÄÄ8 9
)
ÄÄ9 :
;
ÄÄ: ;
i
ÅÅ 
++
ÅÅ 
;
ÅÅ !
_currentTokenLength
ÇÇ +
++
ÇÇ+ -
;
ÇÇ- .
}
ÉÉ 
return
ÖÖ 
new
ÖÖ 
Token
ÖÖ $
(
ÖÖ$ %
)
ÖÖ% &
{
ÖÖ' (
Type
ÖÖ) -
=
ÖÖ. /
	TokenType
ÖÖ0 9
.
ÖÖ9 :
CONSTANT
ÖÖ: B
,
ÖÖB C
Value
ÖÖD I
=
ÖÖJ K
int
ÖÖL O
.
ÖÖO P
Parse
ÖÖP U
(
ÖÖU V
builder
ÖÖV ]
.
ÖÖ] ^
ToString
ÖÖ^ f
(
ÖÖf g
)
ÖÖg h
)
ÖÖh i
}
ÖÖj k
;
ÖÖk l
}
ÜÜ 
if
ââ 
(
ââ 
char
ââ 
.
ââ 
IsLetter
ââ !
(
ââ! "
code
ââ" &
[
ââ& '
index
ââ' ,
]
ââ, -
)
ââ- .
)
ââ. /
{
ää !
_currentTokenLength
ãã '
=
ãã( )
$num
ãã* +
;
ãã+ ,
builder
åå 
.
åå 
Append
åå "
(
åå" #
code
åå# '
[
åå' (
index
åå( -
]
åå- .
.
åå. /
ToString
åå/ 7
(
åå7 8
)
åå8 9
)
åå9 :
;
åå: ;
if
éé 
(
éé 
index
éé 
==
éé  
code
éé! %
.
éé% &
Length
éé& ,
-
éé- .
$num
éé/ 0
)
éé0 1
{
èè 
if
ëë 
(
ëë 
keywords
ëë $
.
ëë$ %
ContainsKey
ëë% 0
(
ëë0 1
builder
ëë1 8
.
ëë8 9
ToString
ëë9 A
(
ëëA B
)
ëëB C
)
ëëC D
)
ëëD E
{
íí 
return
ìì "
new
ìì# &
Token
ìì' ,
(
ìì, -
)
ìì- .
{
ìì/ 0
Type
ìì1 5
=
ìì6 7
keywords
ìì8 @
[
ìì@ A
builder
ììA H
.
ììH I
ToString
ììI Q
(
ììQ R
)
ììR S
]
ììS T
,
ììT U
Name
ììV Z
=
ìì[ \
builder
ìì] d
.
ììd e
ToString
ììe m
(
ììm n
)
ììn o
}
ììp q
;
ììq r
}
îî 
return
ññ 
new
ññ "
Token
ññ# (
(
ññ( )
)
ññ) *
{
ññ+ ,
Type
ññ- 1
=
ññ2 3
	TokenType
ññ4 =
.
ññ= >

IDENTIFIER
ññ> H
,
ññH I
Name
ññJ N
=
ññO P
builder
ññQ X
.
ññX Y
ToString
ññY a
(
ñña b
)
ññb c
}
ññd e
;
ññe f
}
óó 
var
ôô 
i
ôô 
=
ôô 
index
ôô !
+
ôô" #
$num
ôô$ %
;
ôô% &
while
öö 
(
öö 
i
öö 
<
öö 
code
öö #
.
öö# $
Length
öö$ *
&&
öö+ -
(
öö. /
char
öö/ 3
.
öö3 4
IsLetter
öö4 <
(
öö< =
code
öö= A
[
ööA B
i
ööB C
]
ööC D
)
ööD E
||
ööF H
char
ööI M
.
ööM N
IsDigit
ööN U
(
ööU V
code
ööV Z
[
ööZ [
i
öö[ \
]
öö\ ]
)
öö] ^
)
öö^ _
)
öö_ `
{
õõ 
builder
úú 
.
úú  
Append
úú  &
(
úú& '
code
úú' +
[
úú+ ,
i
úú, -
]
úú- .
.
úú. /
ToString
úú/ 7
(
úú7 8
)
úú8 9
)
úú9 :
;
úú: ;
i
ùù 
++
ùù 
;
ùù !
_currentTokenLength
ûû +
++
ûû+ -
;
ûû- .
}
üü 
if
¢¢ 
(
¢¢ 
keywords
¢¢  
.
¢¢  !
ContainsKey
¢¢! ,
(
¢¢, -
builder
¢¢- 4
.
¢¢4 5
ToString
¢¢5 =
(
¢¢= >
)
¢¢> ?
)
¢¢? @
)
¢¢@ A
{
££ 
return
§§ 
new
§§ "
Token
§§# (
(
§§( )
)
§§) *
{
§§+ ,
Type
§§- 1
=
§§2 3
keywords
§§4 <
[
§§< =
builder
§§= D
.
§§D E
ToString
§§E M
(
§§M N
)
§§N O
]
§§O P
,
§§P Q
Name
§§R V
=
§§W X
builder
§§Y `
.
§§` a
ToString
§§a i
(
§§i j
)
§§j k
}
§§l m
;
§§m n
}
•• 
return
ßß 
new
ßß 
Token
ßß $
(
ßß$ %
)
ßß% &
{
ßß' (
Type
ßß) -
=
ßß. /
	TokenType
ßß0 9
.
ßß9 :

IDENTIFIER
ßß: D
,
ßßD E
Name
ßßF J
=
ßßK L
builder
ßßM T
.
ßßT U
ToString
ßßU ]
(
ßß] ^
)
ßß^ _
}
ßß` a
;
ßßa b
}
®® 
if
´´ 
(
´´ 
code
´´ 
[
´´ 
index
´´ 
]
´´ 
==
´´  "
$char
´´# &
)
´´& '
{
¨¨ !
_currentTokenLength
≠≠ '
=
≠≠( )
$num
≠≠* +
;
≠≠+ ,
builder
ÆÆ 
.
ÆÆ 
Append
ÆÆ "
(
ÆÆ" #
code
ÆÆ# '
[
ÆÆ' (
index
ÆÆ( -
]
ÆÆ- .
.
ÆÆ. /
ToString
ÆÆ/ 7
(
ÆÆ7 8
)
ÆÆ8 9
)
ÆÆ9 :
;
ÆÆ: ;
if
∞∞ 
(
∞∞ 
index
∞∞ 
==
∞∞  
code
∞∞! %
.
∞∞% &
Length
∞∞& ,
-
∞∞- .
$num
∞∞/ 0
)
∞∞0 1
{
±± 
return
≤≤ 
new
≤≤ "
Token
≤≤# (
(
≤≤( )
)
≤≤) *
{
≤≤+ ,
Type
≤≤- 1
=
≤≤2 3
	TokenType
≤≤4 =
.
≤≤= >
EQUAL
≤≤> C
}
≤≤D E
;
≤≤E F
}
≥≥ 
if
µµ 
(
µµ 
code
µµ 
[
µµ 
index
µµ "
+
µµ# $
$num
µµ% &
]
µµ& '
==
µµ( *
$char
µµ+ .
)
µµ. /
{
∂∂ !
_currentTokenLength
∑∑ +
++
∑∑+ -
;
∑∑- .
return
∏∏ 
new
∏∏ "
Token
∏∏# (
(
∏∏( )
)
∏∏) *
{
∏∏+ ,
Type
∏∏- 1
=
∏∏2 3
	TokenType
∏∏4 =
.
∏∏= >

COMP_EQUAL
∏∏> H
}
∏∏I J
;
∏∏J K
}
ππ 
return
ªª 
new
ªª 
Token
ªª $
(
ªª$ %
)
ªª% &
{
ªª' (
Type
ªª) -
=
ªª. /
	TokenType
ªª0 9
.
ªª9 :
EQUAL
ªª: ?
}
ªª@ A
;
ªªA B
}
ºº 
if
øø 
(
øø 
code
øø 
[
øø 
index
øø 
]
øø 
==
øø  "
$char
øø# &
)
øø& '
{
¿¿ !
_currentTokenLength
¡¡ '
=
¡¡( )
$num
¡¡* +
;
¡¡+ ,
builder
¬¬ 
.
¬¬ 
Append
¬¬ "
(
¬¬" #
code
¬¬# '
[
¬¬' (
index
¬¬( -
]
¬¬- .
.
¬¬. /
ToString
¬¬/ 7
(
¬¬7 8
)
¬¬8 9
)
¬¬9 :
;
¬¬: ;
if
ƒƒ 
(
ƒƒ 
index
ƒƒ 
==
ƒƒ  
code
ƒƒ! %
.
ƒƒ% &
Length
ƒƒ& ,
-
ƒƒ- .
$num
ƒƒ/ 0
)
ƒƒ0 1
{
≈≈ 
return
∆∆ 
new
∆∆ "
Token
∆∆# (
(
∆∆( )
)
∆∆) *
{
∆∆+ ,
Type
∆∆- 1
=
∆∆2 3
	TokenType
∆∆4 =
.
∆∆= >
COMP_SUPPERIOR
∆∆> L
}
∆∆M N
;
∆∆N O
}
«« 
if
…… 
(
…… 
code
…… 
[
…… 
index
…… "
+
……# $
$num
……% &
]
……& '
==
……( *
$char
……+ .
)
……. /
{
   !
_currentTokenLength
ÀÀ +
++
ÀÀ+ -
;
ÀÀ- .
return
ÃÃ 
new
ÃÃ "
Token
ÃÃ# (
(
ÃÃ( )
)
ÃÃ) *
{
ÃÃ+ ,
Type
ÃÃ- 1
=
ÃÃ2 3
	TokenType
ÃÃ4 =
.
ÃÃ= >%
COMP_SUPPERIOR_OR_EQUAL
ÃÃ> U
}
ÃÃV W
;
ÃÃW X
}
ÕÕ 
return
œœ 
new
œœ 
Token
œœ $
(
œœ$ %
)
œœ% &
{
œœ' (
Type
œœ) -
=
œœ. /
	TokenType
œœ0 9
.
œœ9 :
COMP_SUPPERIOR
œœ: H
}
œœI J
;
œœJ K
}
–– 
if
”” 
(
”” 
code
”” 
[
”” 
index
”” 
]
”” 
==
””  "
$char
””# &
)
””& '
{
‘‘ !
_currentTokenLength
’’ '
=
’’( )
$num
’’* +
;
’’+ ,
builder
÷÷ 
.
÷÷ 
Append
÷÷ "
(
÷÷" #
code
÷÷# '
[
÷÷' (
index
÷÷( -
]
÷÷- .
.
÷÷. /
ToString
÷÷/ 7
(
÷÷7 8
)
÷÷8 9
)
÷÷9 :
;
÷÷: ;
if
ÿÿ 
(
ÿÿ 
index
ÿÿ 
==
ÿÿ  
code
ÿÿ! %
.
ÿÿ% &
Length
ÿÿ& ,
-
ÿÿ- .
$num
ÿÿ/ 0
)
ÿÿ0 1
{
ŸŸ 
return
⁄⁄ 
new
⁄⁄ "
Token
⁄⁄# (
(
⁄⁄( )
)
⁄⁄) *
{
⁄⁄+ ,
Type
⁄⁄- 1
=
⁄⁄2 3
	TokenType
⁄⁄4 =
.
⁄⁄= >
COMP_INFERIOR
⁄⁄> K
}
⁄⁄L M
;
⁄⁄M N
}
€€ 
if
›› 
(
›› 
code
›› 
[
›› 
index
›› "
+
››# $
$num
››% &
]
››& '
==
››( *
$char
››+ .
)
››. /
{
ﬁﬁ !
_currentTokenLength
ﬂﬂ +
++
ﬂﬂ+ -
;
ﬂﬂ- .
return
‡‡ 
new
‡‡ "
Token
‡‡# (
(
‡‡( )
)
‡‡) *
{
‡‡+ ,
Type
‡‡- 1
=
‡‡2 3
	TokenType
‡‡4 =
.
‡‡= >$
COMP_INFERIOR_OR_EQUAL
‡‡> T
}
‡‡U V
;
‡‡V W
}
·· 
return
„„ 
new
„„ 
Token
„„ $
(
„„$ %
)
„„% &
{
„„' (
Type
„„) -
=
„„. /
	TokenType
„„0 9
.
„„9 :
COMP_INFERIOR
„„: G
}
„„H I
;
„„I J
}
‰‰ 
if
ÁÁ 
(
ÁÁ 
code
ÁÁ 
[
ÁÁ 
index
ÁÁ 
]
ÁÁ 
==
ÁÁ  "
$char
ÁÁ# &
)
ÁÁ& '
{
ËË !
_currentTokenLength
ÈÈ '
=
ÈÈ( )
$num
ÈÈ* +
;
ÈÈ+ ,
builder
ÍÍ 
.
ÍÍ 
Append
ÍÍ "
(
ÍÍ" #
code
ÍÍ# '
[
ÍÍ' (
index
ÍÍ( -
]
ÍÍ- .
.
ÍÍ. /
ToString
ÍÍ/ 7
(
ÍÍ7 8
)
ÍÍ8 9
)
ÍÍ9 :
;
ÍÍ: ;
if
ÏÏ 
(
ÏÏ 
index
ÏÏ 
==
ÏÏ  
code
ÏÏ! %
.
ÏÏ% &
Length
ÏÏ& ,
-
ÏÏ- .
$num
ÏÏ/ 0
)
ÏÏ0 1
{
ÌÌ 
return
ÓÓ 
new
ÓÓ "
Token
ÓÓ# (
(
ÓÓ( )
)
ÓÓ) *
{
ÓÓ+ ,
Type
ÓÓ- 1
=
ÓÓ2 3
	TokenType
ÓÓ4 =
.
ÓÓ= >
NOT
ÓÓ> A
}
ÓÓB C
;
ÓÓC D
}
ÔÔ 
if
ÒÒ 
(
ÒÒ 
code
ÒÒ 
[
ÒÒ 
index
ÒÒ "
+
ÒÒ# $
$num
ÒÒ% &
]
ÒÒ& '
==
ÒÒ( *
$char
ÒÒ+ .
)
ÒÒ. /
{
ÚÚ !
_currentTokenLength
ÛÛ +
++
ÛÛ+ -
;
ÛÛ- .
return
ÙÙ 
new
ÙÙ "
Token
ÙÙ# (
(
ÙÙ( )
)
ÙÙ) *
{
ÙÙ+ ,
Type
ÙÙ- 1
=
ÙÙ2 3
	TokenType
ÙÙ4 =
.
ÙÙ= >
COMP_DIFFERENT
ÙÙ> L
}
ÙÙM N
;
ÙÙN O
}
ıı 
return
˜˜ 
new
˜˜ 
Token
˜˜ $
(
˜˜$ %
)
˜˜% &
{
˜˜' (
Type
˜˜) -
=
˜˜. /
	TokenType
˜˜0 9
.
˜˜9 :
NOT
˜˜: =
}
˜˜> ?
;
˜˜? @
}
¯¯ !
_currentTokenLength
˙˙ #
++
˙˙# %
;
˙˙% &
switch
˚˚ 
(
˚˚ 
code
˚˚ 
[
˚˚ 
index
˚˚ "
]
˚˚" #
)
˚˚# $
{
¸¸ 
case
˝˝ 
$char
˝˝ 
:
˝˝ 
return
˛˛ 
new
˛˛ "
Token
˛˛# (
(
˛˛( )
)
˛˛) *
{
˛˛+ ,
Type
˛˛- 1
=
˛˛2 3
	TokenType
˛˛4 =
.
˛˛= >
PLUS
˛˛> B
}
˛˛C D
;
˛˛D E
case
ˇˇ 
$char
ˇˇ 
:
ˇˇ 
return
ÄÄ 
new
ÄÄ "
Token
ÄÄ# (
(
ÄÄ( )
)
ÄÄ) *
{
ÄÄ+ ,
Type
ÄÄ- 1
=
ÄÄ2 3
	TokenType
ÄÄ4 =
.
ÄÄ= >
MINUS
ÄÄ> C
}
ÄÄD E
;
ÄÄE F
case
ÅÅ 
$char
ÅÅ 
:
ÅÅ 
return
ÇÇ 
new
ÇÇ "
Token
ÇÇ# (
(
ÇÇ( )
)
ÇÇ) *
{
ÇÇ+ ,
Type
ÇÇ- 1
=
ÇÇ2 3
	TokenType
ÇÇ4 =
.
ÇÇ= >
MULTIPLY
ÇÇ> F
}
ÇÇG H
;
ÇÇH I
case
ÉÉ 
$char
ÉÉ 
:
ÉÉ 
return
ÑÑ 
new
ÑÑ "
Token
ÑÑ# (
(
ÑÑ( )
)
ÑÑ) *
{
ÑÑ+ ,
Type
ÑÑ- 1
=
ÑÑ2 3
	TokenType
ÑÑ4 =
.
ÑÑ= >
DIVIDE
ÑÑ> D
}
ÑÑE F
;
ÑÑF G
case
ÖÖ 
$char
ÖÖ 
:
ÖÖ 
return
ÜÜ 
new
ÜÜ "
Token
ÜÜ# (
(
ÜÜ( )
)
ÜÜ) *
{
ÜÜ+ ,
Type
ÜÜ- 1
=
ÜÜ2 3
	TokenType
ÜÜ4 =
.
ÜÜ= >
MODULO
ÜÜ> D
}
ÜÜE F
;
ÜÜF G
case
áá 
$char
áá 
:
áá 
return
àà 
new
àà "
Token
àà# (
(
àà( )
)
àà) *
{
àà+ ,
Type
àà- 1
=
àà2 3
	TokenType
àà4 =
.
àà= >
POWER
àà> C
}
ààD E
;
ààE F
case
ââ 
$char
ââ 
:
ââ 
return
ää 
new
ää "
Token
ää# (
(
ää( )
)
ää) *
{
ää+ ,
Type
ää- 1
=
ää2 3
	TokenType
ää4 =
.
ää= >
PAR_OPEN
ää> F
}
ääG H
;
ääH I
case
ãã 
$char
ãã 
:
ãã 
return
åå 
new
åå "
Token
åå# (
(
åå( )
)
åå) *
{
åå+ ,
Type
åå- 1
=
åå2 3
	TokenType
åå4 =
.
åå= >
	PAR_CLOSE
åå> G
}
ååH I
;
ååI J
case
çç 
$char
çç 
:
çç 
return
éé 
new
éé "
Token
éé# (
(
éé( )
)
éé) *
{
éé+ ,
Type
éé- 1
=
éé2 3
	TokenType
éé4 =
.
éé= >
BRACKET_OPEN
éé> J
}
ééK L
;
ééL M
case
èè 
$char
èè 
:
èè 
return
êê 
new
êê "
Token
êê# (
(
êê( )
)
êê) *
{
êê+ ,
Type
êê- 1
=
êê2 3
	TokenType
êê4 =
.
êê= >
BRACKET_CLOSE
êê> K
}
êêL M
;
êêM N
case
ëë 
$char
ëë 
:
ëë 
return
íí 
new
íí "
Token
íí# (
(
íí( )
)
íí) *
{
íí+ ,
Type
íí- 1
=
íí2 3
	TokenType
íí4 =
.
íí= >
AND
íí> A
}
ííB C
;
ííC D
case
ìì 
$char
ìì 
:
ìì 
return
îî 
new
îî "
Token
îî# (
(
îî( )
)
îî) *
{
îî+ ,
Type
îî- 1
=
îî2 3
	TokenType
îî4 =
.
îî= >
OR
îî> @
}
îîA B
;
îîB C
case
ïï 
$char
ïï 
:
ïï 
return
ññ 
new
ññ "
Token
ññ# (
(
ññ( )
)
ññ) *
{
ññ+ ,
Type
ññ- 1
=
ññ2 3
	TokenType
ññ4 =
.
ññ= >
	SEMICOLON
ññ> G
}
ññH I
;
ññI J
default
óó 
:
óó 
break
òò 
;
òò 
}
ôô 
throw
õõ 
new
õõ %
NotImplementedException
õõ 1
(
õõ1 2
)
õõ2 3
;
õõ3 4
}
úú 
catch
ùù 
(
ùù %
NotImplementedException
ùù *
e
ùù+ ,
)
ùù, -
{
ûû 
Console
üü 
.
üü 
	WriteLine
üü !
(
üü! "
e
üü" #
.
üü# $
Message
üü$ +
)
üü+ ,
;
üü, -
return
†† 
null
†† 
;
†† 
}
°° 
}
¢¢ 	
}
££ 
}§§ ˘
AD:\Documents\GITrepos\Compil\Compil\Compil\LauncherVM\Launcher.cs
	namespace

 	
Compil


 
.

 

LauncherVM

 
{ 
public 

class 
Launcher 
{ 
private 
readonly 
string 
pathMsm  '
;' (
private 
readonly 
string 
msmProgrammName  /
;/ 0
public 
Launcher 
( 
string 
pathMsm &
,& '
string( .
msmProgrammName/ >
)> ?
{ 	
this 
. 
pathMsm 
= 
pathMsm "
;" #
this 
. 
msmProgrammName  
=! "
msmProgrammName# 2
;2 3
} 	
public 
void 
CopyOutFile 
(  
)  !
{ 	
File 
. 
Copy 
( 
Path 
. 
Combine "
(" #
Environment# .
.. /
CurrentDirectory/ ?
,? @
$strA K
)K L
,L M
Path 
. 
Combine 
( 
pathMsm $
,$ %
$str& 0
)0 1
,1 2
true 
) 
; 
} 	
public 
void 
LaunchCodeOnVm "
(" #
)# $
{   	
Process!! 
process!! 
=!! 
new!! !
Process!!" )
(!!) *
)!!* +
;!!+ ,
process"" 
."" 
	StartInfo"" 
."" 
FileName"" &
=""' (
Path"") -
.""- .
Combine"". 5
(""5 6
$str	""6 †
,
""† °
$str
""¢ Æ
)
""Æ Ø
;
""Ø ∞
process## 
.## 
	StartInfo## 
.## 
WorkingDirectory## .
=##/ 0
this##1 5
.##5 6
pathMsm##6 =
;##= >
process$$ 
.$$ 
	StartInfo$$ 
.$$ 
	Arguments$$ '
=$$( )
$str$$* .
+$$/ 0
msmProgrammName$$1 @
+$$A B
$str$$B Z
;$$Z [
process%% 
.%% 
	StartInfo%% 
.%% 
CreateNoWindow%% ,
=%%- .
false%%/ 4
;%%4 5
process&& 
.&& 
Start&& 
(&& 
)&& 
;&& 
Thread(( 
.(( 
Sleep(( 
((( 
$num(( 
)(( 
;(( 
})) 	
}++ 
},, ñ
8D:\Documents\GITrepos\Compil\Compil\Compil\Nodes\Node.cs
	namespace 	
Compil
 
{ 
public 

class 
Node 
{ 
public 
NodeType 
Type 
{ 
get "
;" #
set$ '
;' (
}) *
public 
string 
Value 
{ 
get !
;! "
set# &
;& '
}( )
public 
List 
< 
Node 
> 
Children "
{# $
get% (
;( )
set* -
;- .
}/ 0
=1 2
new3 6
List7 ;
<; <
Node< @
>@ A
(A B
)B C
;C D
public 
int 
Slot 
{ 
get 
; 
set "
;" #
}$ %
public(( 
void(( 
AddChild(( 
((( 
Node(( !
node((" &
)((& '
{)) 	
Children** 
.** 
Add** 
(** 
node** 
)** 
;** 
}++ 	
public11 
void11 
AddChildren11 
(11  
List11  $
<11$ %
Node11% )
>11) *
nodes11+ 0
)110 1
{22 	
foreach33 
(33 
var33 
node33 
in33  
nodes33! &
)33& '
Children44 
.44 
Add44 
(44 
node44 !
)44! "
;44" #
}55 	
public<< 
void<< 
Print<< 
(<< 
string<<  
indent<<! '
,<<' (
bool<<) -
last<<. 2
)<<2 3
{== 	
Console>> 
.>> 
Write>> 
(>> 
indent>>  
)>>  !
;>>! "
if?? 
(?? 
last?? 
)?? 
{@@ 
ConsoleAA 
.AA 
WriteAA 
(AA 
$strAA #
)AA# $
;AA$ %
indentBB 
+=BB 
$strBB 
;BB 
}CC 
elseDD 
{EE 
ConsoleFF 
.FF 
WriteFF 
(FF 
$strFF "
)FF" #
;FF# $
indentGG 
+=GG 
$strGG 
;GG 
}HH 
ifII 
(II 
TypeII 
==II 
NodeTypeII  
.II  !
CONSTANTII! )
)II) *
ConsoleKK 
.KK 
	WriteLineKK !
(KK! "
$"KK" $
VALUE: KK$ +
{KK+ ,
ValueKK, 1
}KK1 2
"KK2 3
)KK3 4
;KK4 5
elseLL 
ifLL 
(LL 
TypeLL 
==LL 
NodeTypeLL $
.LL$ %
VARIABLELL% -
)LL- .
ConsoleMM 
.MM 
	WriteLineMM !
(MM! "
$"MM" $
VARIABLE: name=MM$ 3
{MM3 4
ValueMM4 9
}MM9 :
"MM: ;
)MM; <
;MM< =
elseNN 
ConsolePP 
.PP 
	WriteLinePP !
(PP! "
TypePP" &
)PP& '
;PP' (
forRR 
(RR 
varRR 
iRR 
=RR 
$numRR 
;RR 
iRR 
<RR 
ChildrenRR  (
.RR( )
CountRR) .
;RR. /
iRR0 1
++RR1 3
)RR3 4
ChildrenSS 
[SS 
iSS 
]SS 
.SS 
PrintSS !
(SS! "
indentSS" (
,SS( )
iSS* +
==SS, .
ChildrenSS/ 7
.SS7 8
CountSS8 =
-SS> ?
$numSS@ A
)SSA B
;SSB C
}TT 	
}XX 
}YY  
<D:\Documents\GITrepos\Compil\Compil\Compil\Nodes\NodeType.cs
	namespace 	
Compil
 
. 
Nodes 
{ 
public		 

enum		 
NodeType		 
{

 
VARIABLE 
, 
CONSTANT 
, 
MINUS 
, 
PLUS 
, 
NOT 
, 
OP_PLUS 
, 
OP_MINUS 
, 
OP_MULTIPLY 
, 
	OP_DIVIDE 
, 
	OP_MODULO 
, 
OP_POWER 
, 
AFFECT 
, 

COMP_EQUAL 
, 
COMP_DIFFERENT 
, 
COMP_SUPPERIOR 
, 
COMP_INFERIOR   
,   #
COMP_SUPPERIOR_OR_EQUAL!! 
,!!  "
COMP_INFERIOR_OR_EQUAL"" 
,"" 
AND%% 
,%% 
OR&& 

,&&
 
	CONDITION'' 
,'' 
ELSE(( 
,(( 
FOR)) 
,)) 
WHILE** 
,** 
BREAK++ 
,++ 
LOOP,, 
,,, 
DO-- 

,--
 
SWITCH.. 
,.. 
CASE// 
,// 
INT00 
,00 
VOID11 
,11 
BLOCK33 
,33 

EXPRESSION44 
,44 
DECLARE55 
}66 
}77 —(
5D:\Documents\GITrepos\Compil\Compil\Compil\Program.cs
	namespace 	
Compil
 
{ 
static 

class 
Program 
{ 
static 
void 
Main 
( 
string 
[  
]  !
args" &
)& '
{ 	
try 
{ 
if 
( 
args 
. 
Length 
==  "
$num# $
)$ %
{ 
Help 
( 
) 
; 
Console 
. 
ReadKey #
(# $
)$ %
;% &
return 
; 
} 
Console 
. 
	WriteLine !
(! "
$str" 3
+4 5
args6 :
[: ;
args; ?
.? @
Length@ F
-G H
$numI J
]J K
)K L
;L M
var 
pathFile 
= 
Path #
.# $
Combine$ +
(+ ,
args, 0
[0 1
args1 5
.5 6
Length6 <
-= >
$num? @
]@ A
)A B
;B C
var 
codeTemp 
= 
File #
.# $
ReadAllText$ /
(/ 0
pathFile0 8
)8 9
;9 :
Console   
.   
	WriteLine   !
(  ! "
$str  " 3
)  3 4
;  4 5
Console!! 
.!! 
	WriteLine!! !
(!!! "
codeTemp!!" *
)!!* +
;!!+ ,
Console## 
.## 
	WriteLine## !
(##! "
$str##" >
)##> ?
;##? @
Console$$ 
.$$ 
ReadKey$$ 
($$  
)$$  !
;$$! "
Console%% 
.%% 
	WriteLine%% !
(%%! "
)%%" #
;%%# $
var(( 
lexicalAnalyser(( #
=(($ %
new((& )
LexicalAnalyzer((* 9
(((9 :
codeTemp((: B
,((B C
$num((D E
)((E F
;((F G
var** 
syntaxAnalyzer** "
=**# $
new**% (
SyntaxAnalyzer**) 7
(**7 8
lexicalAnalyser**8 G
)**G H
;**H I
var,, 

fileWriter,, 
=,,  
new,,! $

FileWriter,,% /
(,,/ 0
),,0 1
;,,1 2

fileWriter.. 
... 
InitFile.. #
(..# $
)..$ %
;..% &
var11 
node11 
=11 
syntaxAnalyzer11 )
.11) *
Instruction11* 5
(115 6
)116 7
;117 8
node22 
.22 
Print22 
(22 
$str22 
,22 
false22 $
)22$ %
;22% &
var44 
analyzer44 
=44 
new44 "
SemanticAnalyzer44# 3
(443 4
)444 5
;445 6
analyzer55 
.55 
Analyze55  
(55  !
node55! %
)55% &
;55& '
var77 
codeGenerator77 !
=77" #
new77$ '
CodeGenerator77( 5
(775 6
analyzer776 >
,77> ?

fileWriter77@ J
)77J K
;77K L
codeGenerator88 
.88 
GenerateCode88 *
(88* +
node88+ /
)88/ 0
;880 1

fileWriter== 
.== 
	WriteFile== $
(==$ %
)==% &
;==& '
ConsoleGG 
.GG 
	WriteLineGG !
(GG! "
$strGG" <
)GG< =
;GG= >
ConsoleHH 
.HH 
ReadKeyHH 
(HH  
)HH  !
;HH! "
}II 
catchJJ 
(JJ $
EncoderFallbackExceptionJJ +
eJJ, -
)JJ- .
{KK 
ConsoleLL 
.LL 
	WriteLineLL !
(LL! "
eLL" #
.LL# $

StackTraceLL$ .
)LL. /
;LL/ 0
}MM 
catchNN 
(NN !
ArgumentNullExceptionNN (
eNN) *
)NN* +
{OO 
ConsolePP 
.PP 
	WriteLinePP !
(PP! "
$strPP" K
)PPK L
;PPL M
ConsoleQQ 
.QQ 
	WriteLineQQ !
(QQ! "
eQQ" #
.QQ# $
MessageQQ$ +
)QQ+ ,
;QQ, -
}RR 
}SS 	
publicYY 
staticYY 
voidYY 
HelpYY 
(YY  
)YY  !
{ZZ 	
Console[[ 
.[[ 
	WriteLine[[ 
([[ 
$str[[ :
)[[: ;
;[[; <
Console\\ 
.\\ 
	WriteLine\\ 
(\\ 
$str\\ 8
)\\8 9
;\\9 :
Console]] 
.]] 
	WriteLine]] 
(]] 
$str]] 6
)]]6 7
;]]7 8
}^^ 	
}__ 
}`` 
ED:\Documents\GITrepos\Compil\Compil\Compil\Properties\AssemblyInfo.cs
[ 
assembly 	
:	 

AssemblyTitle 
( 
$str !
)! "
]" #
[ 
assembly 	
:	 

AssemblyDescription 
( 
$str !
)! "
]" #
[		 
assembly		 	
:			 
!
AssemblyConfiguration		  
(		  !
$str		! #
)		# $
]		$ %
[

 
assembly

 	
:

	 

AssemblyCompany

 
(

 
$str

 
)

 
]

 
[ 
assembly 	
:	 

AssemblyProduct 
( 
$str #
)# $
]$ %
[ 
assembly 	
:	 

AssemblyCopyright 
( 
$str 0
)0 1
]1 2
[ 
assembly 	
:	 

AssemblyTrademark 
( 
$str 
)  
]  !
[ 
assembly 	
:	 

AssemblyCulture 
( 
$str 
) 
] 
[ 
assembly 	
:	 


ComVisible 
( 
false 
) 
] 
[ 
assembly 	
:	 

Guid 
( 
$str 6
)6 7
]7 8
["" 
assembly"" 	
:""	 

AssemblyVersion"" 
("" 
$str"" $
)""$ %
]""% &
[## 
assembly## 	
:##	 

AssemblyFileVersion## 
(## 
$str## (
)##( )
]##) *æ
>D:\Documents\GITrepos\Compil\Compil\Compil\Symbols\NodeType.cs
	namespace 	
Compil
 
. 
Symbols 
{		 
public

 

enum

 

SymbolType

 
{ 
VARIABLE 
, 
FUNCTION 
} 
} ≈
<D:\Documents\GITrepos\Compil\Compil\Compil\Symbols\Symbol.cs
	namespace 	
Compil
 
. 
Symbols 
{ 
public 

class 
Symbol 
{ 
public 
string 
Id 
{ 
get 
; 
set  #
;# $
}% &
public 

SymbolType 
Type 
{  
get! $
;$ %
set& )
;) *
}+ ,
public 
int 
Slot 
{ 
get 
; 
set "
;" #
}$ %
} 
} ƒ
>D:\Documents\GITrepos\Compil\Compil\Compil\Utils\FileWriter.cs
	namespace 	
Compil
 
. 
Utils 
{ 
public		 

class		 

FileWriter		 
{

 
private 
readonly 
string 
pathFileCode  ,
;, -
private 
string 
code 
; 
public 

FileWriter 
( 
) 
{ 	
code 
= 
String 
. 
Empty 
;  
pathFileCode 
= 
Path 
.  
Combine  '
(' (
Environment( 3
.3 4
CurrentDirectory4 D
,D E
$strF P
)P Q
;Q R
} 	
public 
void 
InitFile 
( 
) 
{ 	
code 
+= 
$str 
+ 
$str #
;# $
} 	
public$$ 
void$$ 
WriteCommand$$  
($$  !
string$$! '
cmd$$( +
,$$+ ,
bool$$- 1
debug$$2 7
=$$8 9
false$$: ?
)$$? @
{%% 	
code&& 
+=&& 
cmd&& 
+&& 
$str&& 
;&& 
if'' 
('' 
debug'' 
)'' 
{(( 
code)) 
+=)) 
$str)) 
+)) 
$str))  $
;))$ %
code** 
+=** 
$str** 
+** 
$str**  $
;**$ %
}++ 
},, 	
public11 
void11 
	WriteFile11 
(11 
)11 
{22 	
try33 
{44 
code55 
+=55 
$str55 
;55  
code66 
+=66 
$str66 
;66 
if77 
(77 
File77 
.77 
Exists77 
(77  
pathFileCode77  ,
)77, -
)77- .
File88 
.88 
Delete88 
(88  
pathFileCode88  ,
)88, -
;88- .
Console:: 
.:: 
	WriteLine:: !
(::! "
)::" #
;::# $
Console;; 
.;; 
	WriteLine;; !
(;;! "
$str;;" 4
);;4 5
;;;5 6
Console<< 
.<< 
	WriteLine<< !
(<<! "
code<<" &
)<<& '
;<<' (
File>> 
.>> 
WriteAllText>> !
(>>! "
pathFileCode>>" .
,>>. /
code>>0 4
)>>4 5
;>>5 6
}?? 
catch@@ 
(@@ 
	Exception@@ 
e@@ 
)@@ 
{AA 
ConsoleBB 
.BB 
	WriteLineBB !
(BB! "
eBB" #
.BB# $
MessageBB$ +
)BB+ ,
;BB, -
ConsoleCC 
.CC 
	WriteLineCC !
(CC! "
eCC" #
.CC# $

StackTraceCC$ .
)CC. /
;CC/ 0
}DD 
}EE 	
}FF 
}GG Ã
:D:\Documents\GITrepos\Compil\Compil\Compil\Tokens\Token.cs
	namespace 	
Compil
 
{ 
public		 

class		 
Token		 
{

 
public 
string 
Name 
{ 
get  
;  !
set" %
;% &
}' (
public 
int 
Value 
{ 
get 
; 
set  #
;# $
}% &
public 
int 
Line 
{ 
get 
; 
set "
;" #
}$ %
public 
int 
Column 
{ 
get 
;  
set! $
;$ %
}& '
public 
	TokenType 
Type 
{ 
get  #
;# $
set% (
;( )
}* +
}!! 
}"" ˜
>D:\Documents\GITrepos\Compil\Compil\Compil\Tokens\TokenType.cs
	namespace 	
Compil
 
. 
Tokens 
{ 
public 

enum 
	TokenType 
{ 

IDENTIFIER 
, 
CONSTANT 
, 
END_OF_FILE		 
,		 
NOT 
, 
PLUS 
, 
MINUS 
, 
MULTIPLY 
, 
DIVIDE 
, 
MODULO 
, 
POWER 
, 
IF 

,
 
ELSE 
, 
FOR 
, 
WHILE 
, 
DO 

,
 
SWITCH 
, 
CASE 
, 
INT 
, 
VOID 
, 

COMP_EQUAL 
, 
COMP_DIFFERENT 
, 
COMP_SUPPERIOR   
,   
COMP_INFERIOR!! 
,!! #
COMP_SUPPERIOR_OR_EQUAL"" 
,""  "
COMP_INFERIOR_OR_EQUAL## 
,## 
PAR_OPEN%% 
,%% 
	PAR_CLOSE&& 
,&& 
OR(( 

,((
 
AND)) 
,)) 
EQUAL++ 
,++ 
BRACKET_OPEN.. 
,.. 
BRACKET_CLOSE// 
,// 
	SEMICOLON11 
,11 
COMA22 
,22 
COMMENT_LINE33 
,33 
COMMENT_BLOCK_START44 
,44 
COMMENT_BLOCK_END55 
,55 
VAR77 
}88 
}99 ·
<D:\Documents\GITrepos\Compil\Compil\Compil\Utils\Operator.cs
	namespace 	
Compil
 
. 
Utils 
{ 
public 

class 
Operator 
{ 
public 
Token 
Token 
{ 
get  
;  !
set" %
;% &
}' (
public 
Node 
Node 
{ 
get 
; 
set  #
;# $
}% &
public 
int 
Priority 
{ 
get !
;! "
set# &
;& '
}( )
public 
int 
Association 
{  
get! $
;$ %
set& )
;) *
}+ ,
}		 
}

 