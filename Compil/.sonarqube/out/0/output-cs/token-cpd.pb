†.
GD:\Documents\GITrepos\Compil\Compil\Compil\Analyzer\SemanticAnalyzer.cs
	namespace 	
Compil
 
{ 
public 

class 
SemanticAnalyzer !
{		 
private

 
int

 
_variablesCount

 #
=

$ %
$num

& '
;

' (
private 
readonly 
Stack 
< 

Dictionary )
<) *
string* 0
,0 1
Symbol2 8
>8 9
>9 :
_stack; A
=B C
newD G
StackH M
<M N

DictionaryN X
<X Y
stringY _
,_ `
Symbola g
>g h
>h i
(i j
)j k
;k l
private 
void 

BeginBlock 
(  
)  !
{ 	
_stack 
. 
Push 
( 
new 

Dictionary &
<& '
string' -
,- .
Symbol/ 5
>5 6
(6 7
)7 8
)8 9
;9 :
} 	
private 
void 
EndBlock 
( 
) 
{ 	
_stack 
. 
Pop 
( 
) 
; 
} 	
private 
Symbol 
Declare 
( 
string %
id& (
)( )
{ 	
var 
s 
= 
new 
Symbol 
( 
)  
{! "
Slot# '
=( )
_variablesCount* 9
,9 :
Id; =
=> ?
id@ B
}C D
;D E
_stack 
. 
Peek 
( 
) 
. 
Add 
( 
id  
,  !
s" #
)# $
;$ %
return 
s 
; 
} 	
private 
Symbol 
Search 
( 
string $
id% '
)' (
{ 	
foreach   
(   
var   
symbolsTable   %
in  & (
_stack  ) /
)  / 0
{!! 
if"" 
("" 
symbolsTable""  
.""  !
TryGetValue""! ,
("", -
id""- /
,""/ 0
out""1 4
var""5 8
value""9 >
)""> ?
)""? @
{## 
return$$ 
value$$  
;$$  !
}%% 
}&& 
throw'' 
new'' !
ArgumentNullException'' +
(''+ ,
$"'', .

Variable '''. 8
{''8 9
id''9 ;
}''; <
' does not exist.'''< N
"''N O
)''O P
;''P Q
}(( 	
public** 
void** 
Analyze** 
(** 
Node**  
node**! %
)**% &
{++ 	
switch,, 
(,, 
node,, 
.,, 
Type,, 
),, 
{-- 
default.. 
:.. 
foreach// 
(// 
var//  
child//! &
in//' )
node//* .
.//. /
Children/// 7
)//7 8
{00 
Analyze11 
(11  
child11  %
)11% &
;11& '
}22 
break33 
;33 
case44 
NodeType44 
.44 
BLOCK44 #
:44# $

BeginBlock55 
(55 
)55  
;55  !
foreach66 
(66 
var66  
child66! &
in66' )
node66* .
.66. /
Children66/ 7
)667 8
{77 
Analyze88 
(88  
child88  %
)88% &
;88& '
}99 
EndBlock:: 
(:: 
):: 
;:: 
break;; 
;;; 
case<< 
NodeType<< 
.<< 
DECLARE<< %
:<<% &
var== 
s1== 
=== 
Declare== $
(==$ %
node==% )
.==) *
Children==* 2
[==2 3
$num==3 4
]==4 5
.==5 6
Value==6 ;
)==; <
;==< =
s1>> 
.>> 
Type>> 
=>> 

SymbolType>> (
.>>( )
VARIABLE>>) 1
;>>1 2
s1?? 
.?? 
Slot?? 
=?? 
_variablesCount?? -
++??- /
;??/ 0
node@@ 
.@@ 
Children@@ !
[@@! "
$num@@" #
]@@# $
.@@$ %
Slot@@% )
=@@* +
s1@@, .
.@@. /
Slot@@/ 3
;@@3 4
AnalyzeAA 
(AA 
nodeAA  
.AA  !
ChildrenAA! )
[AA) *
$numAA* +
]AA+ ,
)AA, -
;AA- .
breakBB 
;BB 
caseCC 
NodeTypeCC 
.CC 
VARIABLECC &
:CC& '
varDD 
s2DD 
=DD 
SearchDD #
(DD# $
nodeDD$ (
.DD( )
ValueDD) .
)DD. /
;DD/ 0
ifEE 
(EE 
s2EE 
.EE 
TypeEE 
!=EE  "

SymbolTypeEE# -
.EE- .
VARIABLEEE. 6
)EE6 7
{FF 
throwGG 
newGG !!
ArgumentNullExceptionGG" 7
(GG7 8
$strGG8 Y
)GGY Z
;GGZ [
}HH 
nodeJJ 
.JJ 
SlotJJ 
=JJ 
s2JJ  "
.JJ" #
SlotJJ# '
;JJ' (
breakKK 
;KK 
}LL 
}MM 	
}NN 
}OO ≠ø
ED:\Documents\GITrepos\Compil\Compil\Compil\Analyzer\SyntaxAnalyzer.cs
	namespace 	
Compil
 
{ 
public 

class 
SyntaxAnalyzer 
{ 
private 
readonly 
LexicalAnalyzer (
_lexicalAnalyzer) 9
;9 :
private 
readonly 

Dictionary #
<# $
	TokenType$ -
,- .
(/ 0
NodeType0 8
,8 9
string: @
,@ A
intB E
,E F
intG J
)J K
>K L!
_exprTokenToNodeMatchM b
=c d
newe h

Dictionaryi s
<s t
	TokenTypet }
,} ~
(	 Ä
NodeType
Ä à
,
à â
string
ä ê
,
ê ë
int
í ï
,
ï ñ
int
ó ö
)
ö õ
>
õ ú
(
ú ù
)
ù û
{ 	
{ 
	TokenType 
. 
OR 
, 
( 
NodeType $
.$ %
OR% '
,' (
$str) ,
,, -
$num. /
,/ 0
$num1 2
)2 3
}3 4
,4 5
{ 
	TokenType 
. 
AND 
, 
( 
NodeType %
.% &
AND& )
,) *
$str+ .
,. /
$num0 1
,1 2
$num3 4
)4 5
}5 6
,6 7
{ 
	TokenType 
. 
NOT 
, 
( 
NodeType %
.% &
NOT& )
,) *
$str+ .
,. /
$num0 1
,1 2
$num3 4
)4 5
}5 6
,6 7
{ 
	TokenType 
. 

COMP_EQUAL !
,! "
(# $
NodeType$ ,
., -

COMP_EQUAL- 7
,7 8
$str9 =
,= >
$num? @
,@ A
$numB C
)C D
}D E
,E F
{ 
	TokenType 
. 
PLUS 
, 
( 
NodeType &
.& '
OP_PLUS' .
,. /
$str0 3
,3 4
$num5 6
,6 7
$num8 9
)9 :
}: ;
,; <
{ 
	TokenType 
. 
MINUS 
, 
( 
NodeType '
.' (
OP_MINUS( 0
,0 1
$str2 5
,5 6
$num7 8
,8 9
$num: ;
); <
}< =
,= >
{ 
	TokenType 
. 
POWER 
, 
( 
NodeType '
.' (
OP_POWER( 0
,0 1
$str2 5
,5 6
$num7 8
,8 9
$num: ;
); <
}< =
,= >
{ 
	TokenType 
. 
DIVIDE 
, 
(  
NodeType  (
.( )
	OP_DIVIDE) 2
,2 3
$str4 7
,7 8
$num9 :
,: ;
$num< =
)= >
}> ?
,? @
{ 
	TokenType 
. 
MODULO 
, 
(  
NodeType  (
.( )
	OP_MODULO) 2
,2 3
$str4 7
,7 8
$num9 :
,: ;
$num< =
)= >
}> ?
,? @
{ 
	TokenType 
. 
MULTIPLY 
,  
(! "
NodeType" *
.* +
OP_MULTIPLY+ 6
,6 7
$str8 ;
,; <
$num= >
,> ?
$num@ A
)A B
}B C
,C D
{ 
	TokenType 
. 
COMP_INFERIOR $
,$ %
(& '
NodeType' /
./ 0
COMP_INFERIOR0 =
,= >
$str? B
,B C
$numD E
,E F
$numG H
)H I
}I J
,J K
{ 
	TokenType 
. 
COMP_DIFFERENT %
,% &
(' (
NodeType( 0
.0 1
COMP_DIFFERENT1 ?
,? @
$strA E
,E F
$numG H
,H I
$numJ K
)K L
}L M
,M N
{ 
	TokenType 
. 
COMP_SUPPERIOR %
,% &
(' (
NodeType( 0
.0 1
COMP_SUPPERIOR1 ?
,? @
$strA D
,D E
$numF G
,G H
$numI J
)J K
}K L
,L M
{ 
	TokenType 
. "
COMP_INFERIOR_OR_EQUAL -
,- .
(/ 0
NodeType0 8
.8 9"
COMP_INFERIOR_OR_EQUAL9 O
,O P
$strQ U
,U V
$numW X
,X Y
$numZ [
)[ \
}\ ]
,] ^
{   
	TokenType   
.   #
COMP_SUPPERIOR_OR_EQUAL   .
,  . /
(  0 1
NodeType  1 9
.  9 :#
COMP_SUPPERIOR_OR_EQUAL  : Q
,  Q R
$str  S W
,  W X
$num  Y Z
,  Z [
$num  \ ]
)  ] ^
}  ^ _
,  _ `
{!! 
	TokenType!! 
.!! 
EQUAL!! 
,!! 
(!! 
NodeType!! '
.!!' (
AFFECT!!( .
,!!. /
$str!!0 3
,!!3 4
$num!!5 6
,!!6 7
$num!!8 9
)!!9 :
}!!: ;
}"" 	
;""	 

public(( 
SyntaxAnalyzer(( 
((( 
LexicalAnalyzer(( -
lexicalAnalyser((. =
)((= >
{)) 	
this** 
.** 
_lexicalAnalyzer** !
=**" #
lexicalAnalyser**$ 3
;**3 4
}++ 	
public00 
Node00 
Primary00 
(00 
)00 
{11 	
try22 
{33 
Node44 
node44 
;44 
if77 
(77 
_lexicalAnalyzer77 $
.77$ %
Next77% )
(77) *
)77* +
.77+ ,
Type77, 0
==771 3
	TokenType774 =
.77= >
CONSTANT77> F
)77F G
{88 
node99 
=99 
new99 
Node99 #
(99# $
)99$ %
{99& '
Type99( ,
=99- .
NodeType99/ 7
.997 8
CONSTANT998 @
,99@ A
Value99B G
=99H I
_lexicalAnalyzer99J Z
.99Z [
Next99[ _
(99_ `
)99` a
.99a b
Value99b g
.99g h
ToString99h p
(99p q
)99q r
}99s t
;99t u
_lexicalAnalyzer:: $
.::$ %
Skip::% )
(::) *
)::* +
;::+ ,
return;; 
node;; 
;;;  
}<< 
if?? 
(?? 
_lexicalAnalyzer?? $
.??$ %
Next??% )
(??) *
)??* +
.??+ ,
Type??, 0
==??1 3
	TokenType??4 =
.??= >
PAR_OPEN??> F
)??F G
{@@ 
_lexicalAnalyzerAA $
.AA$ %
SkipAA% )
(AA) *
)AA* +
;AA+ ,
nodeBB 
=BB 

ExpressionBB %
(BB% &
$numBB& '
)BB' (
;BB( )
_lexicalAnalyzerCC $
.CC$ %
AcceptCC% +
(CC+ ,
	TokenTypeCC, 5
.CC5 6
	PAR_CLOSECC6 ?
)CC? @
;CC@ A
returnDD 
nodeDD 
;DD  
}EE 
ifHH 
(HH 
_lexicalAnalyzerHH $
.HH$ %
NextHH% )
(HH) *
)HH* +
.HH+ ,
TypeHH, 0
==HH1 3
	TokenTypeHH4 =
.HH= >
MINUSHH> C
||HHD F
_lexicalAnalyzerII $
.II$ %
NextII% )
(II) *
)II* +
.II+ ,
TypeII, 0
==II1 3
	TokenTypeII4 =
.II= >
PLUSII> B
||IIC E
_lexicalAnalyzerJJ $
.JJ$ %
NextJJ% )
(JJ) *
)JJ* +
.JJ+ ,
TypeJJ, 0
==JJ1 3
	TokenTypeJJ4 =
.JJ= >
NOTJJ> A
)JJA B
{KK 
varLL 
(LL 
nodeTypeLL !
,LL! "
valLL# &
,LL& '
_LL( )
,LL) *
_LL+ ,
)LL, -
=LL. /!
_exprTokenToNodeMatchLL0 E
[LLE F
_lexicalAnalyzerLLF V
.LLV W
NextLLW [
(LL[ \
)LL\ ]
.LL] ^
TypeLL^ b
]LLb c
;LLc d
nodeMM 
=MM 
newMM 
NodeMM #
(MM# $
)MM$ %
{MM& '
TypeMM( ,
=MM- .
nodeTypeMM/ 7
,MM7 8
ValueMM9 >
=MM? @
valMMA D
}MME F
;MMF G
_lexicalAnalyzerNN $
.NN$ %
SkipNN% )
(NN) *
)NN* +
;NN+ ,
nodeOO 
.OO 
AddChildOO !
(OO! "

ExpressionOO" ,
(OO, -
$numOO- .
)OO. /
)OO/ 0
;OO0 1
returnPP 
nodePP 
;PP  
}QQ 
ifTT 
(TT 
_lexicalAnalyzerTT $
.TT$ %
NextTT% )
(TT) *
)TT* +
.TT+ ,
TypeTT, 0
==TT1 3
	TokenTypeTT4 =
.TT= >

IDENTIFIERTT> H
)TTH I
{UU 
nodeVV 
=VV 
newVV 
NodeVV #
(VV# $
)VV$ %
{VV& '
TypeVV( ,
=VV- .
NodeTypeVV/ 7
.VV7 8
VARIABLEVV8 @
,VV@ A
ValueVVB G
=VVH I
_lexicalAnalyzerVVJ Z
.VVZ [
NextVV[ _
(VV_ `
)VV` a
.VVa b
NameVVb f
.VVf g
ToStringVVg o
(VVo p
)VVp q
}VVr s
;VVs t
_lexicalAnalyzerWW $
.WW$ %
SkipWW% )
(WW) *
)WW* +
;WW+ ,
returnXX 
nodeXX 
;XX  
}YY 
throw\\ 
new\\ !
ArgumentNullException\\ /
(\\/ 0
$str\\0 C
)\\C D
;\\D E
}]] 
catch^^ 
(^^ #
NotImplementedException^^ *
e^^+ ,
)^^, -
{__ 
Console`` 
.`` 
	WriteLine`` !
(``! "
$str``" <
)``< =
;``= >
Consoleaa 
.aa 
	WriteLineaa !
(aa! "
eaa" #
.aa# $

StackTraceaa$ .
)aa. /
;aa/ 0
returnbb 
nullbb 
;bb 
}cc 
catchdd 
(dd !
ArgumentNullExceptiondd (
edd) *
)dd* +
{ee 
Consoleff 
.ff 
	WriteLineff !
(ff! "
eff" #
.ff# $
Messageff$ +
)ff+ ,
;ff, -
Consolegg 
.gg 
	WriteLinegg !
(gg! "
egg" #
.gg# $

StackTracegg$ .
)gg. /
;gg/ 0
returnhh 
nullhh 
;hh 
}ii 
}jj 	
publicqq 
Nodeqq 

Expressionqq 
(qq 
intqq "
pMinqq# '
=qq( )
$numqq* +
)qq+ ,
{rr 	
varss 
leftNodess 
=ss 
Primaryss "
(ss" #
)ss# $
;ss$ %
whileuu 
(uu 
trueuu 
)uu 
{vv 
ifww 
(ww 
_lexicalAnalyzerww $
.ww$ %
Nextww% )
(ww) *
)ww* +
==ww, .
nullww/ 3
)ww3 4
returnxx 
leftNodexx #
;xx# $
varzz 
opzz 
=zz 
SearchOpzz !
(zz! "
_lexicalAnalyzerzz" 2
.zz2 3
Nextzz3 7
(zz7 8
)zz8 9
)zz9 :
;zz: ;
if|| 
(|| 
op|| 
==|| 
null|| 
|||| !
op||" $
.||$ %
Priority||% -
<||. /
pMin||0 4
)||4 5
return}} 
leftNode}} #
;}}# $
_lexicalAnalyzer  
.  !
Skip! %
(% &
)& '
;' (
var
ÄÄ 
	rightNode
ÄÄ 
=
ÄÄ 

Expression
ÄÄ  *
(
ÄÄ* +
op
ÄÄ+ -
.
ÄÄ- .
Priority
ÄÄ. 6
+
ÄÄ7 8
op
ÄÄ9 ;
.
ÄÄ; <
Association
ÄÄ< G
)
ÄÄG H
;
ÄÄH I
var
ÅÅ 
tree
ÅÅ 
=
ÅÅ 
new
ÅÅ 
Node
ÅÅ #
(
ÅÅ# $
)
ÅÅ$ %
{
ÅÅ& '
Type
ÅÅ( ,
=
ÅÅ- .
op
ÅÅ/ 1
.
ÅÅ1 2
Node
ÅÅ2 6
.
ÅÅ6 7
Type
ÅÅ7 ;
}
ÅÅ< =
;
ÅÅ= >
tree
ÇÇ 
.
ÇÇ 
AddChild
ÇÇ 
(
ÇÇ 
leftNode
ÇÇ &
)
ÇÇ& '
;
ÇÇ' (
tree
ÉÉ 
.
ÉÉ 
AddChild
ÉÉ 
(
ÉÉ 
	rightNode
ÉÉ '
)
ÉÉ' (
;
ÉÉ( )
leftNode
ÑÑ 
=
ÑÑ 
tree
ÑÑ 
;
ÑÑ  
}
ÖÖ 
}
ÜÜ 	
public
çç 
Operator
çç 
SearchOp
çç  
(
çç  !
Token
çç! &
token
çç' ,
)
çç, -
{
éé 	
if
èè 
(
èè #
_exprTokenToNodeMatch
èè %
.
èè% &
TryGetValue
èè& 1
(
èè1 2
token
èè2 7
.
èè7 8
Type
èè8 <
,
èè< =
out
èè> A
var
èèB E
vals
èèF J
)
èèJ K
)
èèK L
{
êê 
var
ëë 
(
ëë 
nodetype
ëë 
,
ëë 
val
ëë "
,
ëë" #
priority
ëë$ ,
,
ëë, -
assos
ëë. 3
)
ëë3 4
=
ëë5 6
vals
ëë7 ;
;
ëë; <
return
íí 
new
íí 
Operator
íí #
(
íí# $
)
íí$ %
{
íí& '
Token
íí( -
=
íí. /
token
íí0 5
,
íí5 6
Node
íí7 ;
=
íí< =
new
íí> A
Node
ííB F
(
ííF G
)
ííG H
{
ííI J
Type
ííK O
=
ííP Q
nodetype
ííR Z
}
íí[ \
,
íí\ ]
Priority
íí^ f
=
ííg h
priority
ííi q
,
ííq r
Association
íís ~
=íí Ä
assosííÅ Ü
}ííá à
;ííà â
}
ìì 
return
îî 
null
îî 
;
îî 
}
ïï 	
public
óó 
Node
óó 
Instruction
óó 
(
óó  
)
óó  !
{
òò 	
if
ôô 
(
ôô 
_lexicalAnalyzer
ôô  
.
ôô  !
Next
ôô! %
(
ôô% &
)
ôô& '
.
ôô' (
Type
ôô( ,
==
ôô- /
	TokenType
ôô0 9
.
ôô9 :
IF
ôô: <
)
ôô< =
{
öö 
_lexicalAnalyzer
õõ  
.
õõ  !
Skip
õõ! %
(
õõ% &
)
õõ& '
;
õõ' (
_lexicalAnalyzer
úú  
.
úú  !
Accept
úú! '
(
úú' (
	TokenType
úú( 1
.
úú1 2
PAR_OPEN
úú2 :
)
úú: ;
;
úú; <
var
ùù 
aTest
ùù 
=
ùù 

Expression
ùù &
(
ùù& '
)
ùù' (
;
ùù( )
_lexicalAnalyzer
ûû  
.
ûû  !
Accept
ûû! '
(
ûû' (
	TokenType
ûû( 1
.
ûû1 2
	PAR_CLOSE
ûû2 ;
)
ûû; <
;
ûû< =
var
üü 
aCode
üü 
=
üü 
Instruction
üü '
(
üü' (
)
üü( )
;
üü) *
var
†† 
node
†† 
=
†† 
new
†† 
Node
†† #
(
††# $
)
††$ %
{
††& '
Type
††' +
=
††, -
NodeType
††. 6
.
††6 7
	CONDITION
††7 @
}
††@ A
;
††A B
node
°° 
.
°° 
AddChild
°° 
(
°° 
aTest
°° #
)
°°# $
;
°°$ %
node
¢¢ 
.
¢¢ 
AddChild
¢¢ 
(
¢¢ 
aCode
¢¢ #
)
¢¢# $
;
¢¢$ %
return
££ 
node
££ 
;
££ 
}
§§ 
else
•• 
if
•• 
(
•• 
_lexicalAnalyzer
•• $
.
••$ %
Next
••% )
(
••) *
)
••* +
.
••+ ,
Type
••, 0
==
••1 3
	TokenType
••4 =
.
••= >
WHILE
••> C
)
••C D
{
¶¶ 
_lexicalAnalyzer
ßß  
.
ßß  !
Skip
ßß! %
(
ßß% &
)
ßß& '
;
ßß' (
_lexicalAnalyzer
®®  
.
®®  !
Accept
®®! '
(
®®' (
	TokenType
®®( 1
.
®®1 2
PAR_OPEN
®®2 :
)
®®: ;
;
®®; <
var
©© 
aTest
©© 
=
©© 

Expression
©© &
(
©©& '
)
©©' (
;
©©( )
_lexicalAnalyzer
™™  
.
™™  !
Accept
™™! '
(
™™' (
	TokenType
™™( 1
.
™™1 2
	PAR_CLOSE
™™2 ;
)
™™; <
;
™™< =
var
´´ 
aCode
´´ 
=
´´ 
Instruction
´´ '
(
´´' (
)
´´( )
;
´´) *
var
¨¨ 
node
¨¨ 
=
¨¨ 
new
¨¨ 
Node
¨¨ #
(
¨¨# $
)
¨¨$ %
{
¨¨& '
Type
¨¨( ,
=
¨¨- .
NodeType
¨¨/ 7
.
¨¨7 8
WHILE
¨¨8 =
}
¨¨> ?
;
¨¨? @
node
≠≠ 
.
≠≠ 
AddChild
≠≠ 
(
≠≠ 
aTest
≠≠ #
)
≠≠# $
;
≠≠$ %
node
ÆÆ 
.
ÆÆ 
AddChild
ÆÆ 
(
ÆÆ 
aCode
ÆÆ #
)
ÆÆ# $
;
ÆÆ$ %
return
ØØ 
node
ØØ 
;
ØØ 
}
∞∞ 
else
±± 
if
±± 
(
±± 
_lexicalAnalyzer
±± %
.
±±% &
Next
±±& *
(
±±* +
)
±±+ ,
.
±±, -
Type
±±- 1
==
±±2 4
	TokenType
±±5 >
.
±±> ?
BRACKET_OPEN
±±? K
)
±±K L
{
≤≤ 
var
≥≥ 
node
≥≥ 
=
≥≥ 
new
≥≥ 
Node
≥≥ #
(
≥≥# $
)
≥≥$ %
{
≥≥& '
Type
≥≥' +
=
≥≥, -
NodeType
≥≥. 6
.
≥≥6 7
BLOCK
≥≥7 <
}
≥≥< =
;
≥≥= >
_lexicalAnalyzer
¥¥  
.
¥¥  !
Accept
¥¥! '
(
¥¥' (
	TokenType
¥¥( 1
.
¥¥1 2
BRACKET_OPEN
¥¥2 >
)
¥¥> ?
;
¥¥? @
while
µµ 
(
µµ 
_lexicalAnalyzer
µµ '
.
µµ' (
Next
µµ( ,
(
µµ, -
)
µµ- .
.
µµ. /
Type
µµ/ 3
!=
µµ4 6
	TokenType
µµ7 @
.
µµ@ A
BRACKET_CLOSE
µµA N
)
µµN O
{
∂∂ 
var
∑∑ 
x
∑∑ 
=
∑∑ 
Instruction
∑∑ '
(
∑∑' (
)
∑∑( )
;
∑∑) *
node
∏∏ 
.
∏∏ 
AddChild
∏∏ !
(
∏∏! "
x
∏∏" #
)
∏∏# $
;
∏∏$ %
}
ππ 
_lexicalAnalyzer
∫∫  
.
∫∫  !
Accept
∫∫! '
(
∫∫' (
	TokenType
∫∫( 1
.
∫∫1 2
BRACKET_CLOSE
∫∫2 ?
)
∫∫? @
;
∫∫@ A
return
ªª 
node
ªª 
;
ªª 
}
ºº 
else
ΩΩ 
if
ΩΩ 
(
ΩΩ 
_lexicalAnalyzer
ΩΩ %
.
ΩΩ% &
Next
ΩΩ& *
(
ΩΩ* +
)
ΩΩ+ ,
.
ΩΩ, -
Type
ΩΩ- 1
==
ΩΩ2 4
	TokenType
ΩΩ5 >
.
ΩΩ> ?
VAR
ΩΩ? B
)
ΩΩB C
{
ΩΩD E
_lexicalAnalyzer
ææ  
.
ææ  !
Skip
ææ! %
(
ææ% &
)
ææ& '
;
ææ' (
if
øø 
(
øø 
_lexicalAnalyzer
øø $
.
øø$ %
Next
øø% )
(
øø) *
)
øø* +
.
øø+ ,
Type
øø, 0
==
øø1 3
	TokenType
øø4 =
.
øø= >

IDENTIFIER
øø> H
)
øøH I
{
øøJ K
var
¿¿ 
variableName
¿¿ $
=
¿¿% &
_lexicalAnalyzer
¿¿' 7
.
¿¿7 8
Next
¿¿8 <
(
¿¿< =
)
¿¿= >
.
¿¿> ?
Name
¿¿? C
;
¿¿C D
var
¡¡ 
nodeVariable
¡¡ $
=
¡¡% &
new
¡¡' *
Node
¡¡+ /
(
¡¡/ 0
)
¡¡0 1
{
¡¡2 3
Type
¡¡4 8
=
¡¡9 :
NodeType
¡¡; C
.
¡¡C D
DECLARE
¡¡D K
}
¡¡L M
;
¡¡M N
nodeVariable
¬¬  
.
¬¬  !
AddChild
¬¬! )
(
¬¬) *
new
¬¬* -
Node
¬¬. 2
(
¬¬2 3
)
¬¬3 4
{
¬¬5 6
Type
¬¬6 :
=
¬¬; <
NodeType
¬¬= E
.
¬¬E F
VARIABLE
¬¬F N
,
¬¬N O
Value
¬¬P U
=
¬¬V W
variableName
¬¬X d
}
¬¬d e
)
¬¬e f
;
¬¬f g
var
√√ 
ex
√√ 
=
√√ 

Expression
√√ '
(
√√' (
)
√√( )
;
√√) *
_lexicalAnalyzer
≈≈ $
.
≈≈$ %
Accept
≈≈% +
(
≈≈+ ,
	TokenType
≈≈, 5
.
≈≈5 6
	SEMICOLON
≈≈6 ?
)
≈≈? @
;
≈≈@ A
if
»» 
(
»» 
ex
»» 
.
»» 
Type
»» 
!=
»»  "
NodeType
»»# +
.
»»+ ,
AFFECT
»», 2
)
»»2 3
{
»»4 5
if
…… 
(
…… 
ex
…… 
.
…… 
Children
…… &
.
……& '
Count
……' ,
!=
……- /
$num
……0 1
)
……1 2
throw
   !
new
  " %
	Exception
  & /
(
  / 0
$str
  0 @
)
  @ A
;
  A B
}
ÀÀ 
nodeVariable
ÕÕ  
.
ÕÕ  !
AddChild
ÕÕ! )
(
ÕÕ) *
ex
ÕÕ* ,
)
ÕÕ, -
;
ÕÕ- .
return
—— 
nodeVariable
—— '
;
——' (
}
““ 
_lexicalAnalyzer
‘‘  
.
‘‘  !
Accept
‘‘! '
(
‘‘' (
	TokenType
‘‘( 1
.
‘‘1 2
	SEMICOLON
‘‘2 ;
)
‘‘; <
;
‘‘< =
throw
’’ 
new
’’ 
	Exception
’’ #
(
’’# $
$str
’’$ ;
)
’’; <
;
’’< =
}
÷÷ 
else
◊◊ 
{
ÿÿ 
var
ŸŸ 
ex
ŸŸ 
=
ŸŸ 

Expression
ŸŸ #
(
ŸŸ# $
)
ŸŸ$ %
;
ŸŸ% &
_lexicalAnalyzer
⁄⁄  
.
⁄⁄  !
Accept
⁄⁄! '
(
⁄⁄' (
	TokenType
⁄⁄( 1
.
⁄⁄1 2
	SEMICOLON
⁄⁄2 ;
)
⁄⁄; <
;
⁄⁄< =
var
€€ 
node
€€ 
=
€€ 
new
€€ 
Node
€€ #
(
€€# $
)
€€$ %
{
€€& '
Type
€€' +
=
€€, -
NodeType
€€. 6
.
€€6 7

EXPRESSION
€€7 A
}
€€A B
;
€€B C
node
‹‹ 
.
‹‹ 
AddChild
‹‹ 
(
‹‹ 
ex
‹‹  
)
‹‹  !
;
‹‹! "
return
›› 
node
›› 
;
›› 
}
ﬁﬁ 
}
ﬂﬂ 	
}
·· 
}‚‚ ´
8D:\Documents\GITrepos\Compil\Compil\Compil\Compilator.cs
	namespace 	
Compil
 
{ 
public 

class 

Compilator 
{		 
public

 
void

 
Compile

 
(

 
string

 "
	inputCode

# ,
,

, -
string

. 4

outputPath

5 ?
)

? @
{ 	
var 
lexicalAnalyser 
=  !
new" %
LexicalAnalyzer& 5
(5 6
	inputCode6 ?
,? @
$numA B
)B C
;C D
var 
syntaxAnalyzer 
=  
new! $
SyntaxAnalyzer% 3
(3 4
lexicalAnalyser4 C
)C D
;D E
var 

fileWriter 
= 
new  

FileWriter! +
(+ ,
), -
;- .
var 
node 
= 
syntaxAnalyzer %
.% &

Expression& 0
(0 1
$num1 2
)2 3
;3 4
var 
codeGenerator 
= 
new  #
CodeGenerator$ 1
(1 2

fileWriter2 <
)< =
;= >
codeGenerator 
. 
GenerateCode &
(& '
node' +
)+ ,
;, -
} 	
} 
} Å
ND:\Documents\GITrepos\Compil\Compil\Compil\Exceptions\NotValidCharException.cs
	namespace 	
Compil
 
. 

Exceptions 
{ 
class 	!
NotValidCharException
 
{ 
public !
NotValidCharException $
($ %
)% &
{		 	
} 	
} 
} ´}
ED:\Documents\GITrepos\Compil\Compil\Compil\Generator\CodeGenerator.cs
	namespace 	
Compil
 
. 
	Generator 
{ 
public 

class 
CodeGenerator 
{		 
private 
readonly 

FileWriter #
_fileWriter$ /
;/ 0
private 
readonly 

Dictionary #
<# $
NodeType$ ,
,, -
string. 4
>4 5
_operatorsToCode6 F
=G H
newI L

DictionaryM W
<W X
NodeTypeX `
,` a
stringb h
>h i
(i j
)j k
{ 	
{ 
NodeType 
. 
OP_PLUS 
, 
$str  %
}& '
,' (
{ 
NodeType 
. 
OP_MINUS 
,  
$str! &
}' (
,( )
{ 
NodeType 
. 
OP_MULTIPLY "
," #
$str$ )
}* +
,+ ,
{ 
NodeType 
. 
	OP_DIVIDE  
,  !
$str" '
}( )
,) *
{ 
NodeType 
. 
	OP_MODULO  
,  !
$str" '
}( )
,) *
{ 
NodeType 
. 
AND 
, 
$str !
}" #
,# $
{ 
NodeType 
. 
OR 
, 
$str 
}  !
} 	
;	 

public 
CodeGenerator 
( 

FileWriter '

fileWriter( 2
)2 3
{ 	
_fileWriter 
= 

fileWriter $
;$ %
} 	
public&& 
void&& 
GenerateCode&&  
(&&  !
Node&&! %
node&&& *
)&&* +
{'' 	
if)) 
()) 
node)) 
.)) 
Type)) 
==)) 
NodeType)) %
.))% &
CONSTANT))& .
))). /
{** 
_fileWriter++ 
.++ 
WriteCommand++ (
(++( )
$str++) 0
+++1 2
node++2 6
.++6 7
Value++7 <
,++< =
true++> B
)++B C
;++C D
},, 
if// 
(// 
_operatorsToCode//  
.//  !
ContainsKey//! ,
(//, -
node//- 1
.//1 2
Type//2 6
)//6 7
)//7 8
{00 
GenerateCode11 
(11 
node11 !
.11! "
Children11" *
[11* +
$num11+ ,
]11, -
)11- .
;11. /
GenerateCode22 
(22 
node22 !
.22! "
Children22" *
[22* +
$num22+ ,
]22, -
)22- .
;22. /
_fileWriter33 
.33 
WriteCommand33 (
(33( )
_operatorsToCode33) 9
[339 :
node33: >
.33> ?
Type33? C
]33C D
,33D E
true33F J
)33J K
;33K L
}44 
switch77 
(77 
node77 
.77 
Type77 
)77 
{88 
case:: 
NodeType:: 
.:: 
MINUS:: #
:::# $
_fileWriter;; 
.;;  
WriteCommand;;  ,
(;;, -
$str;;- 5
,;;5 6
true;;7 ;
);;; <
;;;< =
GenerateCode<<  
(<<  !
node<<! %
.<<% &
Children<<& .
[<<. /
$num<</ 0
]<<0 1
)<<1 2
;<<2 3
_fileWriter== 
.==  
WriteCommand==  ,
(==, -
$str==- 2
,==2 3
true==4 8
)==8 9
;==9 :
break>> 
;>> 
case?? 
NodeType?? 
.?? 
PLUS?? "
:??" #
_fileWriter@@ 
.@@  
WriteCommand@@  ,
(@@, -
$str@@- 5
,@@5 6
true@@7 ;
)@@; <
;@@< =
GenerateCodeAA  
(AA  !
nodeAA! %
.AA% &
ChildrenAA& .
[AA. /
$numAA/ 0
]AA0 1
)AA1 2
;AA2 3
_fileWriterBB 
.BB  
WriteCommandBB  ,
(BB, -
$strBB- 2
,BB2 3
trueBB4 8
)BB8 9
;BB9 :
breakCC 
;CC 
}DD 
ifGG 
(GG 
nodeGG 
.GG 
TypeGG 
==GG 
NodeTypeGG %
.GG% &
VARIABLEGG& .
)GG. /
{HH 
_fileWriterII 
.II 
WriteCommandII (
(II( )
$strII) 0
,II0 1
trueII2 6
)II6 7
;II7 8
}JJ 
ifLL 
(LL 
nodeLL 
.LL 
TypeLL 
==LL 
NodeTypeLL %
.LL% &
AFFECTLL& ,
)LL, -
{MM 
GenerateCodeNN 
(NN 
nodeNN !
.NN! "
ChildrenNN" *
[NN* +
$numNN+ ,
]NN, -
)NN- .
;NN. /
_fileWriterOO 
.OO 
WriteCommandOO (
(OO( )
$strOO) .
,OO. /
falseOO0 5
)OO5 6
;OO6 7
_fileWriterPP 
.PP 
WriteCommandPP (
(PP( )
$strPP) 0
,PP0 1
falsePP2 7
)PP7 8
;PP8 9
}QQ 
ifTT 
(TT 
nodeTT 
.TT 
TypeTT 
==TT 
NodeTypeTT %
.TT% &
BLOCKTT& +
)TT+ ,
{UU 
foreachVV 
(VV 
varVV 
childVV "
inVV# %
nodeVV& *
.VV* +
ChildrenVV+ 3
)VV3 4
{WW 
GenerateCodeXX  
(XX  !
childXX! &
)XX& '
;XX' (
}YY 
}ZZ 
if]] 
(]] 
node]] 
.]] 
Type]] 
==]] 
NodeType]] %
.]]% &

EXPRESSION]]& 0
)]]0 1
{^^ 
GenerateCode__ 
(__ 
node__ !
.__! "
Children__" *
[__* +
$num__+ ,
]__, -
)__- .
;__. /
_fileWriter`` 
.`` 
WriteCommand`` (
(``( )
$str``) /
)``/ 0
;``0 1
}aa 
ifdd 
(dd 
nodedd 
.dd 
Typedd 
==dd 
NodeTypedd %
.dd% &
	CONDITIONdd& /
)dd/ 0
{ee 
varff 
nodeTestff 
=ff 
nodeff #
.ff# $
Childrenff$ ,
[ff, -
$numff- .
]ff. /
;ff/ 0
vargg 
nodeCodegg 
=gg 
nodegg #
.gg# $
Childrengg$ ,
[gg, -
$numgg- .
]gg. /
;gg/ 0
GenerateCodeii 
(ii 
nodeTestii %
)ii% &
;ii& '
_fileWriterkk 
.kk 
WriteCommandkk (
(kk( )
$strkk) 6
,kk6 7
falsekk8 =
)kk= >
;kk> ?
foreachmm 
(mm 
varmm 
childmm "
inmm# %
nodeCodemm& .
.mm. /
Childrenmm/ 7
)mm7 8
{nn 
GenerateCodeoo  
(oo  !
childoo! &
)oo& '
;oo' (
}pp 
_fileWriterrr 
.rr 
WriteCommandrr (
(rr( )
$strrr) 1
,rr1 2
falserr3 8
)rr8 9
;rr9 :
}ss 
ifuu 
(uu 
nodeuu 
.uu 
Typeuu 
==uu 
NodeTypeuu $
.uu$ %
ELSEuu% )
)uu) *
{vv 
varww 
nodeCodeww 
=ww 
nodeww #
.ww# $
Childrenww$ ,
[ww, -
$numww- .
]ww. /
;ww/ 0
foreachyy 
(yy 
varyy 
childyy !
inyy" $
nodeCodeyy% -
.yy- .
Childrenyy. 6
)yy6 7
{zz 
GenerateCode{{  
({{  !
child{{! &
){{& '
;{{' (
}|| 
}}} 
if
ÄÄ 
(
ÄÄ 
node
ÄÄ 
.
ÄÄ 
Type
ÄÄ 
==
ÄÄ 
NodeType
ÄÄ $
.
ÄÄ$ %
WHILE
ÄÄ% *
)
ÄÄ* +
{
ÅÅ 
_fileWriter
ÉÉ 
.
ÉÉ 
WriteCommand
ÉÉ (
(
ÉÉ( )
$str
ÉÉ) :
,
ÉÉ: ;
false
ÉÉ< A
)
ÉÉA B
;
ÉÉB C
var
ÖÖ 
nodeTest
ÖÖ 
=
ÖÖ 
node
ÖÖ #
.
ÖÖ# $
Children
ÖÖ$ ,
[
ÖÖ, -
$num
ÖÖ- .
]
ÖÖ. /
;
ÖÖ/ 0
var
ÜÜ 
nodeCode
ÜÜ 
=
ÜÜ 
node
ÜÜ #
.
ÜÜ# $
Children
ÜÜ$ ,
[
ÜÜ, -
$num
ÜÜ- .
]
ÜÜ. /
;
ÜÜ/ 0
GenerateCode
àà 
(
àà 
nodeTest
àà %
)
àà% &
;
àà& '
_fileWriter
ää 
.
ää 
WriteCommand
ää (
(
ää( )
$str
ää) 9
,
ää9 :
false
ää; @
)
ää@ A
;
ääA B
foreach
åå 
(
åå 
var
åå 
child
åå "
in
åå# %
nodeCode
åå& .
.
åå. /
Children
åå/ 7
)
åå7 8
{
çç 
GenerateCode
éé  
(
éé  !
child
éé! &
)
éé& '
;
éé' (
}
èè 
_fileWriter
íí 
.
íí 
WriteCommand
íí (
(
íí( )
$str
íí) >
,
íí> ?
false
íí@ E
)
ííE F
;
ííF G
_fileWriter
ìì 
.
ìì 
WriteCommand
ìì (
(
ìì( )
$str
ìì) 4
,
ìì4 5
false
ìì6 ;
)
ìì; <
;
ìì< =
}
îî 
if
óó 
(
óó 
node
óó 
.
óó 
Type
óó 
==
óó 
NodeType
óó %
.
óó% &
DECLARE
óó& -
)
óó- .
{
òò 
_fileWriter
ôô 
.
ôô 
WriteCommand
ôô (
(
ôô( )
$"
ôô) +
resn 
ôô+ 0
{
ôô0 1
node
ôô1 5
.
ôô5 6
Children
ôô6 >
[
ôô> ?
$num
ôô? @
]
ôô@ A
.
ôôA B
Slot
ôôB F
}
ôôF G
"
ôôG H
)
ôôH I
;
ôôI J
GenerateCode
öö 
(
öö 
node
öö !
.
öö! "
Children
öö" *
[
öö* +
$num
öö+ ,
]
öö, -
)
öö- .
;
öö. /
}
õõ 
if
üü 
(
üü 
node
üü 
.
üü 
Type
üü 
==
üü 
NodeType
üü %
.
üü% &

COMP_EQUAL
üü& 0
)
üü0 1
{
†† 
GenerateCode
°° 
(
°° 
node
°° !
.
°°! "
Children
°°" *
[
°°* +
$num
°°+ ,
]
°°, -
)
°°- .
;
°°. /
GenerateCode
¢¢ 
(
¢¢ 
node
¢¢ !
.
¢¢! "
Children
¢¢" *
[
¢¢* +
$num
¢¢+ ,
]
¢¢, -
)
¢¢- .
;
¢¢. /
_fileWriter
££ 
.
££ 
WriteCommand
££ (
(
££( )
$str
££) 0
,
££0 1
true
££2 6
)
££6 7
;
££7 8
}
§§ 
if
ßß 
(
ßß 
node
ßß 
.
ßß 
Type
ßß 
==
ßß 
NodeType
ßß %
.
ßß% &
COMP_DIFFERENT
ßß& 4
)
ßß4 5
{
®® 
GenerateCode
©© 
(
©© 
node
©© !
.
©©! "
Children
©©" *
[
©©* +
$num
©©+ ,
]
©©, -
)
©©- .
;
©©. /
GenerateCode
™™ 
(
™™ 
node
™™ !
.
™™! "
Children
™™" *
[
™™* +
$num
™™+ ,
]
™™, -
)
™™- .
;
™™. /
_fileWriter
´´ 
.
´´ 
WriteCommand
´´ (
(
´´( )
$str
´´) 0
,
´´0 1
true
´´2 6
)
´´6 7
;
´´7 8
}
¨¨ 
if
ØØ 
(
ØØ 
node
ØØ 
.
ØØ 
Type
ØØ 
==
ØØ 
NodeType
ØØ %
.
ØØ% &
COMP_INFERIOR
ØØ& 3
)
ØØ3 4
{
∞∞ 
GenerateCode
±± 
(
±± 
node
±± !
.
±±! "
Children
±±" *
[
±±* +
$num
±±+ ,
]
±±, -
)
±±- .
;
±±. /
GenerateCode
≤≤ 
(
≤≤ 
node
≤≤ !
.
≤≤! "
Children
≤≤" *
[
≤≤* +
$num
≤≤+ ,
]
≤≤, -
)
≤≤- .
;
≤≤. /
_fileWriter
≥≥ 
.
≥≥ 
WriteCommand
≥≥ (
(
≥≥( )
$str
≥≥) 0
,
≥≥0 1
true
≥≥2 6
)
≥≥6 7
;
≥≥7 8
}
¥¥ 
if
∑∑ 
(
∑∑ 
node
∑∑ 
.
∑∑ 
Type
∑∑ 
==
∑∑ 
NodeType
∑∑ %
.
∑∑% &$
COMP_INFERIOR_OR_EQUAL
∑∑& <
)
∑∑< =
{
∏∏ 
GenerateCode
ππ 
(
ππ 
node
ππ !
.
ππ! "
Children
ππ" *
[
ππ* +
$num
ππ+ ,
]
ππ, -
)
ππ- .
;
ππ. /
GenerateCode
∫∫ 
(
∫∫ 
node
∫∫ !
.
∫∫! "
Children
∫∫" *
[
∫∫* +
$num
∫∫+ ,
]
∫∫, -
)
∫∫- .
;
∫∫. /
_fileWriter
ªª 
.
ªª 
WriteCommand
ªª (
(
ªª( )
$str
ªª) 0
,
ªª0 1
true
ªª2 6
)
ªª6 7
;
ªª7 8
}
ºº 
if
øø 
(
øø 
node
øø 
.
øø 
Type
øø 
==
øø 
NodeType
øø %
.
øø% &
COMP_SUPPERIOR
øø& 4
)
øø4 5
{
¿¿ 
GenerateCode
¡¡ 
(
¡¡ 
node
¡¡ !
.
¡¡! "
Children
¡¡" *
[
¡¡* +
$num
¡¡+ ,
]
¡¡, -
)
¡¡- .
;
¡¡. /
GenerateCode
¬¬ 
(
¬¬ 
node
¬¬ !
.
¬¬! "
Children
¬¬" *
[
¬¬* +
$num
¬¬+ ,
]
¬¬, -
)
¬¬- .
;
¬¬. /
_fileWriter
√√ 
.
√√ 
WriteCommand
√√ (
(
√√( )
$str
√√) 0
,
√√0 1
true
√√2 6
)
√√6 7
;
√√7 8
}
ƒƒ 
if
«« 
(
«« 
node
«« 
.
«« 
Type
«« 
==
«« 
NodeType
«« %
.
««% &%
COMP_SUPPERIOR_OR_EQUAL
««& =
)
««= >
{
»» 
GenerateCode
…… 
(
…… 
node
…… !
.
……! "
Children
……" *
[
……* +
$num
……+ ,
]
……, -
)
……- .
;
……. /
GenerateCode
   
(
   
node
   !
.
  ! "
Children
  " *
[
  * +
$num
  + ,
]
  , -
)
  - .
;
  . /
_fileWriter
ÀÀ 
.
ÀÀ 
WriteCommand
ÀÀ (
(
ÀÀ( )
$str
ÀÀ) 0
,
ÀÀ0 1
true
ÀÀ2 6
)
ÀÀ6 7
;
ÀÀ7 8
}
ÃÃ 
}
ÕÕ 	
}
ŒŒ 
}œœ õ√
FD:\Documents\GITrepos\Compil\Compil\Compil\Analyzer\LexicalAnalyzer.cs
	namespace 	
Compil
 
{		 
public

 

class

 
LexicalAnalyzer

  
{ 
private 
readonly 
string 
code  $
;$ %
private 
int 
index 
; 
private 
readonly 

Dictionary #
<# $
string$ *
,* +
	TokenType, 5
>5 6
keywords7 ?
=@ A
newB E

DictionaryF P
<P Q
stringQ W
,W X
	TokenTypeY b
>b c
(c d
)d e
{ 	
{ 
$str 
, 
	TokenType 
. 
IF 
}  
,  !
{ 
$str 
, 
	TokenType 
. 
ELSE #
}# $
,$ %
{ 
$str 
, 
	TokenType 
. 
FOR !
}! "
," #
{ 
$str 
, 
	TokenType 
.  
WHILE  %
}% &
,& '
{ 
$str 
, 
	TokenType 
. 
DO 
}  
,  !
{ 
$str 
, 
	TokenType  
.  !
SWITCH! '
}' (
,( )
{ 
$str 
, 
	TokenType 
. 
CASE #
}# $
,$ %
{ 
$str 
, 
	TokenType 
. 
INT !
}! "
," #
{ 
$str 
, 
	TokenType 
. 
VOID #
}# $
,$ %
{ 
$str 
, 
	TokenType 
. 
VAR !
}! "
} 	
;	 

private 
Token 
_currentNextToken '
;' (
private 
int 
_currentTokenLength '
=( )
$num* +
;+ ,
public&& 
LexicalAnalyzer&& 
(&& 
string&& %
code&&& *
,&&* +
int&&, /
index&&0 5
)&&5 6
{'' 	
this(( 
.(( 
code(( 
=(( 
code(( 
;(( 
this)) 
.)) 
index)) 
=)) 
index)) 
;)) 
}** 	
public11 
Token11 
Next11 
(11 
)11 
{22 	
if33 
(33 
_currentNextToken33 !
!=33" $
null33% )
)33) *
{44 
return55 
_currentNextToken55 (
;55( )
}66 
var88 
result88 
=88 

DetectNext88 #
(88# $
)88$ %
;88% &
_currentNextToken99 
=99 
result99  &
;99& '
return:: 
result:: 
;:: 
};; 	
public@@ 
void@@ 
Skip@@ 
(@@ 
)@@ 
{AA 	
indexBB 
+=BB 
_currentTokenLengthBB (
;BB( )
_currentTokenLengthCC 
=CC  !
$numCC" #
;CC# $
_currentNextTokenDD 
=DD 
nullDD  $
;DD$ %
}EE 	
publicKK 
voidKK 
AcceptKK 
(KK 
	TokenTypeKK $
typeKK% )
)KK) *
{LL 	
tryMM 
{NN 
ifOO 
(OO 
NextOO 
(OO 
)OO 
.OO 
TypeOO 
!=OO  "
typeOO# '
)OO' (
{PP 
throwQQ 
newQQ !
ArgumentNullExceptionQQ 3
(QQ3 4
$"QQ4 6
Bad token: 'QQ6 B
{QQB C
typeQQC G
.QQG H
ToStringQQH P
(QQP Q
)QQQ R
}QQR S
' expected.QQS ^
"QQ^ _
)QQ_ `
;QQ` a
}RR 
SkipTT 
(TT 
)TT 
;TT 
}UU 
catchVV 
(VV !
ArgumentNullExceptionVV (
eVV) *
)VV* +
{WW 
ConsoleXX 
.XX 
	WriteLineXX !
(XX! "
eXX" #
.XX# $
MessageXX$ +
)XX+ ,
;XX, -
}YY 
}ZZ 	
privateaa 
Tokenaa 

DetectNextaa  
(aa  !
)aa! "
{bb 	
trycc 
{dd 
StringBuilderee 
builderee %
=ee& '
newee( +
StringBuilderee, 9
(ee9 :
)ee: ;
;ee; <
ifgg 
(gg 
indexgg 
==gg 
codegg !
.gg! "
Lengthgg" (
)gg( )
{hh 
returnii 
newii 
Tokenii $
(ii$ %
)ii% &
{ii' (
Typeii) -
=ii. /
	TokenTypeii0 9
.ii9 :
END_OF_FILEii: E
}iiF G
;iiG H
}jj 
whilell 
(ll 
codell 
[ll 
indexll !
]ll! "
==ll# %
$charll& )
||ll* ,
codell- 1
[ll1 2
indexll2 7
]ll7 8
==ll9 ;
$charll< @
||llA C
codellD H
[llH I
indexllI N
]llN O
==llP R
$charllS W
||llX Z
codell[ _
[ll_ `
indexll` e
]lle f
==llg i
$charllj n
)lln o
{mm 
indexnn 
++nn 
;nn 
}oo 
ifrr 
(rr 
charrr 
.rr 
IsDigitrr  
(rr  !
coderr! %
[rr% &
indexrr& +
]rr+ ,
)rr, -
)rr- .
{ss 
_currentTokenLengthtt '
=tt( )
$numtt* +
;tt+ ,
buildervv 
.vv 
Appendvv "
(vv" #
codevv# '
[vv' (
indexvv( -
]vv- .
.vv. /
ToStringvv/ 7
(vv7 8
)vv8 9
)vv9 :
;vv: ;
ifxx 
(xx 
indexxx 
==xx  
codexx! %
.xx% &
Lengthxx& ,
-xx- .
$numxx/ 0
)xx0 1
{yy 
returnzz 
newzz "
Tokenzz# (
(zz( )
)zz) *
{zz+ ,
Typezz- 1
=zz2 3
	TokenTypezz4 =
.zz= >
CONSTANTzz> F
,zzF G
ValuezzH M
=zzN O
intzzP S
.zzS T
ParsezzT Y
(zzY Z
builderzzZ a
.zza b
ToStringzzb j
(zzj k
)zzk l
)zzl m
}zzn o
;zzo p
}{{ 
var}} 
i}} 
=}} 
index}} !
+}}" #
$num}}$ %
;}}% &
while~~ 
(~~ 
i~~ 
<~~ 
code~~ #
.~~# $
Length~~$ *
&&~~+ -
char~~. 2
.~~2 3
IsDigit~~3 :
(~~: ;
code~~; ?
[~~? @
i~~@ A
]~~A B
)~~B C
)~~C D
{ 
builder
ÄÄ 
.
ÄÄ  
Append
ÄÄ  &
(
ÄÄ& '
code
ÄÄ' +
[
ÄÄ+ ,
i
ÄÄ, -
]
ÄÄ- .
.
ÄÄ. /
ToString
ÄÄ/ 7
(
ÄÄ7 8
)
ÄÄ8 9
)
ÄÄ9 :
;
ÄÄ: ;
i
ÅÅ 
++
ÅÅ 
;
ÅÅ !
_currentTokenLength
ÇÇ +
++
ÇÇ+ -
;
ÇÇ- .
}
ÉÉ 
return
ÖÖ 
new
ÖÖ 
Token
ÖÖ $
(
ÖÖ$ %
)
ÖÖ% &
{
ÖÖ' (
Type
ÖÖ) -
=
ÖÖ. /
	TokenType
ÖÖ0 9
.
ÖÖ9 :
CONSTANT
ÖÖ: B
,
ÖÖB C
Value
ÖÖD I
=
ÖÖJ K
int
ÖÖL O
.
ÖÖO P
Parse
ÖÖP U
(
ÖÖU V
builder
ÖÖV ]
.
ÖÖ] ^
ToString
ÖÖ^ f
(
ÖÖf g
)
ÖÖg h
)
ÖÖh i
}
ÖÖj k
;
ÖÖk l
}
ÜÜ 
if
ââ 
(
ââ 
char
ââ 
.
ââ 
IsLetter
ââ !
(
ââ! "
code
ââ" &
[
ââ& '
index
ââ' ,
]
ââ, -
)
ââ- .
)
ââ. /
{
ää !
_currentTokenLength
ãã '
=
ãã( )
$num
ãã* +
;
ãã+ ,
builder
åå 
.
åå 
Append
åå "
(
åå" #
code
åå# '
[
åå' (
index
åå( -
]
åå- .
.
åå. /
ToString
åå/ 7
(
åå7 8
)
åå8 9
)
åå9 :
;
åå: ;
if
éé 
(
éé 
index
éé 
==
éé  
code
éé! %
.
éé% &
Length
éé& ,
-
éé- .
$num
éé/ 0
)
éé0 1
{
èè 
if
ëë 
(
ëë 
keywords
ëë $
.
ëë$ %
ContainsKey
ëë% 0
(
ëë0 1
builder
ëë1 8
.
ëë8 9
ToString
ëë9 A
(
ëëA B
)
ëëB C
)
ëëC D
)
ëëD E
{
íí 
return
ìì "
new
ìì# &
Token
ìì' ,
(
ìì, -
)
ìì- .
{
ìì/ 0
Type
ìì1 5
=
ìì6 7
keywords
ìì8 @
[
ìì@ A
builder
ììA H
.
ììH I
ToString
ììI Q
(
ììQ R
)
ììR S
]
ììS T
,
ììT U
Name
ììV Z
=
ìì[ \
builder
ìì] d
.
ììd e
ToString
ììe m
(
ììm n
)
ììn o
}
ììp q
;
ììq r
}
îî 
return
ññ 
new
ññ "
Token
ññ# (
(
ññ( )
)
ññ) *
{
ññ+ ,
Type
ññ- 1
=
ññ2 3
	TokenType
ññ4 =
.
ññ= >

IDENTIFIER
ññ> H
,
ññH I
Name
ññJ N
=
ññO P
builder
ññQ X
.
ññX Y
ToString
ññY a
(
ñña b
)
ññb c
}
ññd e
;
ññe f
}
óó 
var
ôô 
i
ôô 
=
ôô 
index
ôô !
+
ôô" #
$num
ôô$ %
;
ôô% &
while
öö 
(
öö 
i
öö 
<
öö 
code
öö #
.
öö# $
Length
öö$ *
&&
öö+ -
(
öö. /
char
öö/ 3
.
öö3 4
IsLetter
öö4 <
(
öö< =
code
öö= A
[
ööA B
i
ööB C
]
ööC D
)
ööD E
||
ööF H
char
ööI M
.
ööM N
IsDigit
ööN U
(
ööU V
code
ööV Z
[
ööZ [
i
öö[ \
]
öö\ ]
)
öö] ^
)
öö^ _
)
öö_ `
{
õõ 
builder
úú 
.
úú  
Append
úú  &
(
úú& '
code
úú' +
[
úú+ ,
i
úú, -
]
úú- .
.
úú. /
ToString
úú/ 7
(
úú7 8
)
úú8 9
)
úú9 :
;
úú: ;
i
ùù 
++
ùù 
;
ùù !
_currentTokenLength
ûû +
++
ûû+ -
;
ûû- .
}
üü 
if
¢¢ 
(
¢¢ 
keywords
¢¢  
.
¢¢  !
ContainsKey
¢¢! ,
(
¢¢, -
builder
¢¢- 4
.
¢¢4 5
ToString
¢¢5 =
(
¢¢= >
)
¢¢> ?
)
¢¢? @
)
¢¢@ A
{
££ 
return
§§ 
new
§§ "
Token
§§# (
(
§§( )
)
§§) *
{
§§+ ,
Type
§§- 1
=
§§2 3
keywords
§§4 <
[
§§< =
builder
§§= D
.
§§D E
ToString
§§E M
(
§§M N
)
§§N O
]
§§O P
,
§§P Q
Name
§§R V
=
§§W X
builder
§§Y `
.
§§` a
ToString
§§a i
(
§§i j
)
§§j k
}
§§l m
;
§§m n
}
•• 
return
ßß 
new
ßß 
Token
ßß $
(
ßß$ %
)
ßß% &
{
ßß' (
Type
ßß) -
=
ßß. /
	TokenType
ßß0 9
.
ßß9 :

IDENTIFIER
ßß: D
,
ßßD E
Name
ßßF J
=
ßßK L
builder
ßßM T
.
ßßT U
ToString
ßßU ]
(
ßß] ^
)
ßß^ _
}
ßß` a
;
ßßa b
}
®® 
if
´´ 
(
´´ 
code
´´ 
[
´´ 
index
´´ 
]
´´ 
==
´´  "
$char
´´# &
)
´´& '
{
¨¨ !
_currentTokenLength
≠≠ '
=
≠≠( )
$num
≠≠* +
;
≠≠+ ,
builder
ÆÆ 
.
ÆÆ 
Append
ÆÆ "
(
ÆÆ" #
code
ÆÆ# '
[
ÆÆ' (
index
ÆÆ( -
]
ÆÆ- .
.
ÆÆ. /
ToString
ÆÆ/ 7
(
ÆÆ7 8
)
ÆÆ8 9
)
ÆÆ9 :
;
ÆÆ: ;
if
∞∞ 
(
∞∞ 
index
∞∞ 
==
∞∞  
code
∞∞! %
.
∞∞% &
Length
∞∞& ,
-
∞∞- .
$num
∞∞/ 0
)
∞∞0 1
{
±± 
return
≤≤ 
new
≤≤ "
Token
≤≤# (
(
≤≤( )
)
≤≤) *
{
≤≤+ ,
Type
≤≤- 1
=
≤≤2 3
	TokenType
≤≤4 =
.
≤≤= >
EQUAL
≤≤> C
}
≤≤D E
;
≤≤E F
}
≥≥ 
if
µµ 
(
µµ 
code
µµ 
[
µµ 
index
µµ "
+
µµ# $
$num
µµ% &
]
µµ& '
==
µµ( *
$char
µµ+ .
)
µµ. /
{
∂∂ !
_currentTokenLength
∑∑ +
++
∑∑+ -
;
∑∑- .
return
∏∏ 
new
∏∏ "
Token
∏∏# (
(
∏∏( )
)
∏∏) *
{
∏∏+ ,
Type
∏∏- 1
=
∏∏2 3
	TokenType
∏∏4 =
.
∏∏= >

COMP_EQUAL
∏∏> H
}
∏∏I J
;
∏∏J K
}
ππ 
return
ªª 
new
ªª 
Token
ªª $
(
ªª$ %
)
ªª% &
{
ªª' (
Type
ªª) -
=
ªª. /
	TokenType
ªª0 9
.
ªª9 :
EQUAL
ªª: ?
}
ªª@ A
;
ªªA B
}
ºº 
if
øø 
(
øø 
code
øø 
[
øø 
index
øø 
]
øø 
==
øø  "
$char
øø# &
)
øø& '
{
¿¿ !
_currentTokenLength
¡¡ '
=
¡¡( )
$num
¡¡* +
;
¡¡+ ,
builder
¬¬ 
.
¬¬ 
Append
¬¬ "
(
¬¬" #
code
¬¬# '
[
¬¬' (
index
¬¬( -
]
¬¬- .
.
¬¬. /
ToString
¬¬/ 7
(
¬¬7 8
)
¬¬8 9
)
¬¬9 :
;
¬¬: ;
if
ƒƒ 
(
ƒƒ 
index
ƒƒ 
==
ƒƒ  
code
ƒƒ! %
.
ƒƒ% &
Length
ƒƒ& ,
-
ƒƒ- .
$num
ƒƒ/ 0
)
ƒƒ0 1
{
≈≈ 
return
∆∆ 
new
∆∆ "
Token
∆∆# (
(
∆∆( )
)
∆∆) *
{
∆∆+ ,
Type
∆∆- 1
=
∆∆2 3
	TokenType
∆∆4 =
.
∆∆= >
COMP_SUPPERIOR
∆∆> L
}
∆∆M N
;
∆∆N O
}
«« 
if
…… 
(
…… 
code
…… 
[
…… 
index
…… "
+
……# $
$num
……% &
]
……& '
==
……( *
$char
……+ .
)
……. /
{
   !
_currentTokenLength
ÀÀ +
++
ÀÀ+ -
;
ÀÀ- .
return
ÃÃ 
new
ÃÃ "
Token
ÃÃ# (
(
ÃÃ( )
)
ÃÃ) *
{
ÃÃ+ ,
Type
ÃÃ- 1
=
ÃÃ2 3
	TokenType
ÃÃ4 =
.
ÃÃ= >%
COMP_SUPPERIOR_OR_EQUAL
ÃÃ> U
}
ÃÃV W
;
ÃÃW X
}
ÕÕ 
return
œœ 
new
œœ 
Token
œœ $
(
œœ$ %
)
œœ% &
{
œœ' (
Type
œœ) -
=
œœ. /
	TokenType
œœ0 9
.
œœ9 :
COMP_SUPPERIOR
œœ: H
}
œœI J
;
œœJ K
}
–– 
if
”” 
(
”” 
code
”” 
[
”” 
index
”” 
]
”” 
==
””  "
$char
””# &
)
””& '
{
‘‘ !
_currentTokenLength
’’ '
=
’’( )
$num
’’* +
;
’’+ ,
builder
÷÷ 
.
÷÷ 
Append
÷÷ "
(
÷÷" #
code
÷÷# '
[
÷÷' (
index
÷÷( -
]
÷÷- .
.
÷÷. /
ToString
÷÷/ 7
(
÷÷7 8
)
÷÷8 9
)
÷÷9 :
;
÷÷: ;
if
ÿÿ 
(
ÿÿ 
index
ÿÿ 
==
ÿÿ  
code
ÿÿ! %
.
ÿÿ% &
Length
ÿÿ& ,
-
ÿÿ- .
$num
ÿÿ/ 0
)
ÿÿ0 1
{
ŸŸ 
return
⁄⁄ 
new
⁄⁄ "
Token
⁄⁄# (
(
⁄⁄( )
)
⁄⁄) *
{
⁄⁄+ ,
Type
⁄⁄- 1
=
⁄⁄2 3
	TokenType
⁄⁄4 =
.
⁄⁄= >
COMP_INFERIOR
⁄⁄> K
}
⁄⁄L M
;
⁄⁄M N
}
€€ 
if
›› 
(
›› 
code
›› 
[
›› 
index
›› "
+
››# $
$num
››% &
]
››& '
==
››( *
$char
››+ .
)
››. /
{
ﬁﬁ !
_currentTokenLength
ﬂﬂ +
++
ﬂﬂ+ -
;
ﬂﬂ- .
return
‡‡ 
new
‡‡ "
Token
‡‡# (
(
‡‡( )
)
‡‡) *
{
‡‡+ ,
Type
‡‡- 1
=
‡‡2 3
	TokenType
‡‡4 =
.
‡‡= >$
COMP_INFERIOR_OR_EQUAL
‡‡> T
}
‡‡U V
;
‡‡V W
}
·· 
return
„„ 
new
„„ 
Token
„„ $
(
„„$ %
)
„„% &
{
„„' (
Type
„„) -
=
„„. /
	TokenType
„„0 9
.
„„9 :
COMP_INFERIOR
„„: G
}
„„H I
;
„„I J
}
‰‰ 
if
ÁÁ 
(
ÁÁ 
code
ÁÁ 
[
ÁÁ 
index
ÁÁ 
]
ÁÁ 
==
ÁÁ  "
$char
ÁÁ# &
)
ÁÁ& '
{
ËË !
_currentTokenLength
ÈÈ '
=
ÈÈ( )
$num
ÈÈ* +
;
ÈÈ+ ,
builder
ÍÍ 
.
ÍÍ 
Append
ÍÍ "
(
ÍÍ" #
code
ÍÍ# '
[
ÍÍ' (
index
ÍÍ( -
]
ÍÍ- .
.
ÍÍ. /
ToString
ÍÍ/ 7
(
ÍÍ7 8
)
ÍÍ8 9
)
ÍÍ9 :
;
ÍÍ: ;
if
ÏÏ 
(
ÏÏ 
index
ÏÏ 
==
ÏÏ  
code
ÏÏ! %
.
ÏÏ% &
Length
ÏÏ& ,
-
ÏÏ- .
$num
ÏÏ/ 0
)
ÏÏ0 1
{
ÌÌ 
return
ÓÓ 
new
ÓÓ "
Token
ÓÓ# (
(
ÓÓ( )
)
ÓÓ) *
{
ÓÓ+ ,
Type
ÓÓ- 1
=
ÓÓ2 3
	TokenType
ÓÓ4 =
.
ÓÓ= >
NOT
ÓÓ> A
}
ÓÓB C
;
ÓÓC D
}
ÔÔ 
if
ÒÒ 
(
ÒÒ 
code
ÒÒ 
[
ÒÒ 
index
ÒÒ "
+
ÒÒ# $
$num
ÒÒ% &
]
ÒÒ& '
==
ÒÒ( *
$char
ÒÒ+ .
)
ÒÒ. /
{
ÚÚ !
_currentTokenLength
ÛÛ +
++
ÛÛ+ -
;
ÛÛ- .
return
ÙÙ 
new
ÙÙ "
Token
ÙÙ# (
(
ÙÙ( )
)
ÙÙ) *
{
ÙÙ+ ,
Type
ÙÙ- 1
=
ÙÙ2 3
	TokenType
ÙÙ4 =
.
ÙÙ= >
COMP_DIFFERENT
ÙÙ> L
}
ÙÙM N
;
ÙÙN O
}
ıı 
return
˜˜ 
new
˜˜ 
Token
˜˜ $
(
˜˜$ %
)
˜˜% &
{
˜˜' (
Type
˜˜) -
=
˜˜. /
	TokenType
˜˜0 9
.
˜˜9 :
NOT
˜˜: =
}
˜˜> ?
;
˜˜? @
}
¯¯ !
_currentTokenLength
˙˙ #
++
˙˙# %
;
˙˙% &
switch
˚˚ 
(
˚˚ 
code
˚˚ 
[
˚˚ 
index
˚˚ "
]
˚˚" #
)
˚˚# $
{
¸¸ 
case
˝˝ 
$char
˝˝ 
:
˝˝ 
return
˛˛ 
new
˛˛ "
Token
˛˛# (
(
˛˛( )
)
˛˛) *
{
˛˛+ ,
Type
˛˛- 1
=
˛˛2 3
	TokenType
˛˛4 =
.
˛˛= >
PLUS
˛˛> B
}
˛˛C D
;
˛˛D E
case
ˇˇ 
$char
ˇˇ 
:
ˇˇ 
return
ÄÄ 
new
ÄÄ "
Token
ÄÄ# (
(
ÄÄ( )
)
ÄÄ) *
{
ÄÄ+ ,
Type
ÄÄ- 1
=
ÄÄ2 3
	TokenType
ÄÄ4 =
.
ÄÄ= >
MINUS
ÄÄ> C
}
ÄÄD E
;
ÄÄE F
case
ÅÅ 
$char
ÅÅ 
:
ÅÅ 
return
ÇÇ 
new
ÇÇ "
Token
ÇÇ# (
(
ÇÇ( )
)
ÇÇ) *
{
ÇÇ+ ,
Type
ÇÇ- 1
=
ÇÇ2 3
	TokenType
ÇÇ4 =
.
ÇÇ= >
MULTIPLY
ÇÇ> F
}
ÇÇG H
;
ÇÇH I
case
ÉÉ 
$char
ÉÉ 
:
ÉÉ 
return
ÑÑ 
new
ÑÑ "
Token
ÑÑ# (
(
ÑÑ( )
)
ÑÑ) *
{
ÑÑ+ ,
Type
ÑÑ- 1
=
ÑÑ2 3
	TokenType
ÑÑ4 =
.
ÑÑ= >
DIVIDE
ÑÑ> D
}
ÑÑE F
;
ÑÑF G
case
ÖÖ 
$char
ÖÖ 
:
ÖÖ 
return
ÜÜ 
new
ÜÜ "
Token
ÜÜ# (
(
ÜÜ( )
)
ÜÜ) *
{
ÜÜ+ ,
Type
ÜÜ- 1
=
ÜÜ2 3
	TokenType
ÜÜ4 =
.
ÜÜ= >
MODULO
ÜÜ> D
}
ÜÜE F
;
ÜÜF G
case
áá 
$char
áá 
:
áá 
return
àà 
new
àà "
Token
àà# (
(
àà( )
)
àà) *
{
àà+ ,
Type
àà- 1
=
àà2 3
	TokenType
àà4 =
.
àà= >
POWER
àà> C
}
ààD E
;
ààE F
case
ââ 
$char
ââ 
:
ââ 
return
ää 
new
ää "
Token
ää# (
(
ää( )
)
ää) *
{
ää+ ,
Type
ää- 1
=
ää2 3
	TokenType
ää4 =
.
ää= >
PAR_OPEN
ää> F
}
ääG H
;
ääH I
case
ãã 
$char
ãã 
:
ãã 
return
åå 
new
åå "
Token
åå# (
(
åå( )
)
åå) *
{
åå+ ,
Type
åå- 1
=
åå2 3
	TokenType
åå4 =
.
åå= >
	PAR_CLOSE
åå> G
}
ååH I
;
ååI J
case
çç 
$char
çç 
:
çç 
return
éé 
new
éé "
Token
éé# (
(
éé( )
)
éé) *
{
éé+ ,
Type
éé- 1
=
éé2 3
	TokenType
éé4 =
.
éé= >
BRACKET_OPEN
éé> J
}
ééK L
;
ééL M
case
èè 
$char
èè 
:
èè 
return
êê 
new
êê "
Token
êê# (
(
êê( )
)
êê) *
{
êê+ ,
Type
êê- 1
=
êê2 3
	TokenType
êê4 =
.
êê= >
BRACKET_CLOSE
êê> K
}
êêL M
;
êêM N
case
ëë 
$char
ëë 
:
ëë 
return
íí 
new
íí "
Token
íí# (
(
íí( )
)
íí) *
{
íí+ ,
Type
íí- 1
=
íí2 3
	TokenType
íí4 =
.
íí= >
AND
íí> A
}
ííB C
;
ííC D
case
ìì 
$char
ìì 
:
ìì 
return
îî 
new
îî "
Token
îî# (
(
îî( )
)
îî) *
{
îî+ ,
Type
îî- 1
=
îî2 3
	TokenType
îî4 =
.
îî= >
OR
îî> @
}
îîA B
;
îîB C
case
ïï 
$char
ïï 
:
ïï 
return
ññ 
new
ññ "
Token
ññ# (
(
ññ( )
)
ññ) *
{
ññ+ ,
Type
ññ- 1
=
ññ2 3
	TokenType
ññ4 =
.
ññ= >
	SEMICOLON
ññ> G
}
ññH I
;
ññI J
default
óó 
:
óó 
break
òò 
;
òò 
}
ôô 
throw
õõ 
new
õõ %
NotImplementedException
õõ 1
(
õõ1 2
)
õõ2 3
;
õõ3 4
}
úú 
catch
ùù 
(
ùù %
NotImplementedException
ùù *
e
ùù+ ,
)
ùù, -
{
ûû 
Console
üü 
.
üü 
	WriteLine
üü !
(
üü! "
e
üü" #
.
üü# $
Message
üü$ +
)
üü+ ,
;
üü, -
return
†† 
null
†† 
;
†† 
}
°° 
}
¢¢ 	
}
££ 
}§§ ˘
AD:\Documents\GITrepos\Compil\Compil\Compil\LauncherVM\Launcher.cs
	namespace

 	
Compil


 
.

 

LauncherVM

 
{ 
public 

class 
Launcher 
{ 
private 
readonly 
string 
pathMsm  '
;' (
private 
readonly 
string 
msmProgrammName  /
;/ 0
public 
Launcher 
( 
string 
pathMsm &
,& '
string( .
msmProgrammName/ >
)> ?
{ 	
this 
. 
pathMsm 
= 
pathMsm "
;" #
this 
. 
msmProgrammName  
=! "
msmProgrammName# 2
;2 3
} 	
public 
void 
CopyOutFile 
(  
)  !
{ 	
File 
. 
Copy 
( 
Path 
. 
Combine "
(" #
Environment# .
.. /
CurrentDirectory/ ?
,? @
$strA K
)K L
,L M
Path 
. 
Combine 
( 
pathMsm $
,$ %
$str& 0
)0 1
,1 2
true 
) 
; 
} 	
public 
void 
LaunchCodeOnVm "
(" #
)# $
{   	
Process!! 
process!! 
=!! 
new!! !
Process!!" )
(!!) *
)!!* +
;!!+ ,
process"" 
."" 
	StartInfo"" 
."" 
FileName"" &
=""' (
Path"") -
.""- .
Combine"". 5
(""5 6
$str	""6 †
,
""† °
$str
""¢ Æ
)
""Æ Ø
;
""Ø ∞
process## 
.## 
	StartInfo## 
.## 
WorkingDirectory## .
=##/ 0
this##1 5
.##5 6
pathMsm##6 =
;##= >
process$$ 
.$$ 
	StartInfo$$ 
.$$ 
	Arguments$$ '
=$$( )
$str$$* .
+$$/ 0
msmProgrammName$$1 @
+$$A B
$str$$B Z
;$$Z [
process%% 
.%% 
	StartInfo%% 
.%% 
CreateNoWindow%% ,
=%%- .
false%%/ 4
;%%4 5
process&& 
.&& 
Start&& 
(&& 
)&& 
;&& 
Thread(( 
.(( 
Sleep(( 
((( 
$num(( 
)(( 
;(( 
})) 	
}++ 
},, ñ
8D:\Documents\GITrepos\Compil\Compil\Compil\Nodes\Node.cs
	namespace 	
Compil
 
{ 
public 

class 
Node 
{ 
public 
NodeType 
Type 
{ 
get "
;" #
set$ '
;' (
}) *
public 
string 
Value 
{ 
get !
;! "
set# &
;& '
}( )
public 
List 
< 
Node 
> 
Children "
{# $
get% (
;( )
set* -
;- .
}/ 0
=1 2
new3 6
List7 ;
<; <
Node< @
>@ A
(A B
)B C
;C D
public 
int 
Slot 
{ 
get 
; 
set "
;" #
}$ %
public 
void 
AddChild 
( 
Node !
node" &
)& '
{ 	
Children 
. 
Add 
( 
node 
) 
; 
} 	
public$$ 
void$$ 
AddChildren$$ 
($$  
List$$  $
<$$$ %
Node$$% )
>$$) *
nodes$$+ 0
)$$0 1
{%% 	
foreach&& 
(&& 
var&& 
node&& 
in&&  
nodes&&! &
)&&& '
Children'' 
.'' 
Add'' 
('' 
node'' !
)''! "
;''" #
}(( 	
public// 
void// 
Print// 
(// 
string//  
indent//! '
,//' (
bool//) -
last//. 2
)//2 3
{00 	
Console11 
.11 
Write11 
(11 
indent11  
)11  !
;11! "
if22 
(22 
last22 
)22 
{33 
Console44 
.44 
Write44 
(44 
$str44 #
)44# $
;44$ %
indent55 
+=55 
$str55 
;55 
}66 
else77 
{88 
Console99 
.99 
Write99 
(99 
$str99 "
)99" #
;99# $
indent:: 
+=:: 
$str:: 
;:: 
};; 
if<< 
(<< 
Type<< 
==<< 
NodeType<<  
.<<  !
CONSTANT<<! )
)<<) *
Console>> 
.>> 
	WriteLine>> !
(>>! "
$">>" $
VALUE: >>$ +
{>>+ ,
Value>>, 1
}>>1 2
">>2 3
)>>3 4
;>>4 5
else?? 
if?? 
(?? 
Type?? 
==?? 
NodeType?? $
.??$ %
VARIABLE??% -
)??- .
Console@@ 
.@@ 
	WriteLine@@ !
(@@! "
$"@@" $
VARIABLE: name=@@$ 3
{@@3 4
Value@@4 9
}@@9 :
"@@: ;
)@@; <
;@@< =
elseAA 
ConsoleCC 
.CC 
	WriteLineCC !
(CC! "
TypeCC" &
)CC& '
;CC' (
forEE 
(EE 
varEE 
iEE 
=EE 
$numEE 
;EE 
iEE 
<EE 
ChildrenEE  (
.EE( )
CountEE) .
;EE. /
iEE0 1
++EE1 3
)EE3 4
ChildrenFF 
[FF 
iFF 
]FF 
.FF 
PrintFF !
(FF! "
indentFF" (
,FF( )
iFF* +
==FF, .
ChildrenFF/ 7
.FF7 8
CountFF8 =
-FF> ?
$numFF@ A
)FFA B
;FFB C
}GG 	
}KK 
}LL á
<D:\Documents\GITrepos\Compil\Compil\Compil\Nodes\NodeType.cs
	namespace 	
Compil
 
. 
Nodes 
{ 
public		 

enum		 
NodeType		 
{

 
VARIABLE 
, 
CONSTANT 
, 
MINUS 
, 
PLUS 
, 
NOT 
, 
OP_PLUS 
, 
OP_MINUS 
, 
OP_MULTIPLY 
, 
	OP_DIVIDE 
, 
	OP_MODULO 
, 
OP_POWER 
, 
AFFECT 
, 

COMP_EQUAL 
, 
COMP_DIFFERENT 
, 
COMP_SUPPERIOR 
, 
COMP_INFERIOR   
,   #
COMP_SUPPERIOR_OR_EQUAL!! 
,!!  "
COMP_INFERIOR_OR_EQUAL"" 
,"" 
AND%% 
,%% 
OR&& 

,&&
 
	CONDITION'' 
,'' 
ELSE(( 
,(( 
FOR)) 
,)) 
WHILE** 
,** 
DO++ 

,++
 
SWITCH,, 
,,, 
CASE-- 
,-- 
INT.. 
,.. 
VOID// 
,// 
BLOCK11 
,11 

EXPRESSION22 
,22 
DECLARE33 
}44 
}55 ≤(
5D:\Documents\GITrepos\Compil\Compil\Compil\Program.cs
	namespace 	
Compil
 
{ 
static 

class 
Program 
{ 
static 
void 
Main 
( 
string 
[  
]  !
args" &
)& '
{ 	
try 
{ 
if 
( 
args 
. 
Length 
==  "
$num# $
)$ %
{ 
Help 
( 
) 
; 
Console 
. 
ReadKey #
(# $
)$ %
;% &
return 
; 
} 
Console 
. 
	WriteLine !
(! "
$str" 3
+4 5
args6 :
[: ;
args; ?
.? @
Length@ F
-G H
$numI J
]J K
)K L
;L M
string 
pathFile 
=  !
Path" &
.& '
Combine' .
(. /
args/ 3
[3 4
args4 8
.8 9
Length9 ?
-@ A
$numB C
]C D
)D E
;E F
string 
codeTemp 
=  !
File" &
.& '
ReadAllText' 2
(2 3
pathFile3 ;
); <
;< =
Console   
.   
	WriteLine   !
(  ! "
$str  " 3
)  3 4
;  4 5
Console!! 
.!! 
	WriteLine!! !
(!!! "
codeTemp!!" *
)!!* +
;!!+ ,
Console## 
.## 
	WriteLine## !
(##! "
$str##" >
)##> ?
;##? @
Console$$ 
.$$ 
ReadKey$$ 
($$  
)$$  !
;$$! "
Console%% 
.%% 
	WriteLine%% !
(%%! "
)%%" #
;%%# $
var(( 
lexicalAnalyser(( #
=(($ %
new((& )
LexicalAnalyzer((* 9
(((9 :
codeTemp((: B
,((B C
$num((D E
)((E F
;((F G
var** 
syntaxAnalyzer** "
=**# $
new**% (
SyntaxAnalyzer**) 7
(**7 8
lexicalAnalyser**8 G
)**G H
;**H I
var,, 

fileWriter,, 
=,,  
new,,! $

FileWriter,,% /
(,,/ 0
),,0 1
;,,1 2

fileWriter.. 
... 
InitFile.. #
(..# $
)..$ %
;..% &
var11 
node11 
=11 
syntaxAnalyzer11 )
.11) *
Instruction11* 5
(115 6
)116 7
;117 8
node22 
.22 
Print22 
(22 
$str22 
,22 
false22 $
)22$ %
;22% &
var44 
analyzer44 
=44 
new44 "
SemanticAnalyzer44# 3
(443 4
)444 5
;445 6
analyzer55 
.55 
Analyze55  
(55  !
node55! %
)55% &
;55& '
var77 
codeGenerator77 !
=77" #
new77$ '
CodeGenerator77( 5
(775 6

fileWriter776 @
)77@ A
;77A B
codeGenerator88 
.88 
GenerateCode88 *
(88* +
node88+ /
)88/ 0
;880 1

fileWriter== 
.== 
	WriteFile== $
(==$ %
)==% &
;==& '
ConsoleGG 
.GG 
	WriteLineGG !
(GG! "
$strGG" <
)GG< =
;GG= >
ConsoleHH 
.HH 
ReadKeyHH 
(HH  
)HH  !
;HH! "
}II 
catchJJ 
(JJ $
EncoderFallbackExceptionJJ +
eJJ, -
)JJ- .
{KK 
ConsoleLL 
.LL 
	WriteLineLL !
(LL! "
eLL" #
.LL# $

StackTraceLL$ .
)LL. /
;LL/ 0
}MM 
catchNN 
(NN !
ArgumentNullExceptionNN (
eNN) *
)NN* +
{OO 
ConsolePP 
.PP 
	WriteLinePP !
(PP! "
$strPP" K
)PPK L
;PPL M
ConsoleQQ 
.QQ 
	WriteLineQQ !
(QQ! "
eQQ" #
.QQ# $
MessageQQ$ +
)QQ+ ,
;QQ, -
}RR 
}SS 	
publicYY 
staticYY 
voidYY 
HelpYY 
(YY  
)YY  !
{ZZ 	
Console[[ 
.[[ 
	WriteLine[[ 
([[ 
$str[[ :
)[[: ;
;[[; <
Console\\ 
.\\ 
	WriteLine\\ 
(\\ 
$str\\ 8
)\\8 9
;\\9 :
Console]] 
.]] 
	WriteLine]] 
(]] 
$str]] 6
)]]6 7
;]]7 8
}^^ 	
}__ 
}`` 
ED:\Documents\GITrepos\Compil\Compil\Compil\Properties\AssemblyInfo.cs
[ 
assembly 	
:	 

AssemblyTitle 
( 
$str !
)! "
]" #
[ 
assembly 	
:	 

AssemblyDescription 
( 
$str !
)! "
]" #
[		 
assembly		 	
:			 
!
AssemblyConfiguration		  
(		  !
$str		! #
)		# $
]		$ %
[

 
assembly

 	
:

	 

AssemblyCompany

 
(

 
$str

 
)

 
]

 
[ 
assembly 	
:	 

AssemblyProduct 
( 
$str #
)# $
]$ %
[ 
assembly 	
:	 

AssemblyCopyright 
( 
$str 0
)0 1
]1 2
[ 
assembly 	
:	 

AssemblyTrademark 
( 
$str 
)  
]  !
[ 
assembly 	
:	 

AssemblyCulture 
( 
$str 
) 
] 
[ 
assembly 	
:	 


ComVisible 
( 
false 
) 
] 
[ 
assembly 	
:	 

Guid 
( 
$str 6
)6 7
]7 8
["" 
assembly"" 	
:""	 

AssemblyVersion"" 
("" 
$str"" $
)""$ %
]""% &
[## 
assembly## 	
:##	 

AssemblyFileVersion## 
(## 
$str## (
)##( )
]##) *æ
>D:\Documents\GITrepos\Compil\Compil\Compil\Symbols\NodeType.cs
	namespace 	
Compil
 
. 
Symbols 
{		 
public

 

enum

 

SymbolType

 
{ 
VARIABLE 
, 
FUNCTION 
} 
} ≈
<D:\Documents\GITrepos\Compil\Compil\Compil\Symbols\Symbol.cs
	namespace 	
Compil
 
. 
Symbols 
{ 
public 

class 
Symbol 
{ 
public 
string 
Id 
{ 
get 
; 
set  #
;# $
}% &
public 

SymbolType 
Type 
{  
get! $
;$ %
set& )
;) *
}+ ,
public 
int 
Slot 
{ 
get 
; 
set "
;" #
}$ %
} 
}		 ƒ
>D:\Documents\GITrepos\Compil\Compil\Compil\Utils\FileWriter.cs
	namespace 	
Compil
 
. 
Utils 
{ 
public		 

class		 

FileWriter		 
{

 
private 
readonly 
string 
pathFileCode  ,
;, -
private 
string 
code 
; 
public 

FileWriter 
( 
) 
{ 	
code 
= 
String 
. 
Empty 
;  
pathFileCode 
= 
Path 
.  
Combine  '
(' (
Environment( 3
.3 4
CurrentDirectory4 D
,D E
$strF P
)P Q
;Q R
} 	
public 
void 
InitFile 
( 
) 
{ 	
code 
+= 
$str 
+ 
$str #
;# $
} 	
public$$ 
void$$ 
WriteCommand$$  
($$  !
string$$! '
cmd$$( +
,$$+ ,
bool$$- 1
debug$$2 7
=$$8 9
false$$: ?
)$$? @
{%% 	
code&& 
+=&& 
cmd&& 
+&& 
$str&& 
;&& 
if'' 
('' 
debug'' 
)'' 
{(( 
code)) 
+=)) 
$str)) 
+)) 
$str))  $
;))$ %
code** 
+=** 
$str** 
+** 
$str**  $
;**$ %
}++ 
},, 	
public11 
void11 
	WriteFile11 
(11 
)11 
{22 	
try33 
{44 
code55 
+=55 
$str55 
;55  
code66 
+=66 
$str66 
;66 
if77 
(77 
File77 
.77 
Exists77 
(77  
pathFileCode77  ,
)77, -
)77- .
File88 
.88 
Delete88 
(88  
pathFileCode88  ,
)88, -
;88- .
Console:: 
.:: 
	WriteLine:: !
(::! "
)::" #
;::# $
Console;; 
.;; 
	WriteLine;; !
(;;! "
$str;;" 4
);;4 5
;;;5 6
Console<< 
.<< 
	WriteLine<< !
(<<! "
code<<" &
)<<& '
;<<' (
File>> 
.>> 
WriteAllText>> !
(>>! "
pathFileCode>>" .
,>>. /
code>>0 4
)>>4 5
;>>5 6
}?? 
catch@@ 
(@@ 
	Exception@@ 
e@@ 
)@@ 
{AA 
ConsoleBB 
.BB 
	WriteLineBB !
(BB! "
eBB" #
.BB# $
MessageBB$ +
)BB+ ,
;BB, -
ConsoleCC 
.CC 
	WriteLineCC !
(CC! "
eCC" #
.CC# $

StackTraceCC$ .
)CC. /
;CC/ 0
}DD 
}EE 	
}FF 
}GG Ã
:D:\Documents\GITrepos\Compil\Compil\Compil\Tokens\Token.cs
	namespace 	
Compil
 
{ 
public		 

class		 
Token		 
{

 
public 
string 
Name 
{ 
get  
;  !
set" %
;% &
}' (
public 
int 
Value 
{ 
get 
; 
set  #
;# $
}% &
public 
int 
Line 
{ 
get 
; 
set "
;" #
}$ %
public 
int 
Column 
{ 
get 
;  
set! $
;$ %
}& '
public 
	TokenType 
Type 
{ 
get  #
;# $
set% (
;( )
}* +
} 
} ˜
>D:\Documents\GITrepos\Compil\Compil\Compil\Tokens\TokenType.cs
	namespace 	
Compil
 
. 
Tokens 
{ 
public 

enum 
	TokenType 
{ 

IDENTIFIER 
, 
CONSTANT 
, 
END_OF_FILE		 
,		 
NOT 
, 
PLUS 
, 
MINUS 
, 
MULTIPLY 
, 
DIVIDE 
, 
MODULO 
, 
POWER 
, 
IF 

,
 
ELSE 
, 
FOR 
, 
WHILE 
, 
DO 

,
 
SWITCH 
, 
CASE 
, 
INT 
, 
VOID 
, 

COMP_EQUAL 
, 
COMP_DIFFERENT 
, 
COMP_SUPPERIOR   
,   
COMP_INFERIOR!! 
,!! #
COMP_SUPPERIOR_OR_EQUAL"" 
,""  "
COMP_INFERIOR_OR_EQUAL## 
,## 
PAR_OPEN%% 
,%% 
	PAR_CLOSE&& 
,&& 
OR(( 

,((
 
AND)) 
,)) 
EQUAL++ 
,++ 
BRACKET_OPEN.. 
,.. 
BRACKET_CLOSE// 
,// 
	SEMICOLON11 
,11 
COMA22 
,22 
COMMENT_LINE33 
,33 
COMMENT_BLOCK_START44 
,44 
COMMENT_BLOCK_END55 
,55 
VAR77 
}88 
}99 ·
<D:\Documents\GITrepos\Compil\Compil\Compil\Utils\Operator.cs
	namespace 	
Compil
 
. 
Utils 
{ 
public 

class 
Operator 
{ 
public 
Token 
Token 
{ 
get  
;  !
set" %
;% &
}' (
public 
Node 
Node 
{ 
get 
; 
set  #
;# $
}% &
public 
int 
Priority 
{ 
get !
;! "
set# &
;& '
}( )
public 
int 
Association 
{  
get! $
;$ %
set& )
;) *
}+ ,
}		 
}

 